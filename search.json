[
  {
    "objectID": "Mathematical Analysis I/lec_1.html",
    "href": "Mathematical Analysis I/lec_1.html",
    "title": "2. Complex Numbers, MI",
    "section": "",
    "text": "1. Summary\n\n1.1 Set Theory Fundamentals\nA set is a collection of distinct objects, referred to as elements or members. The fundamental idea is that a set is defined purely by the elements it contains, not by the order in which they are listed.\nSets of numbers are foundational in mathematics:\n\nNatural Numbers (\\(\\mathbb{N}\\)): The set of positive counting numbers, \\(\\{1, 2, 3, \\dots\\}\\).\nIntegers (\\(\\mathbb{Z}\\)): The set of all whole numbers, including positive, negative, and zero, \\(\\{\\dots, -2, -1, 0, 1, 2, \\dots\\}\\).\nRational Numbers (\\(\\mathbb{Q}\\)): Numbers that can be expressed as a fraction \\(p/q\\), where \\(p\\) and \\(q\\) are integers and \\(q \\neq 0\\).\nIrrational Numbers (\\(\\mathbb{R} \\setminus \\mathbb{Q}\\)): Numbers that cannot be expressed as a simple fraction, like \\(\\pi\\) or \\(\\sqrt{2}\\).\nReal Numbers (\\(\\mathbb{R}\\)): The set combining both rational and irrational numbers.\nComplex Numbers (\\(\\mathbb{C}\\)): Numbers that extend the real number line, which will be discussed in detail.\n\nThere are several key concepts and operations related to sets:\n\nSubset: A set \\(A\\) is a subset of set \\(X\\) (denoted \\(A \\subseteq X\\)) if every element of \\(A\\) is also an element of \\(X\\). If \\(A\\) is a subset but is not equal to \\(X\\), it is a proper subset (\\(A \\subset X\\)).\nPower Set (\\(\\mathcal{P}(X)\\)): The set of all possible subsets of a given set \\(X\\). If \\(X\\) has \\(n\\) elements, its power set will have \\(2^n\\) elements.\nUnion (\\(A \\cup B\\)): The set containing all elements that are in set \\(A\\), or in set \\(B\\), or in both.\nIntersection (\\(A \\cap B\\)): The set containing only the elements that are common to both set \\(A\\) and set \\(B\\).\nComplement (\\(A^c\\)): The set of all elements in the universal set \\(X\\) that are not in set \\(A\\).\n\n\n\n\n1.2 Introduction to Complex Numbers\nA complex number is an extension of the real number system that allows for the square root of negative numbers. It is written in the standard form: \\[ z = a + bi \\] where:\n\n\\(a\\) and \\(b\\) are real numbers.\n\\(a\\) is the real part of the complex number, denoted as \\(\\text{Re}(z)\\).\n\\(b\\) is the imaginary part, denoted as \\(\\text{Im}(z)\\).\n\\(i\\) is the imaginary unit, defined by the property \\(i^2 = -1\\), or \\(i = \\sqrt{-1}\\).\n\nFor example, in the complex number \\(3 + 4i\\), the real part is 3, and the imaginary part is 4.\n\n\n1.3 Geometric Representation of Complex Numbers\nComplex numbers can be visualized as points or vectors on a two-dimensional plane called the complex plane or Argand plane.\n\nThe horizontal axis represents the real part (\\(a\\)).\nThe vertical axis represents the imaginary part (\\(b\\)).\n\nA complex number \\(z = a + bi\\) corresponds to the point \\((a, b)\\) on this plane. This geometric view allows us to define two important properties:\n\nModulus (\\(r\\)): The distance of the point \\((a, b)\\) from the origin. It is also known as the absolute value of the complex number, \\(|z|\\). It is calculated using the Pythagorean theorem: \\(r = |z| = \\sqrt{a^2 + b^2}\\).\nArgument (\\(\\theta\\)): The angle that the line connecting the origin to the point \\((a, b)\\) makes with the positive real axis. It is calculated as \\(\\theta = \\tan^{-1}(b/a)\\), ensuring the angle is in the correct quadrant.\n\n\n\n1.4 Trigonometric and Exponential Forms\nBesides the standard form \\(a+bi\\), complex numbers can be expressed in other ways that are useful for certain operations.\n\nTrigonometric Form: Using the modulus \\(r\\) and argument \\(\\theta\\), we can express the real and imaginary parts as \\(a = r\\cos\\theta\\) and \\(b = r\\sin\\theta\\). Substituting these into the standard form gives: \\[ z = r(\\cos\\theta + i\\sin\\theta) \\]\nExponential (or Polar) Form: This form is derived from Euler’s Formula, a fundamental relationship in mathematics: \\[ e^{i\\theta} = \\cos\\theta + i\\sin\\theta \\] By substituting this into the trigonometric form, we get the compact exponential form: \\[ z = re^{i\\theta} \\]\n\n\n\n1.5 De Moivre’s Theorem\nDe Moivre’s Theorem provides a straightforward method for calculating the power of a complex number when it is in trigonometric form. For any complex number \\(z = r(\\cos\\theta + i\\sin\\theta)\\) and any integer \\(n\\), the theorem states: \\[ z^n = r^n(\\cos(n\\theta) + i\\sin(n\\theta)) \\] In exponential form, this is equivalent to \\((re^{i\\theta})^n = r^n e^{in\\theta}\\). This theorem is incredibly useful for finding powers and roots of complex numbers efficiently.\n\n\n1.6 Principles of Mathematical Induction\nMathematical induction is a powerful and rigorous proof technique used to demonstrate that a statement, property, or formula is true for all natural numbers (or all integers from a certain starting point). It does not rely on observation or patterns but on logical deduction. The process is often compared to the domino effect: if you knock over the first domino, and you know that each domino will knock over the next, then all the dominoes will eventually fall.\nA proof by induction consists of three main steps:\n\nBase Case: Verify that the statement holds true for the first value, usually \\(n=1\\). This is like knocking over the first domino.\nInductive Hypothesis: Assume that the statement is true for an arbitrary natural number, \\(k\\). This is the assumption that some domino, the \\(k\\)-th one, falls.\nInductive Step: Prove that if the statement is true for \\(k\\), it must also be true for the next number, \\(k+1\\). This establishes the link—that if the \\(k\\)-th domino falls, it will knock over the (\\(k+1\\))-th domino.\n\nOnce these steps are completed, the principle of mathematical induction allows us to conclude that the statement is true for all natural numbers \\(n\\).\n\n\n\n2. Definitions\n\nSet: A collection of distinct objects or elements.\nComplex Number: A number of the form \\(a + bi\\), where \\(a\\) and \\(b\\) are real numbers and \\(i\\) is the imaginary unit.\nImaginary Unit (\\(i\\)): The number defined by the property \\(i^2 = -1\\).\nComplex Plane: A two-dimensional plane used to represent complex numbers geometrically, with a real axis and an imaginary axis.\nModulus (\\(r\\) or \\(|z|\\)): The magnitude or absolute value of a complex number, representing its distance from the origin on the complex plane.\nArgument (\\(\\theta\\)): The angle of a complex number’s vector on the complex plane, measured from the positive real axis.\nEuler’s Formula: The identity \\(e^{i\\theta} = \\cos\\theta + i\\sin\\theta\\) that links complex exponentials with trigonometric functions.\nDe Moivre’s Theorem: A formula used to compute powers of complex numbers in trigonometric form: \\(z^n = r^n(\\cos(n\\theta) + i\\sin(n\\theta))\\).\nMathematical Induction: A formal proof technique used to establish the truth of a statement for all natural numbers.\n\n\n\n3. Formulas\n\nStandard Form of a Complex Number: \\(z = a + bi\\)\nImaginary Unit: \\(i = \\sqrt{-1}\\)\nModulus of a Complex Number: \\(r = |z| = \\sqrt{a^2 + b^2}\\)\nArgument of a Complex Number: \\(\\theta = \\arctan(b/a)\\)\nTrigonometric Form: \\(z = r(\\cos\\theta + i\\sin\\theta)\\)\nEuler’s Formula: \\(e^{i\\theta} = \\cos\\theta + i\\sin\\theta\\)\nExponential (Polar) Form: \\(z = re^{i\\theta}\\)\nDe Moivre’s Theorem: \\(z^n = r^n(\\cos(n\\theta) + i\\sin(n\\theta))\\)\n\n\n\n4. Mistakes\n\nForgetting the Quadrant for the Argument: Simply using \\(\\theta = \\tan^{-1}(b/a)\\) can give the wrong angle if the complex number is not in the first or fourth quadrant. Why it’s wrong: The arctan function on most calculators has a limited range (typically \\((-\\pi/2, \\pi/2)\\)), so you must adjust the angle based on the signs of \\(a\\) and \\(b\\) to place it in the correct quadrant.\nConfusing the Imaginary Part: Stating that the imaginary part of \\(a+bi\\) is \\(bi\\). Why it’s wrong: The imaginary part is just the real number coefficient \\(b\\), not the term with \\(i\\).\nSkipping the Base Case in Induction: Starting an induction proof with the inductive hypothesis without first proving the statement is true for \\(n=1\\). Why it’s wrong: The entire chain of logic depends on the first “domino” falling. Without a true base case, the proof is invalid.\nAssuming P(k+1) is True: In the inductive step, assuming the conclusion for \\(k+1\\) is true, rather than using the assumption for \\(k\\) to prove the case for \\(k+1\\). Why it’s wrong: This is circular reasoning. The goal is to prove the implication if P(k) is true, then P(k+1) is true, not to assume it.\nIncorrectly Applying De Moivre’s Theorem: Applying the theorem to a complex number that is not in trigonometric or polar form. Why it’s wrong: The theorem explicitly requires the modulus \\(r\\) and argument \\(\\theta\\) to work. You cannot simply raise the real and imaginary parts to the power \\(n\\).\n\n\n\n5. Examples\n\n5.1. Complex Number Arithmetic\nQuestion: Express \\((2+3i)^2\\) in the form \\(X+Yi\\).\n\n\nClick to see the solution\n\n\nExpand the expression: Use the formula \\((a+b)^2 = a^2 + 2ab + b^2\\). \\[ (2+3i)^2 = 2^2 + 2(2)(3i) + (3i)^2 \\]\nSimplify the terms: \\[ 4 + 12i + 9i^2 \\]\nSubstitute \\(i^2 = -1\\): \\[ 4 + 12i + 9(-1) \\] \\[ 4 + 12i - 9 \\]\nCombine the real parts: \\[ (4 - 9) + 12i = -5 + 12i \\]\n\nAnswer: The result is \\(-5 + 12i\\).\n\n\n\n5.2. Complex Number Division\nQuestion: Find the values of \\(P\\) and \\(Q\\) if \\(P+Qi = \\frac{3-i}{1+i}\\).\n\n\nClick to see the solution\n\n\nMultiply by the complex conjugate: To remove the imaginary unit from the denominator, multiply the numerator and denominator by the conjugate of \\(1+i\\), which is \\(1-i\\). \\[ \\frac{3-i}{1+i} \\times \\frac{1-i}{1-i} \\]\nExpand the numerator: \\[ (3-i)(1-i) = 3 - 3i - i + i^2 = 3 - 4i - 1 = 2 - 4i \\]\nExpand the denominator: \\[ (1+i)(1-i) = 1^2 - i^2 = 1 - (-1) = 2 \\]\nCombine and simplify: \\[ \\frac{2-4i}{2} = 1 - 2i \\]\nIdentify P and Q: By comparing \\(1-2i\\) with \\(P+Qi\\), we find \\(P=1\\) and \\(Q=-2\\).\n\nAnswer: \\(P=1\\), \\(Q=-2\\).\n\n\n\n5.3. Convert to Trigonometric/Exponential Form\nQuestion: Write the complex number \\(Z = 1+i\\) in trigonometric and exponential forms.\n\n\nClick to see the solution\n\n\nIdentify \\(a\\) and \\(b\\): For \\(Z=1+i\\), we have \\(a=1\\) and \\(b=1\\).\nCalculate the modulus (\\(r\\)): \\[ r = \\sqrt{a^2 + b^2} = \\sqrt{1^2 + 1^2} = \\sqrt{2} \\]\nCalculate the argument (\\(\\theta\\)): \\[ \\theta = \\tan^{-1}\\left(\\frac{b}{a}\\right) = \\tan^{-1}\\left(\\frac{1}{1}\\right) = \\frac{\\pi}{4} \\text{ radians} \\] Since \\(a\\) and \\(b\\) are both positive, the point is in the first quadrant, so this angle is correct.\nWrite the trigonometric form: \\(Z = r(\\cos\\theta + i\\sin\\theta)\\) \\[ Z = \\sqrt{2}\\left(\\cos\\left(\\frac{\\pi}{4}\\right) + i\\sin\\left(\\frac{\\pi}{4}\\right)\\right) \\]\nWrite the exponential form: \\(Z = re^{i\\theta}\\) \\[ Z = \\sqrt{2}e^{i\\frac{\\pi}{4}} \\]\n\nAnswer: Trigonometric form is \\(\\sqrt{2}(\\cos(\\pi/4) + i\\sin(\\pi/4))\\) and exponential form is \\(\\sqrt{2}e^{i\\pi/4}\\).\n\n\n\n5.4. Apply De Moivre’s Theorem\nQuestion: Using De Moivre’s Theorem, simplify \\(Z = (2+2i)^3\\).\n\n\nClick to see the solution\n\n\nConvert to trigonometric form: First, we need to express \\(2+2i\\) in the form \\(r(\\cos\\theta + i\\sin\\theta)\\).\n\n\\(a=2, b=2\\)\nModulus: \\(r = \\sqrt{2^2+2^2} = \\sqrt{8} = 2\\sqrt{2}\\).\nArgument: \\(\\theta = \\tan^{-1}(2/2) = \\tan^{-1}(1) = \\pi/4\\).\nSo, \\(2+2i = 2\\sqrt{2}(\\cos(\\pi/4) + i\\sin(\\pi/4))\\).\n\nApply De Moivre’s Theorem: \\(Z^n = r^n(\\cos(n\\theta) + i\\sin(n\\theta))\\) with \\(n=3\\). \\[ Z = (2\\sqrt{2})^3 \\left(\\cos\\left(3 \\cdot \\frac{\\pi}{4}\\right) + i\\sin\\left(3 \\cdot \\frac{\\pi}{4}\\right)\\right) \\]\nSimplify the expression:\n\n\\((2\\sqrt{2})^3 = 8 \\cdot (\\sqrt{2})^3 = 8 \\cdot 2\\sqrt{2} = 16\\sqrt{2}\\).\n\\(\\cos(3\\pi/4) = -\\frac{\\sqrt{2}}{2}\\)\n\\(\\sin(3\\pi/4) = \\frac{\\sqrt{2}}{2}\\)\n\nSubstitute the values back: \\[ Z = 16\\sqrt{2} \\left(-\\frac{\\sqrt{2}}{2} + i\\frac{\\sqrt{2}}{2}\\right) \\]\nDistribute and simplify: \\[ Z = -16\\sqrt{2} \\cdot \\frac{\\sqrt{2}}{2} + i \\cdot 16\\sqrt{2} \\cdot \\frac{\\sqrt{2}}{2} \\] \\[ Z = -16 \\cdot \\frac{2}{2} + i \\cdot 16 \\cdot \\frac{2}{2} \\] \\[ Z = -16 + 16i \\]\n\nAnswer: The simplified form is \\(-16 + 16i\\).\n\n\n\n5.5. Induction with Divisibility\nQuestion: Use mathematical induction to show that for all positive integers \\(n\\), \\(P(n) = 5^{2n} + 3n - 1\\) is an integer multiple of 9.\n\n\nClick to see the solution\n\n\nBase Case (n=1): \\[ P(1) = 5^{2(1)} + 3(1) - 1 = 25 + 3 - 1 = 27 \\] Since \\(27 = 9 \\times 3\\), the statement holds for \\(n=1\\).\nInductive Hypothesis: Assume the statement is true for some positive integer \\(k\\). That is, assume \\(5^{2k} + 3k - 1\\) is a multiple of 9. This means \\(5^{2k} + 3k - 1 = 9m\\) for some integer \\(m\\). We can rearrange this as \\(5^{2k} = 9m - 3k + 1\\).\nInductive Step: We must show that \\(P(k+1) = 5^{2(k+1)} + 3(k+1) - 1\\) is also a multiple of 9. \\[ P(k+1) = 5^{2k+2} + 3k + 3 - 1 \\] \\[ P(k+1) = 5^2 \\cdot 5^{2k} + 3k + 2 \\] \\[ P(k+1) = 25 \\cdot 5^{2k} + 3k + 2 \\] Now, substitute \\(5^{2k}\\) from our hypothesis: \\[ P(k+1) = 25(9m - 3k + 1) + 3k + 2 \\] \\[ P(k+1) = 225m - 75k + 25 + 3k + 2 \\] \\[ P(k+1) = 225m - 72k + 27 \\] Factor out a 9: \\[ P(k+1) = 9(25m - 8k + 3) \\] Since \\(m\\) and \\(k\\) are integers, \\((25m - 8k + 3)\\) is also an integer. Thus, \\(P(k+1)\\) is a multiple of 9.\n\nAnswer: By the principle of mathematical induction, the statement is true for all positive integers \\(n\\).\n\n\n\n5.6. Induction with Products\nQuestion: Use mathematical induction to show that for all positive integers \\(n\\), \\(P(n) = n(n+1)(n+2)\\) is an integer multiple of 6.\n\n\nClick to see the solution\n\n\nBase Case (n=1): \\[ P(1) = 1(1+1)(1+2) = 1 \\cdot 2 \\cdot 3 = 6 \\] Since \\(6 = 6 \\times 1\\), the statement holds for \\(n=1\\).\nInductive Hypothesis: Assume the statement is true for some positive integer \\(k\\). That is, assume \\(k(k+1)(k+2) = 6m\\) for some integer \\(m\\).\nInductive Step: We must show that \\(P(k+1) = (k+1)(k+2)(k+3)\\) is a multiple of 6. \\[ P(k+1) = (k+1)(k+2)(k+3) \\] \\[ P(k+1) = (k(k+1)(k+2)) + 3(k+1)(k+2) \\] From our hypothesis, we know \\(k(k+1)(k+2)\\) is a multiple of 6. So we can write: \\[ P(k+1) = 6m + 3(k+1)(k+2) \\] Now we need to show that \\(3(k+1)(k+2)\\) is also a multiple of 6. Notice that \\((k+1)\\) and \\((k+2)\\) are two consecutive integers. One of them must be an even number. Let’s say \\((k+1)(k+2) = 2p\\) for some integer \\(p\\). \\[ P(k+1) = 6m + 3(2p) = 6m + 6p = 6(m+p) \\] Since \\(m\\) and \\(p\\) are integers, \\((m+p)\\) is also an integer. Thus, \\(P(k+1)\\) is a multiple of 6.\n\nAnswer: By the principle of mathematical induction, the statement is true for all positive integers \\(n\\).\n\n\n\n5.7. Induction with Exponents\nQuestion: Use mathematical induction to show that for all positive integers \\(n\\), \\(P(n) = 7^{2n+1} + 1\\) is an integer multiple of 8.\n\n\nClick to see the solution\n\n\nBase Case (n=1): \\[ P(1) = 7^{2(1)+1} + 1 = 7^3 + 1 = 343 + 1 = 344 \\] Since \\(344 = 8 \\times 43\\), the statement holds for \\(n=1\\).\nInductive Hypothesis: Assume the statement is true for some positive integer \\(k\\). That is, assume \\(7^{2k+1} + 1 = 8m\\) for some integer \\(m\\). We can rearrange this as \\(7^{2k+1} = 8m - 1\\).\nInductive Step: We must show that \\(P(k+1) = 7^{2(k+1)+1} + 1\\) is a multiple of 8. \\[ P(k+1) = 7^{2k+2+1} + 1 = 7^{2k+3} + 1 \\] \\[ P(k+1) = 7^2 \\cdot 7^{2k+1} + 1 \\] \\[ P(k+1) = 49 \\cdot 7^{2k+1} + 1 \\] Now, substitute \\(7^{2k+1}\\) from our hypothesis: \\[ P(k+1) = 49(8m - 1) + 1 \\] \\[ P(k+1) = 392m - 49 + 1 \\] \\[ P(k+1) = 392m - 48 \\] Factor out an 8: \\[ P(k+1) = 8(49m - 6) \\] Since \\(m\\) is an integer, \\((49m - 6)\\) is also an integer. Thus, \\(P(k+1)\\) is a multiple of 8.\n\nAnswer: By the principle of mathematical induction, the statement is true for all positive integers \\(n\\).",
    "crumbs": [
      "Mathematical Analysis I",
      "2. Complex Numbers, MI"
    ]
  },
  {
    "objectID": "Mathematical Analysis I/lec_2.html",
    "href": "Mathematical Analysis I/lec_2.html",
    "title": "2. Complex Numbers, Set Theory, Real Numbers, and MI",
    "section": "",
    "text": "1. Summary\n\n1.1 Complex Numbers in Trigonometric Form\nA complex number is a number that can be expressed in the form \\(z = x + iy\\), where x and y are real numbers, and \\(i\\) is the imaginary unit, satisfying the equation \\(i^2 = -1\\). Here, x is the real part and y is the imaginary part. While this is the standard Cartesian form, the trigonometric form (also known as polar form) is often more convenient for operations like multiplication and exponentiation.\nTo convert a complex number to its trigonometric form, we need two components: the modulus and the argument.\n\n\n1.1.1 Modulus\nThe modulus of a complex number, denoted as \\(r\\) or \\(|z|\\), represents its distance from the origin (0,0) in the complex plane. It’s a non-negative real number calculated using a formula analogous to the Pythagorean theorem. \\[\nr = |z| = \\sqrt{x^2 + y^2}\n\\]\n\n\n1.1.2 Argument\nThe argument of a complex number, denoted by \\(\\theta\\), is the angle formed by the positive real axis and the line segment connecting the origin to the point \\(z = x + iy\\) in the complex plane. The angle is measured in radians and is typically in the interval \\([0, 2\\pi)\\).\nThe argument can be determined from the relations: \\[\n\\cos\\theta = \\frac{x}{r}, \\quad \\sin\\theta = \\frac{y}{r}, \\quad \\tan\\theta = \\frac{y}{x}\n\\] However, using \\(\\theta = \\arctan(y/x)\\) directly is insufficient because the arctan function only returns values in \\((-\\pi/2, \\pi/2)\\), which covers only Quadrants I and IV. To find the correct angle, you must consider the signs of x and y to identify the correct quadrant:\n\nQuadrant I (\\(x &gt; 0, y \\ge 0\\)): \\(\\theta = \\arctan(y/x)\\)\nQuadrant II (\\(x &lt; 0, y &gt; 0\\)): \\(\\theta = \\arctan(y/x) + \\pi\\)\nQuadrant III (\\(x &lt; 0, y &lt; 0\\)): \\(\\theta = \\arctan(y/x) + \\pi\\)\nQuadrant IV (\\(x &gt; 0, y &lt; 0\\)): \\(\\theta = \\arctan(y/x) + 2\\pi\\)\n\n\n\n1.1.3 The Trigonometric Form\nOnce the modulus \\(r\\) and argument \\(\\theta\\) are found, the complex number can be written in its trigonometric form: \\[\nz = r(\\cos\\theta + i\\sin\\theta)\n\\]\n\n\n\n1.2 De Moivre’s Theorem and Its Applications\n\n1.2.1 Powers of Complex Numbers\nDe Moivre’s Theorem provides a straightforward method for raising a complex number in trigonometric form to an integer power. It states that to raise a complex number to the power \\(n\\), you raise the modulus to the power \\(n\\) and multiply the argument by \\(n\\). \\[\n[r(\\cos\\theta + i\\sin\\theta)]^n = r^n(\\cos(n\\theta) + i\\sin(n\\theta))\n\\]\n\n\n1.2.2 Roots of Complex Numbers\nThe theorem can be extended to find the n-th roots of a complex number. A complex number \\(z\\) has exactly \\(n\\) distinct n-th roots, which are evenly spaced on a circle in the complex plane. The formula for the roots is: \\[\n\\sqrt[n]{z} = \\sqrt[n]{r} \\left( \\cos\\left(\\frac{\\theta + 2k\\pi}{n}\\right) + i\\sin\\left(\\frac{\\theta + 2k\\pi}{n}\\right) \\right)\n\\] where \\(k\\) is an integer that ranges from \\(0\\) to \\(n-1\\).\n\n\n\n1.3 Geometric Representation of Complex Numbers\nEvery complex number \\(z = x + iy\\) corresponds to a unique point \\((x,y)\\) in a two-dimensional plane called the complex plane. The horizontal axis is the real axis, and the vertical axis is the imaginary axis.\nThe expression \\(|z - a| = r\\) describes the set of all points \\(z\\) that are at a fixed distance \\(r\\) from a central point \\(a\\). Geometrically, this represents a circle centered at \\(a\\) with radius \\(r\\).\n\n\\(|z - a| \\le r\\) describes a closed disk (the circle and its interior).\n\\(|z - a| &lt; r\\) describes an open disk (the interior of the circle only).\n\\(|z - a| \\ge r\\) describes the exterior of a disk including its boundary.\n\n\n\n1.4 Introduction to Set Theory\nA set is a well-defined collection of distinct objects, which are called elements or members of the set. The language of sets is fundamental to modern mathematics.\n\n1.4.1 Basic Notation and Definitions\n\nElement of a set: If an object x is an element of a set A, we write \\(x \\in A\\). If not, we write \\(x \\notin A\\).\nEmpty Set: A set with no elements is called the empty set, denoted by \\(\\emptyset\\) or \\(\\{\\}\\).\nSubset: A set A is a subset of a set B if every element of A is also an element of B. This is denoted \\(A \\subset B\\).\nEquality: Two sets A and B are equal if they contain exactly the same elements. This means \\(A \\subset B\\) and \\(B \\subset A\\).\n\n\n\n1.4.2 Set Operations\n\nUnion (\\(\\cup\\)): The union of two sets A and B, written \\(A \\cup B\\), is the set containing all elements that are in A, or in B, or in both.\nIntersection (\\(\\cap\\)): The intersection of A and B, written \\(A \\cap B\\), is the set containing all elements that are in both A and B.\nDifference (\\(\\setminus\\)): The difference of A and B, written \\(A \\setminus B\\), is the set of all elements that are in A but not in B.\nComplement (\\(A^c\\)): If there is a universal set U, the complement of A is the set of all elements in U that are not in A, i.e., \\(A^c = U \\setminus A\\).\n\n\n\n\n1.5 The Real Number System\nThe real numbers (\\(\\mathbb{R}\\)) form the foundation of calculus and analysis. They can be visualized as all points on an infinitely long number line. They are defined by a set of axioms and contain several important subsets.\n\n1.5.1 Subsets of Real Numbers\n\nNatural Numbers (\\(\\mathbb{N}\\)): The counting numbers: \\(\\{1, 2, 3, \\dots\\}\\).\nIntegers (\\(\\mathbb{Z}\\)): All whole numbers, both positive, negative, and zero: \\(\\{\\dots, -2, -1, 0, 1, 2, \\dots\\}\\).\nRational Numbers (\\(\\mathbb{Q}\\)): Numbers that can be expressed as a fraction \\(p/q\\), where p and q are integers and \\(q \\neq 0\\). Their decimal representations are either terminating or repeating.\nIrrational Numbers: Real numbers that cannot be expressed as a simple fraction. Their decimal representations are non-terminating and non-repeating (e.g., \\(\\pi, \\sqrt{2}, e\\)).\n\n\n\n1.5.2 Key Properties of Real Numbers\n\nArchimedean Property: This property states that for any two positive real numbers x and y, there is an integer n such that \\(nx &gt; y\\). Intuitively, this means there are no “infinitely large” or “infinitely small” real numbers.\nDensity: The rational and irrational numbers are dense in the real numbers. This means that between any two distinct real numbers, you can always find another rational number and another irrational number.\n\n\n\n1.5.3 Countability\nA set is countable if its elements can be put into a one-to-one correspondence with the natural numbers. The sets \\(\\mathbb{N}\\), \\(\\mathbb{Z}\\), and \\(\\mathbb{Q}\\) are all countable. An infinite set that is not countable is called uncountable. The set of real numbers (\\(\\mathbb{R}\\)) is uncountable, which implies that in a sense, there are “more” real numbers than rational numbers.\n\n\n\n1.6 Mathematical Induction\nThe Principle of Mathematical Induction is a powerful proof technique used to prove that a statement \\(P(n)\\) is true for all natural numbers \\(n\\) (or all integers from a certain starting point). It is often compared to a domino effect.\n\nTo prove a statement by induction, two steps are required: 1. Base Case: Prove that the statement is true for the first value, usually \\(n=1\\). (This is like tipping over the first domino). 2. Inductive Step: Assume that the statement is true for an arbitrary natural number \\(k\\), i.e., assume \\(P(k)\\) is true (this is the inductive hypothesis). Then, using this assumption, prove that the statement must also be true for the next number, \\(k+1\\), i.e., prove \\(P(k+1)\\) is true. (This is like proving that if any given domino falls, it will knock over the next one).\nIf both steps are successfully completed, the principle of mathematical induction guarantees that the statement is true for all natural numbers \\(n\\).\n\n\n\n2. Definitions\n\nComplex Number: A number of the form \\(x + iy\\), where x and y are real numbers and \\(i = \\sqrt{-1}\\).\nModulus: The distance of a complex number from the origin in the complex plane, given by \\(r = |z| = \\sqrt{x^2 + y^2}\\).\nArgument: The angle \\(\\theta\\) a complex number makes with the positive real axis in the complex plane.\nDe Moivre’s Theorem: A formula for computing powers of complex numbers, stating that \\([r(\\cos\\theta + i\\sin\\theta)]^n = r^n(\\cos(n\\theta) + i\\sin(n\\theta))\\).\nSet: A collection of distinct objects, known as elements or members.\nSubset: A set A is a subset of B if all elements of A are also elements of B.\nUnion: The set of elements present in either of two sets.\nIntersection: The set of elements that two sets have in common.\nCountable Set: An infinite set whose elements can be listed in a one-to-one correspondence with the natural numbers.\nUncountable Set: An infinite set that is not countable.\nMathematical Induction: A proof technique to establish that a given statement is true for all natural numbers.\n\n\n\n3. Formulas\n\nModulus: \\(r = |z| = \\sqrt{x^2 + y^2}\\)\nArgument Relations: \\(\\cos\\theta = x/r, \\sin\\theta = y/r\\)\nTrigonometric Form: \\(z = r(\\cos\\theta + i\\sin\\theta)\\)\nDe Moivre’s Theorem (Powers): \\([r(\\cos\\theta + i\\sin\\theta)]^n = r^n(\\cos(n\\theta) + i\\sin(n\\theta))\\)\nDe Moivre’s Theorem (Roots): \\(\\sqrt[n]{z} = \\sqrt[n]{r} \\left( \\cos\\left(\\frac{\\theta + 2k\\pi}{n}\\right) + i\\sin\\left(\\frac{\\theta + 2k\\pi}{n}\\right) \\right)\\) for \\(k = 0, 1, \\dots, n-1\\)\nDe Morgan’s Laws: \\((A \\cup B)^c = A^c \\cap B^c\\) and \\((A \\cap B)^c = A^c \\cup B^c\\)\n\n\n\n4. Mistakes\n\nIncorrectly Calculating the Argument (\\(\\theta\\)): A common mistake is using \\(\\theta = \\arctan(y/x)\\) without considering the signs of x and y. Why it’s wrong: The arctan function has a limited range and will give the wrong angle for complex numbers in the second and third quadrants. You must adjust the angle by adding \\(\\pi\\) (or using other methods) based on the quadrant.\nApplying De Moivre’s Theorem to Cartesian Form: Attempting to calculate \\((x+iy)^n\\) by simply raising the parts to the power n. Why it’s wrong: De Moivre’s Theorem only applies to the trigonometric (polar) form of a complex number. You must convert \\(x+iy\\) to \\(r(\\cos\\theta + i\\sin\\theta)\\) before applying the theorem.\nForgetting All n-th Roots: When asked to find the roots of a complex number, students often find only the principal root (for k=0). Why it’s wrong: A complex number has exactly n distinct n-th roots. You must cycle through k = 0, 1, 2, ..., n-1 to find all of them.\nForgetting the Base Case in Induction: Starting an induction proof by only showing the inductive step (\\(P(k) \\implies P(k+1)\\)). Why it’s wrong: The inductive step only proves that if a domino falls, the next one will fall. Without the base case to prove \\(P(1)\\) is true, the chain reaction never starts.\nAssuming the Conclusion in the Inductive Step: When trying to prove \\(P(k+1)\\), it is wrong to start with the statement \\(P(k+1)\\) itself and work backward. Why it’s wrong: This is a form of circular reasoning. You must start with the inductive hypothesis \\(P(k)\\) and use logical steps to derive the conclusion \\(P(k+1)\\).\nConfusing Density with Uncountability: Believing that because rational numbers are dense in the reals, the sets must have the same “size” (cardinality). Why it’s wrong: Density describes how elements are distributed, not how many there are. The set of reals is uncountably infinite, a larger order of infinity than the countably infinite set of rationals.\n\n\n\n5. Examples\n\n5.1. Convert to Trigonometric Form\nQuestion: Convert the complex number \\(z = -2\\sqrt{3} + 2i\\) to its trigonometric form.\n\n\nClick to see the solution\n\n\nFind the modulus \\(r\\): \\[\nr = |z| = \\sqrt{(-2\\sqrt{3})^2 + (2)^2} = \\sqrt{12 + 4} = \\sqrt{16} = 4\n\\]\nDetermine the quadrant: The real part \\(x = -2\\sqrt{3}\\) is negative, and the imaginary part \\(y = 2\\) is positive. This places the number in Quadrant II.\nFind the argument \\(\\theta\\): We find a reference angle using \\(\\tan\\alpha = |y/x| = |2 / (-2\\sqrt{3})| = 1/\\sqrt{3}\\). The reference angle is \\(\\alpha = \\pi/6\\). For Quadrant II, the angle is \\(\\theta = \\pi - \\alpha = \\pi - \\pi/6 = 5\\pi/6\\).\nWrite the trigonometric form: Combine \\(r\\) and \\(\\theta\\) into the final form \\(z = r(\\cos\\theta + i\\sin\\theta)\\).\n\nAnswer: \\(z = 4(\\cos(5\\pi/6) + i\\sin(5\\pi/6))\\)\n\n\n\n5.2. Powers of Complex Numbers\nQuestion: Compute \\((1 - i)^{8}\\) using De Moivre’s Theorem.\n\n\nClick to see the solution\n\n\nConvert \\(1-i\\) to trigonometric form:\n\nModulus: \\(r = \\sqrt{1^2 + (-1)^2} = \\sqrt{2}\\).\nQuadrant: \\(x &gt; 0, y &lt; 0\\) is Quadrant IV.\nArgument: \\(\\theta = \\arctan(-1/1) + 2\\pi = -\\pi/4 + 2\\pi = 7\\pi/4\\).\nTrigonometric form: \\(z = \\sqrt{2}(\\cos(7\\pi/4) + i\\sin(7\\pi/4))\\).\n\nApply De Moivre’s Theorem with \\(n=8\\): \\[\nz^8 = (\\sqrt{2})^8 \\left( \\cos\\left(8 \\cdot \\frac{7\\pi}{4}\\right) + i\\sin\\left(8 \\cdot \\frac{7\\pi}{4}\\right) \\right)\n\\]\nSimplify the expression:\n\n\\((\\sqrt{2})^8 = (2^{1/2})^8 = 2^4 = 16\\).\n\\(8 \\cdot \\frac{7\\pi}{4} = 14\\pi\\).\n\\(\\cos(14\\pi) = \\cos(0) = 1\\).\n\\(\\sin(14\\pi) = \\sin(0) = 0\\). \\[\nz^8 = 16(1 + i \\cdot 0) = 16\n\\]\n\n\nAnswer: 16\n\n\n\n5.3. Roots of Complex Numbers\nQuestion: Find the three cube roots of \\(z = -8i\\).\n\n\nClick to see the solution\n\n\nConvert \\(z = -8i\\) to trigonometric form:\n\n\\(x=0, y=-8\\).\nModulus: \\(r = \\sqrt{0^2 + (-8)^2} = 8\\).\nArgument: The point is on the negative imaginary axis, so \\(\\theta = 3\\pi/2\\).\nTrigonometric form: \\(z = 8(\\cos(3\\pi/2) + i\\sin(3\\pi/2))\\).\n\nApply the n-th root formula with \\(n=3\\): \\[\nw_k = \\sqrt[3]{8} \\left( \\cos\\left(\\frac{3\\pi/2 + 2k\\pi}{3}\\right) + i\\sin\\left(\\frac{3\\pi/2 + 2k\\pi}{3}\\right) \\right)\n\\] for \\(k=0, 1, 2\\). The modulus of each root is \\(\\sqrt[3]{8} = 2\\).\nCalculate the root for \\(k=0\\): \\[\nw_0 = 2 \\left( \\cos\\left(\\frac{3\\pi/2}{3}\\right) + i\\sin\\left(\\frac{3\\pi/2}{3}\\right) \\right) = 2(\\cos(\\pi/2) + i\\sin(\\pi/2)) = 2(0 + i) = 2i\n\\]\nCalculate the root for \\(k=1\\): \\[\nw_1 = 2 \\left( \\cos\\left(\\frac{3\\pi/2 + 2\\pi}{3}\\right) + i\\sin\\left(\\frac{3\\pi/2 + 2\\pi}{3}\\right) \\right) = 2(\\cos(7\\pi/6) + i\\sin(7\\pi/6)) = 2(-\\frac{\\sqrt{3}}{2} - \\frac{1}{2}i) = -\\sqrt{3} - i\n\\]\nCalculate the root for \\(k=2\\): \\[\nw_2 = 2 \\left( \\cos\\left(\\frac{3\\pi/2 + 4\\pi}{3}\\right) + i\\sin\\left(\\frac{3\\pi/2 + 4\\pi}{3}\\right) \\right) = 2(\\cos(11\\pi/6) + i\\sin(11\\pi/6)) = 2(\\frac{\\sqrt{3}}{2} - \\frac{1}{2}i) = \\sqrt{3} - i\n\\]\n\nAnswer: The three cube roots are \\(2i\\), \\(-\\sqrt{3} - i\\), and \\(\\sqrt{3} - i\\).\n\n\n\n5.4. Geometric Interpretation\nQuestion: Describe and sketch the set of points in the complex plane satisfying \\(1 \\le |z + 2| &lt; 3\\).\n\n\nClick to see the solution\n\n\nRewrite the expression: The form \\(|z - a|\\) represents the distance from \\(z\\) to \\(a\\). We rewrite \\(|z+2|\\) as \\(|z - (-2)|\\).\nInterpret the inequalities:\n\n\\(|z - (-2)| \\ge 1\\) means the set of points \\(z\\) whose distance from \\(-2\\) is greater than or equal to 1. This is the exterior of an open disk centered at \\(-2\\) with radius 1, including the boundary circle.\n\\(|z - (-2)| &lt; 3\\) means the set of points \\(z\\) whose distance from \\(-2\\) is less than 3. This is the interior of a circle centered at \\(-2\\) with radius 3.\n\nCombine the conditions: We need the points that satisfy both conditions. This is the region between the two circles, including the inner circle but excluding the outer circle. This shape is called an annulus.\n\nAnswer: The set is an annulus (a ring-like region) centered at \\(-2+0i\\). It includes all points on or outside the circle of radius 1 and inside the circle of radius 3.\n\n\n\n5.5. Induction with a Summation\nQuestion: Prove by mathematical induction that for all \\(n \\in \\mathbb{N}\\), \\(\\sum_{i=1}^{n} (2i-1) = n^2\\).\n\n\nClick to see the solution\n\n\nBase Case (\\(n=1\\)): The left-hand side (LHS) is \\(\\sum_{i=1}^{1} (2i-1) = 2(1)-1 = 1\\). The right-hand side (RHS) is \\(1^2 = 1\\). Since LHS = RHS, the statement is true for \\(n=1\\).\nInductive Step:\n\nInductive Hypothesis: Assume the formula is true for some arbitrary natural number \\(k \\ge 1\\). That is, assume \\(S_k = \\sum_{i=1}^{k} (2i-1) = k^2\\).\nGoal: We must prove the formula is true for \\(n = k+1\\). We need to show that \\(S_{k+1} = \\sum_{i=1}^{k+1} (2i-1) = (k+1)^2\\).\n\nProof: Start with the LHS for \\(k+1\\) and use the inductive hypothesis. \\[\nS_{k+1} = \\sum_{i=1}^{k+1} (2i-1) = \\left(\\sum_{i=1}^{k} (2i-1)\\right) + (2(k+1)-1)\n\\] By the inductive hypothesis, the sum in the parenthesis is \\(k^2\\). \\[\nS_{k+1} = k^2 + (2k+2-1) = k^2 + 2k + 1\n\\] Factor the resulting expression. \\[\nS_{k+1} = (k+1)^2\n\\] This is exactly the RHS of the statement for \\(n=k+1\\).\nConclusion: Since the base case is true and the inductive step holds, by the principle of mathematical induction, the formula is true for all \\(n \\in \\mathbb{N}\\).\n\nAnswer: The proof is complete as shown in the steps above.\n\n\n\n5.6. Induction with Divisibility\nQuestion: Prove that \\(5^n - 1\\) is divisible by 4 for all integers \\(n \\ge 1\\).\n\n\nClick to see the solution\n\n\nBase Case (\\(n=1\\)): For \\(n=1\\), the expression is \\(5^1 - 1 = 4\\). Since 4 is divisible by 4, the base case holds.\nInductive Step:\n\nInductive Hypothesis: Assume that for some integer \\(k \\ge 1\\), \\(5^k - 1\\) is divisible by 4. This means we can write \\(5^k - 1 = 4m\\) for some integer \\(m\\).\nGoal: We need to prove that \\(5^{k+1} - 1\\) is also divisible by 4.\n\nProof: Start with the expression for \\(k+1\\) and manipulate it algebraically to use the inductive hypothesis. \\[\n5^{k+1} - 1 = 5 \\cdot 5^k - 1\n\\] From the hypothesis, we know \\(5^k = 4m + 1\\). Substitute this into the expression. \\[\n5^{k+1} - 1 = 5(4m + 1) - 1 = 20m + 5 - 1 = 20m + 4\n\\] Factor out a 4 from the result. \\[\n5^{k+1} - 1 = 4(5m + 1)\n\\] Since \\(m\\) is an integer, \\(5m+1\\) is also an integer. Therefore, \\(5^{k+1} - 1\\) is a multiple of 4.\nConclusion: The base case is true and the inductive step has been proven. By the principle of mathematical induction, \\(5^n - 1\\) is divisible by 4 for all \\(n \\ge 1\\).\n\nAnswer: The proof is complete as shown in the steps above.\n\n\n\n5.7. Induction with an Inequality\nQuestion: Prove that for all integers \\(n \\ge 4\\), \\(2^n &gt; 3n\\).\n\n\nClick to see the solution\n\n\nBase Case (\\(n=4\\)): The base case here is \\(n=4\\). LHS: \\(2^4 = 16\\). RHS: \\(3(4) = 12\\). Since \\(16 &gt; 12\\), the base case is true.\nInductive Step:\n\nInductive Hypothesis: Assume for some integer \\(k \\ge 4\\) that \\(2^k &gt; 3k\\).\nGoal: We need to prove that \\(2^{k+1} &gt; 3(k+1)\\).\n\nProof: Start with the LHS of the goal inequality and use the hypothesis. \\[\n2^{k+1} = 2 \\cdot 2^k\n\\] By the inductive hypothesis, \\(2^k &gt; 3k\\), so we can substitute to get an inequality. \\[\n2 \\cdot 2^k &gt; 2 \\cdot (3k) = 6k\n\\] Now we need to show that this result, \\(6k\\), is greater than our target RHS, \\(3(k+1)\\). Let’s compare them. We want to show \\(6k &gt; 3(k+1)\\). \\[\n6k &gt; 3k + 3 \\implies 3k &gt; 3 \\implies k &gt; 1\n\\] Since our induction is for \\(k \\ge 4\\), the condition \\(k &gt; 1\\) is certainly true. Therefore, we have the chain of inequalities: \\(2^{k+1} = 2 \\cdot 2^k &gt; 6k &gt; 3(k+1)\\).\nConclusion: Since the base case and inductive step are true, by the principle of mathematical induction, \\(2^n &gt; 3n\\) for all integers \\(n \\ge 4\\).\n\nAnswer: The proof is complete as shown in the steps above.",
    "crumbs": [
      "Mathematical Analysis I",
      "2. Complex Numbers, Set Theory, Real Numbers, and MI"
    ]
  },
  {
    "objectID": "Computer Architecture/lec_2.html",
    "href": "Computer Architecture/lec_2.html",
    "title": "2. Hierarchy of Memories, Moore’s Law, Parallelism, Pipelining",
    "section": "",
    "text": "1. Summary\n\n1.1 The Hierarchy of Memories\nIn computer architecture, the memory hierarchy is a fundamental concept that organizes a computer’s storage into a pyramid-like structure. This organization is necessary to balance three competing factors: speed, capacity, and cost. Processors are extremely fast, but high-speed memory is expensive and thus has a small capacity. Conversely, large-capacity storage is affordable but much slower. The memory hierarchy solves this problem by creating layers of memory, where each level is smaller, faster, and more expensive per byte than the level below it.\nThe typical levels of the memory hierarchy, from fastest to slowest, are:\n\nCPU Registers: These are the fastest and smallest memory units, located directly inside the CPU. They hold the data that the CPU is currently processing. Access is virtually instantaneous.\nCache Memory: This is a small, very fast memory that sits between the CPU and the main system memory. It stores frequently accessed data and instructions, allowing the CPU to retrieve them much faster than from the main memory. Caches are typically divided into levels (L1, L2, L3), with L1 being the smallest and fastest.\nSystem Memory (RAM - Random Access Memory): This is the computer’s main working memory, where the operating system, applications, and data in current use are kept so that they can be quickly reached by the computer’s processor. It is significantly larger than cache but also slower.\nStorage Devices (Secondary Storage): This includes devices like Solid-State Drives (SSDs) and Hard Disk Drives (HDDs). They provide long-term, high-capacity storage for data and programs. This is the slowest but largest level of the hierarchy.\n\n\nAn important distinction within the hierarchy is between volatile and non-volatile memory.\n\nVolatile Memory (Registers, Cache, RAM) requires power to maintain the stored information. It loses all its data when the power is turned off.\nNon-Volatile Memory (SSDs, HDDs, Flash Memory) retains its stored information even when not powered.\n\n\n\n1.2 Design Simplification via Abstraction\nAbstraction is a core principle in computer architecture used to manage complexity. It involves hiding the complex details of a system while exposing only the essential features. This allows designers and programmers to work with a simplified model of a component without needing to understand its intricate internal workings.\nFor example, a CPU can be viewed at several levels of abstraction:\n\nHighest Level: A programmer sees the CPU as a single block that executes instructions.\nIntermediate Level: An architect sees the CPU as a collection of major components, such as the Control Unit (CU), Arithmetic Logic Unit (ALU), and registers.\nLowest Level: An engineer sees the CPU as a detailed diagram of logic gates and transistors that implement its functions.\n\nBy using abstraction, a complex system like a computer can be designed, built, and programmed in manageable layers.\n\n\n1.3 Moore’s Law and Its Stagnation\nMoore’s Law is an observation made by Intel co-founder Gordon Moore in 1965. It states that the number of transistors on an integrated circuit (IC) doubles approximately every two years. For decades, this trend also meant that CPU execution speed doubled every 18-24 months, leading to exponential growth in computing power.\nHowever, since around 2008, the growth in single-thread performance and CPU clock speed has significantly slowed down, leading to what is often called the stagnation of Moore’s Law. This is not because transistor density has stopped increasing, but because of two fundamental physical limits:\n\nHeat Dissipation: As transistors become smaller and more densely packed, the heat they generate becomes a major problem. Increasing clock speed further leads to higher power consumption and excessive heat, which can damage the chip. This is known as the end of Dennard scaling.\nSpeed of Light Limitation: Signals within a CPU chip travel at nearly the speed of light. As chips get faster, the time it takes for a signal to travel across the chip becomes a significant limiting factor.\n\nBecause of these limitations, the industry has shifted its focus from making single processors faster to adding more processors (or cores) to a single chip. This has led to the rise of multicore and multiprocessor systems.\n\n\n1.4 Performance via Parallelism\nParallelism, or parallel processing, involves using multiple processing units to execute multiple tasks or parts of a single task simultaneously. This contrasts with a single-processor system, which executes instructions sequentially (one after another).\nThe goal of multiprocessing is to speed up computation by dividing work among multiple cores. This is highly effective for tasks that can be broken down into independent sub-tasks. However, a major challenge is instruction dependency, where one instruction needs the result of a previous one before it can execute, forcing a sequential execution and limiting the benefits of parallelism.\n\n\n1.5 Performance via Pipelining\nPipelining is another technique to improve performance, but it works differently from parallelism. Instead of using multiple processors, pipelining uses a single processor and breaks down the execution of an instruction into several stages. It then overlaps these stages for different instructions, much like an assembly line.\nA classic five-stage pipeline includes:\n\nInstruction Fetch (IF): Fetch the instruction from memory.\nInstruction Decode (ID): Decode the instruction to see what it does.\nExecute (EX): Perform the calculation.\nMemory Access (MEM): Read from or write to memory.\nWrite Back (WB): Write the result back to a register.\n\nWhile one instruction is being executed (EX stage), the next one is being decoded (ID), and the one after that is being fetched (IF). This allows the CPU to work on multiple instructions at once, increasing throughput. Pipelining improves performance by increasing instruction throughput, while parallelism improves performance by running multiple instructions simultaneously on different hardware.\n\n\n1.6 Performance via Speculation (Prediction)\nSpeculative execution is an optimization technique where a processor makes an educated guess about the future execution path of a program and begins executing instructions from that predicted path before it’s certain the path will be taken. This is most commonly used for branch prediction.\nWhen the CPU encounters a conditional branch (e.g., an if statement), instead of waiting to see which branch is taken, the branch predictor guesses the outcome. The CPU then speculatively executes instructions along the predicted path. * If the prediction was correct, the results are kept, and time was saved by avoiding a pipeline stall. * If the prediction was incorrect, the speculative results are discarded, and the CPU starts executing from the correct path. This incurs a performance penalty, but since modern predictors are highly accurate (&gt;95%), the overall performance gain is significant.\n\n\n1.7 Other Fundamental Ideas\n\nDependability via Redundancy: This principle involves adding spare components (e.g., extra CPUs, memory, or power supplies) to a system to increase its reliability. If a primary component fails, a redundant one can take over, ensuring the system continues to operate. This is critical in applications like spacecraft or servers.\nMake the Common Case Fast: This design philosophy prioritizes optimizing the performance of the most frequent operations. By focusing resources on making common tasks as fast as possible, the overall system performance is improved, even if less common tasks are not as optimized.\nFinite State Machines (FSM): An FSM is a mathematical model of computation used to design both hardware and software. It consists of a finite number of states and the transitions between them in response to inputs. FSMs are a powerful tool for modeling the behavior of systems like network protocols, compilers, and hardware components like processor caches.\n\n\n\n\n2. Definitions\n\nComputer Architecture: The design and fundamental operational structure of a computer system. It defines the system’s parts and their interrelationships, especially the instruction set architecture (ISA), microarchitecture, and system design.\nCPU (Central Processing Unit): The primary component of a computer that executes instructions. It contains the Control Unit and the Arithmetic Logic Unit.\nALU (Arithmetic Logic Unit): The part of the CPU that performs arithmetic (addition, subtraction) and logic (AND, OR, NOT) operations.\nControl Unit (CU): The part of the CPU that directs the operation of the processor. It tells the other parts of the computer system how to carry out a program’s instructions.\nRegister: A small, extremely fast memory location directly inside the CPU used to hold a single piece of data during processing.\nCache Memory: A small amount of very fast, expensive memory used to store frequently accessed data from the main memory, reducing the average time to access data.\nSystem Memory (RAM): Volatile hardware in a computing device where the operating system, application programs, and data in current use are kept so they can be quickly reached by the device’s processor.\nVolatile Memory: Memory that requires constant power to maintain stored information; its contents are lost when power is turned off.\nNon-Volatile Memory: Memory that can retain stored information even after power is removed.\nAbstraction: The technique of hiding complex implementation details and showing only the necessary features of an object or system.\nMoore’s Law: The observation that the number of transistors in an integrated circuit doubles about every two years.\nParallelism: The simultaneous execution of multiple instructions or tasks on multiple processing units (cores) to achieve faster computation.\nPipelining: A technique where a single processor overlaps the execution of multiple instructions by breaking each into stages and processing them in an assembly-line fashion.\nSpeculative Execution: An optimization technique where a processor performs a task before it is known to be needed, such as executing instructions after a predicted branch.\nRedundancy: The inclusion of extra components that are not strictly necessary to functioning, in case of failure in other components.\nFinite State Machine (FSM): A computational model consisting of a finite number of states and transitions between them, used to model the behavior of systems.\n\n\n\n3. Mistakes\n\nConfusing Parallelism and Pipelining: Thinking these are the same concept. Why it’s wrong: Parallelism involves using multiple, independent processing units (like multiple cores) to execute different tasks simultaneously. Pipelining involves a single processing unit breaking instructions into stages and overlapping these stages to increase throughput. Pipelining is a form of instruction-level parallelism, but it doesn’t use multiple CPUs.\nBelieving Moore’s Law Guarantees Faster Clock Speeds: Assuming that the doubling of transistors automatically translates to a doubling of CPU clock frequency. Why it’s wrong: While historically correlated, clock speeds have stagnated since the mid-2000s due to power and heat dissipation limits. Moore’s Law now primarily results in more cores on a chip rather than faster individual cores.\nAssuming All Memory is Equal: Ignoring the vast performance differences between registers, cache, RAM, and SSDs. Why it’s wrong: The memory hierarchy exists because there is a trade-off between speed and cost. An algorithm that frequently accesses data from RAM or disk will be orders of magnitude slower than one that keeps its working data in the cache.\nIgnoring the Cost of a Branch Misprediction: Believing that speculative execution is a “free” performance boost. Why it’s wrong: When a branch is mispredicted, the entire pipeline must be flushed of the incorrect, speculatively executed instructions, and the correct instructions must be fetched. This incurs a significant performance penalty. The technique is only effective because modern predictors are correct most of the time.\nThinking More Cores Always Means a Faster Program: Assuming that doubling the number of CPU cores will cut a program’s execution time in half. Why it’s wrong: This is only true for perfectly parallelizable tasks. Most programs have sequential parts and dependencies between threads, which limit the speedup gained from adding more cores, a concept described by Amdahl’s Law.\nTreating Abstraction as Just “Dumbing Down”: Viewing abstraction as merely a simplification that loses important information. Why it’s wrong: Abstraction is a critical tool for managing complexity. It allows engineers and programmers to work effectively at different levels of a system without being overwhelmed by irrelevant detail, which is essential for building and maintaining complex modern computers.\n\n\n\n4. Examples\n\n4.1. Memory Hierarchy Ordering\nQuestion: A program needs to access a piece of data. Arrange the following memory types in order from the location that would provide the fastest access to the one that would provide the slowest access: L2 Cache, SSD, System RAM, CPU Register.\n\n\nClick to see the solution\n\n\nIdentify the fastest level: The memory closest to the CPU’s processing units is the fastest. CPU registers are physically part of the CPU core.\nConsider the cache levels: Cache is the next fastest level, acting as a buffer for RAM.\nPlace the main memory: System RAM is the primary working memory but is slower than the cache.\nPlace the storage device: Secondary storage like an SSD is the slowest level in this list, as it is accessed via I/O controllers and not directly by the CPU in the same way as RAM.\n\nAnswer: The correct order from fastest to slowest is: CPU Register, L2 Cache, System RAM, SSD.\n\n\n\n4.2. Pipelining Throughput\nQuestion: A non-pipelined processor takes 5 clock cycles to execute one instruction. A 5-stage pipelined processor has a clock cycle time of 1 ns and can complete one stage per cycle. Ignoring any pipeline stalls, how long would it take the pipelined processor to execute 10 instructions?\n\n\nClick to see the solution\n\n\nCalculate the time to fill the pipeline: The first instruction will take the full number of stages to complete because the pipeline starts empty. Time for the first instruction = 5 stages * 1 ns/stage = 5 ns.\nCalculate the time for subsequent instructions: Once the pipeline is full, a new instruction completes every clock cycle. So, the remaining (10 - 1) = 9 instructions will each take 1 ns to emerge from the pipeline.\nSum the times: Total time = (Time for first instruction) + (Time for the remaining 9 instructions) = 5 ns + (9 * 1 ns) = 14 ns.\n\nAnswer: It would take 14 ns to execute 10 instructions.\n\n\n\n4.3. Identifying Parallelism vs. Pipelining\nQuestion: A server is running a web application and a database simultaneously. The server’s CPU has 8 cores, and the operating system assigns the web application to run on 4 cores and the database to run on the other 4 cores. Is this an example of performance via parallelism or pipelining?\n\n\nClick to see the solution\n\n\nAnalyze the resource allocation: The system is using multiple, distinct processing units (8 cores).\nAnalyze the task distribution: Two separate, large-scale tasks (web application and database) are being executed at the same time on different sets of cores.\nCompare with definitions: This matches the definition of parallelism, which uses multiple processors to handle different tasks concurrently. It is not pipelining, which involves overlapping stages of instructions on a single processor.\n\nAnswer: This is an example of performance via parallelism.\n\n\n\n4.4. Applying Moore’s Law\nQuestion: In 2023, you buy a laptop with a CPU that has 8 cores. Based on the modern interpretation of Moore’s Law (where performance gains come from more cores rather than faster clock speeds), what would be a reasonable expectation for a similar-class laptop CPU you might buy in 2027 (4 years later)?\n\n\nClick to see the solution\n\n\nRecall Moore’s Law: The number of transistors doubles roughly every 2 years. In the multicore era, this often translates to a doubling of cores.\nCalculate the number of doubling periods: The time frame is 4 years, which is two 2-year periods.\nApply the doubling:\n\nAfter the first 2 years (2025), the core count would be expected to double from 8 to 16.\nAfter the second 2 years (2027), the core count would be expected to double again from 16 to 32.\n\n\nAnswer: A reasonable expectation would be a CPU with 32 cores.\n\n\n\n4.5. Levels of Abstraction\nQuestion: Describe a modern car at three different levels of abstraction, from highest (simplest) to lowest (most detailed).\n\n\nClick to see the solution\n\n\nHighest Level (The Driver’s View): At this level, the car is a simple machine with a few key interfaces: a steering wheel to change direction, pedals for acceleration and braking, and a gear selector. The complex mechanics of the engine, transmission, and electronics are hidden. The car is an object that transports you from one place to another.\nIntermediate Level (The Mechanic’s View): A mechanic sees the car as a system of interconnected components: the engine, the transmission, the braking system, the exhaust system, the electrical system, etc. They understand how these major parts work together and can diagnose problems within a specific system, but they might not know the internal details of the engine control unit (ECU).\nLowest Level (The Engineer’s View): An automotive engineer sees the car at a highly detailed level. They are concerned with the physics of combustion inside an engine cylinder, the material science of the brake pads, the specific algorithms running on the ECU, and the design of individual transistors on a microchip. This is the most complex and detailed view, where the fundamental principles of operation are designed and analyzed.\n\nAnswer: The three levels are Driver (highest abstraction), Mechanic (intermediate abstraction), and Engineer (lowest abstraction).\n\n\n\n4.6. Speculative Execution Scenario\nQuestion: Consider the following piece of code. Explain how a CPU with speculative execution and branch prediction would handle the if statement to improve performance. if (user_input &gt; 100) { perform_complex_calculation(); } else { perform_simple_task(); }\n\n\nClick to see the solution\n\n\nEncounter the Branch: When the CPU’s pipeline reaches the if statement, it encounters a conditional branch. It needs to know the result of user_input &gt; 100 to decide which block of code to execute next.\nPredict the Outcome: Instead of waiting for the comparison to complete, the branch predictor makes a guess. Based on past behavior of this branch, it might predict that the condition is usually false.\nSpeculatively Execute: The CPU will speculatively start fetching and executing the instructions for perform_simple_task() from the else block. It will do this before it officially knows the value of user_input.\nVerify the Prediction: In parallel, the CPU completes the user_input &gt; 100 comparison.\n\nIf the prediction was correct (false): The results of perform_simple_task() are kept, and the pipeline continues without any delay. Performance was gained.\nIf the prediction was incorrect (true): The CPU discards all the work it did on perform_simple_task(), flushes the pipeline, and begins fetching and executing instructions from the correct path: perform_complex_calculation(). Performance was lost compared to a perfect guess, but the system still functions correctly.\n\n\nAnswer: The CPU predicts the outcome of the if condition, executes the predicted code path (e.g., the else block) immediately, and only discards the work if the prediction was wrong.\n\n\n\n4.7. Finite State Machine Design\nQuestion: Design a simple Finite State Machine (FSM) for an automatic door. The door has a sensor that detects a person. It should have three states: CLOSED, OPENING, and OPEN. Describe the states and the transitions between them.\n\n\nClick to see the solution\n\n\nDefine the States:\n\nCLOSED: The initial state. The door is fully closed and is waiting for a trigger.\nOPENING: The door is in the process of opening. This is a transient state.\nOPEN: The door is fully open. It will wait here for a period before attempting to close.\n\nDefine the Transitions:\n\nCLOSED to OPENING: This transition occurs when the input person_detected is true.\nOPENING to OPEN: This transition occurs automatically once the door has finished its opening motion (e.g., an opening_complete signal becomes true).\nOPEN to CLOSED: This transition occurs after a timer expires and the input person_detected is false. The door starts closing. (For simplicity, we can assume it transitions directly to CLOSED, though a CLOSING state could also be added).\nOPEN to OPEN: If the timer expires but a person is still detected (person_detected is true), the FSM should remain in the OPEN state and reset its timer to avoid closing on someone.\n\n\n\nAnswer: The FSM has three states: CLOSED, OPENING, and OPEN. Transitions are triggered by a person being detected by the sensor and internal timers for the opening/closing process.",
    "crumbs": [
      "Computer Architecture",
      "2. Hierarchy of Memories, Moore's Law, Parallelism, Pipelining"
    ]
  },
  {
    "objectID": "Discrete Mathematics/lec_2.html",
    "href": "Discrete Mathematics/lec_2.html",
    "title": "2. Logical Equivalence, Normal Forms (DNF, CNF, ANF)",
    "section": "",
    "text": "1. Summary\n\n1.1 Logical Formulas and Operators\nIn logic, a formula (or proposition) is a statement that can be definitively determined as either true or false. Simple formulas, often represented by variables like \\(p\\) or \\(q\\), can be combined using logical operators to form more complex formulas.\n\nNegation (\\(\\neg\\)): Reverses the truth value of a formula. \\(\\neg p\\) is read as “not p”. If \\(p\\) is true, \\(\\neg p\\) is false.\nConjunction (\\(\\land\\) or &): Represents logical “AND”. The formula \\(p \\land q\\) is true only if both \\(p\\) and \\(q\\) are true.\nDisjunction (\\(\\lor\\)): Represents logical “OR”. The formula \\(p \\lor q\\) is true if at least one of \\(p\\) or \\(q\\) is true. It is only false when both are false.\nImplication (\\(\\to\\)): Represents an “if-then” statement. \\(p \\to q\\) is read as “if p, then q”. It is only false when \\(p\\) is true and \\(q\\) is false. In all other cases, it is true.\nBi-implication (\\(\\leftrightarrow\\)): Represents “if and only if”. \\(p \\leftrightarrow q\\) is true only when \\(p\\) and \\(q\\) have the same truth value (both true or both false).\n\n\n\n1.2 Classification of Logical Formulas\nFormulas can be classified based on their truth values across all possible interpretations of their variables.\n\n\nTautology: A formula that is always true, regardless of the truth values of its constituent variables. For example, the formula \\(p \\lor \\neg p\\) is always true because a proposition must be either true or false.\nContradiction: A formula that is always false. For example, \\(p \\land \\neg p\\) is a contradiction because a proposition cannot be both true and false at the same time.\nContingency: A formula that is neither a tautology nor a contradiction. Its truth value depends on the truth values of its variables. For example, \\(p \\lor q\\) is a contingency because its truth depends on whether \\(p\\) or \\(q\\) is true.\nSatisfiability: A formula is considered satisfiable if there exists at least one assignment of truth values to its variables that makes the entire formula true. Tautologies and contingencies are satisfiable, while contradictions are not. The problem of determining if a formula is satisfiable is a famous problem in computer science known as the Boolean Satisfiability Problem (SAT), which the Cook-Levin theorem proved to be NP-complete.\n\n\n\n1.3 Logical Equivalence\nTwo formulas are logically equivalent if they have identical truth tables. This means that for every possible combination of truth values for their variables, the two formulas produce the same result. This relationship is denoted by the symbol \\(\\equiv\\). Understanding these equivalences is crucial for simplifying and manipulating logical expressions.\n\nIdentity Laws: A variable OR-ed with false is the variable itself. A variable AND-ed with true is the variable itself.\n\n\\(p \\lor F \\equiv p\\)\n\\(p \\land T \\equiv p\\)\n\nDomination Laws: Any variable OR-ed with true is always true. Any variable AND-ed with false is always false.\n\n\\(p \\lor T \\equiv T\\)\n\\(p \\land F \\equiv F\\)\n\nIdempotent Laws: OR-ing or AND-ing a variable with itself does not change its value.\n\n\\(p \\lor p \\equiv p\\)\n\\(p \\land p \\equiv p\\)\n\nDouble Negation Law: Negating a negation cancels out.\n\n\\(\\neg(\\neg p) \\equiv p\\)\n\nCommutative Laws: The order of variables does not matter for AND and OR operations.\n\n\\(p \\lor q \\equiv q \\lor p\\)\n\\(p \\land q \\equiv q \\land p\\)\n\nAssociative Laws: The grouping of variables does not matter for a sequence of the same operator (AND or OR).\n\n\\((p \\lor q) \\lor r \\equiv p \\lor (q \\lor r)\\)\n\\((p \\land q) \\land r \\equiv p \\land (q \\land r)\\)\n\nDistributive Laws: An operator can be distributed over another within parentheses.\n\n\\(p \\land (q \\lor r) \\equiv (p \\land q) \\lor (p \\land r)\\)\n\\(p \\lor (q \\land r) \\equiv (p \\lor q) \\land (p \\lor r)\\)\n\nDe Morgan’s Laws: These laws describe how to negate a conjunction or a disjunction. To do this, you negate each term and flip the operator.\n\n\\(\\neg(p \\land q) \\equiv \\neg p \\lor \\neg q\\)\n\\(\\neg(p \\lor q) \\equiv \\neg p \\land \\neg q\\)\n\nAbsorption Laws: These laws simplify expressions where a variable is combined with an expression containing that same variable.\n\n\\(p \\lor (p \\land q) \\equiv p\\)\n\\(p \\land (p \\lor q) \\equiv p\\)\n\nImplication and Bi-implication Equivalences: These are fundamental for rewriting conditional statements.\n\nImplication: \\(p \\to q \\equiv \\neg p \\lor q\\)\nContrapositive: \\(p \\to q \\equiv \\neg q \\to \\neg p\\)\nBi-implication: \\(p \\leftrightarrow q \\equiv (p \\to q) \\land (q \\to p)\\) and \\(p \\leftrightarrow q \\equiv (p \\land q) \\lor (\\neg p \\land \\neg q)\\)\n\n\n\n\n1.4 Normal Forms\nA normal form in logic is a standardized way of writing a formula. Two of the most common are Disjunctive Normal Form (DNF) and Conjunctive Normal Form (CNF).\n\nDisjunctive Normal Form (DNF): A formula is in DNF if it is a disjunction (ORs) of conjunctions (ANDs) of literals. A literal is a variable or its negation (e.g., \\(p\\) or \\(\\neg p\\)).\n\nExample: \\((p \\land q) \\lor (\\neg p \\land r)\\)\nTo create a DNF from a truth table, you identify all rows where the output is true. For each such row, you create a conjunction (an AND clause) that is true for that specific combination of inputs. Finally, you connect all these conjunctions with disjunctions (ORs).\n\nConjunctive Normal Form (CNF): A formula is in CNF if it is a conjunction (ANDs) of disjunctions (ORs) of literals.\n\nExample: \\((p \\lor q) \\land (\\neg p \\lor r)\\)\nTo create a CNF from a truth table, you identify all rows where the output is false. For each such row, you create a disjunction (an OR clause) that is false for that specific combination. Finally, you connect all these disjunctions with conjunctions (ANDs).\n\n\n\n\n1.5 Algebraic Normal Form (ANF)\nAlgebraic Normal Form (ANF), also known as a Zhegalkin polynomial, is a unique way to represent any logical formula using only two operators: XOR (\\(\\oplus\\)) and AND (\\(\\cdot\\)). The calculations are performed modulo 2, which means that \\(1 + 1 = 0\\). This form is a polynomial where variables can only have a power of 1 (since \\(x \\cdot x = x\\)).\nThe key conversion formulas are:\n\n\\(\\neg p \\equiv p \\oplus 1\\)\n\\(p \\land q \\equiv p \\cdot q\\) (or just \\(pq\\))\n\\(p \\lor q \\equiv p \\oplus q \\oplus pq\\)\n\\(p \\to q \\equiv 1 \\oplus p \\oplus pq\\)\n\\(p \\leftrightarrow q \\equiv 1 \\oplus x \\oplus y\\)\n\nImportant properties in modulo 2 arithmetic include: * \\(p \\oplus p \\equiv 0\\) * \\(p \\cdot p \\equiv p\\) (or \\(p^2 \\equiv p\\))\n\n\n\n\n2. Definitions\n\nTautology: A logical formula that is always true for any assignment of truth values to its variables.\nContradiction: A logical formula that is always false for any assignment of truth values to its variables.\nContingency: A logical formula that can be either true or false depending on the truth values of its variables.\nSatisfiability: The property of a formula for which there is at least one assignment of truth values that makes it true.\nLogical Equivalence: The relationship between two formulas that have identical truth tables.\nLiteral: A propositional variable or its negation (e.g., \\(p\\) or \\(\\neg p\\)).\nDisjunctive Normal Form (DNF): A logical formula expressed as a disjunction (OR) of one or more conjunctions (ANDs) of literals.\nConjunctive Normal Form (CNF): A logical formula expressed as a conjunction (AND) of one or more disjunctions (ORs) of literals.\nAlgebraic Normal Form (ANF): A canonical representation of a logical formula as a polynomial over a two-element field, using XOR (addition) and AND (multiplication). Also known as a Zhegalkin polynomial.\n\n\n\n\n3. Formulas\n\nDouble Negation: \\(\\neg(\\neg p) \\equiv p\\)\nDe Morgan’s Laws:\n\n\\(\\neg(p \\lor q) \\equiv \\neg p \\land \\neg q\\)\n\\(\\neg(p \\land q) \\equiv \\neg p \\lor \\neg q\\)\n\nDistributive Laws:\n\n\\(p \\land (q \\lor r) \\equiv (p \\land q) \\lor (p \\land r)\\)\n\\(p \\lor (q \\land r) \\equiv (p \\lor q) \\land (p \\lor r)\\)\n\nImplication Equivalence: \\(p \\to q \\equiv \\neg p \\lor q\\)\nBi-implication Equivalence: \\(p \\leftrightarrow q \\equiv (p \\land q) \\lor (\\neg p \\land \\neg q)\\)\nANF Conversions (Modulo 2):\n\n\\(\\neg p \\equiv p \\oplus 1\\)\n\\(p \\lor q \\equiv p \\oplus q \\oplus pq\\)\n\\(p \\to q \\equiv 1 \\oplus p \\oplus pq\\)\n\\(p \\leftrightarrow q \\equiv 1 \\oplus p \\oplus q\\)\n\\(p \\oplus p \\equiv 0\\)\n\\(p \\cdot p \\equiv p\\)\n\n\n\n\n\n4. Mistakes\n\nIncorrectly Applying De Morgan’s Law: A common error is only negating the variables but forgetting to flip the operator. For example, stating that \\(\\neg(p \\lor q)\\) is equivalent to \\(\\neg p \\lor \\neg q\\). Why it’s wrong: De Morgan’s Law requires both negating the terms and inverting the connective, so the correct equivalence is \\(\\neg p \\land \\neg q\\).\nConfusing the Distributive Laws: Incorrectly distributing OR over AND, or vice-versa. For example, assuming \\(p \\lor (q \\land r)\\) simplifies to \\((p \\lor q) \\land r\\). Why it’s wrong: The distribution must apply to both terms inside the parentheses, resulting in the correct form: \\((p \\lor q) \\land (p \\lor r)\\).\nTreating Implication as Commutative: Assuming that \\(p \\to q\\) is the same as \\(q \\to p\\). Why it’s wrong: These are different statements. \\(p \\to q\\) is the original implication, while \\(q \\to p\\) is its converse. They do not have the same truth table and are not logically equivalent.\nErrors in ANF Arithmetic: Forgetting that all arithmetic in ANF is modulo 2. For instance, simplifying \\(p \\oplus p\\) to \\(2p\\) instead of \\(0\\). Why it’s wrong: The XOR operation corresponds to addition in a field with only two elements, {0, 1}, where \\(1+1=0\\).\nIncorrectly Constructing DNF/CNF: Using the “false” rows of a truth table to construct DNF, or the “true” rows for CNF. Why it’s wrong: DNF is a disjunction of terms representing the true outcomes, so each term must correspond to a row where the function is true. CNF is a conjunction of clauses that rule out the false outcomes, so each clause must correspond to a row where the function is false.\nSimplifying \\(\\neg a \\to \\neg b\\) to \\(a \\to b\\): Assuming that negating both sides of an implication preserves the original meaning. Why it’s wrong: The statement \\(\\neg a \\to \\neg b\\) is the inverse of \\(a \\to b\\), not an equivalent form. The correct logical equivalence is the contrapositive: \\(\\neg b \\to \\neg a\\).\n\n\n\n\n5. Examples\n\n5.1. Proving Equivalence with a Truth Table\nQuestion: Prove the equivalence \\(p \\to q \\equiv \\neg p \\lor q\\).\n\n\nClick to see the solution\n\n\nSet up the table: Create columns for the variables \\(p\\) and \\(q\\), and for the expressions \\(p \\to q\\) and \\(\\neg p \\lor q\\). Include an intermediate column for \\(\\neg p\\).\nList all possible truth value combinations for \\(p\\) and \\(q\\).\nEvaluate \\(\\neg p\\): Fill in the column for \\(\\neg p\\) based on the values in the \\(p\\) column.\nEvaluate \\(p \\to q\\): This is false only when \\(p\\) is true and \\(q\\) is false.\nEvaluate \\(\\neg p \\lor q\\): This is true if either \\(\\neg p\\) is true or \\(q\\) is true.\nCompare the final columns: Check if the columns for \\(p \\to q\\) and \\(\\neg p \\lor q\\) are identical.\n\n\n\n\n\\(p\\)\n\\(q\\)\n\\(\\neg p\\)\n\\(p \\to q\\)\n\\(\\neg p \\lor q\\)\n\n\n\n\nT\nT\nF\nT\nT\n\n\nT\nF\nF\nF\nF\n\n\nF\nT\nT\nT\nT\n\n\nF\nF\nT\nT\nT\n\n\n\nAnswer: Since the truth columns for \\(p \\to q\\) and \\(\\neg p \\lor q\\) are identical, the two expressions are logically equivalent.\n\n\n\n5.2. Simplifying a Logical Expression\nQuestion: Simplify the expression \\(\\neg(p \\lor (\\neg p \\land q))\\).\n\n\nClick to see the solution\n\n\nApply De Morgan’s Law to the outermost negation: \\[ \\neg p \\land \\neg(\\neg p \\land q) \\]\nApply De Morgan’s Law to the second part of the expression: \\[ \\neg p \\land (\\neg(\\neg p) \\lor \\neg q) \\]\nApply the Double Negation Law to \\(\\neg(\\neg p)\\): \\[ \\neg p \\land (p \\lor \\neg q) \\]\nApply the Distributive Law: \\[ (\\neg p \\land p) \\lor (\\neg p \\land \\neg q) \\]\nApply the Contradiction Law (\\(\\neg p \\land p \\equiv F\\)): \\[ F \\lor (\\neg p \\land \\neg q) \\]\nApply the Identity Law (\\(F \\lor A \\equiv A\\)): \\[ \\neg p \\land \\neg q \\]\n\nAnswer: The simplified expression is \\(\\neg p \\land \\neg q\\).\n\n\n\n5.3. Finding Disjunctive Normal Form (DNF)\nQuestion: Find the DNF for the function \\(\\Phi(p, q, r)\\) defined by the following truth table:\n\n\n\n\\(p\\)\n\\(q\\)\n\\(r\\)\n\\(\\Phi\\)\n\n\n\n\nT\nT\nT\nT\n\n\nT\nT\nF\nF\n\n\nT\nF\nT\nT\n\n\nT\nF\nF\nF\n\n\nF\nT\nT\nF\n\n\nF\nT\nF\nF\n\n\nF\nF\nT\nT\n\n\nF\nF\nF\nF\n\n\n\n\n\nClick to see the solution\n\n\nIdentify the ‘true’ rows: The function \\(\\Phi\\) is true for the input combinations (T, T, T), (T, F, T), and (F, F, T).\nCreate a conjunction for each ‘true’ row:\n\nFor (T, T, T), the term is \\(p \\land q \\land r\\).\nFor (T, F, T), the term is \\(p \\land \\neg q \\land r\\).\nFor (F, F, T), the term is \\(\\neg p \\land \\neg q \\land r\\).\n\nCombine the conjunctions with disjunctions (ORs): \\[ (p \\land q \\land r) \\lor (p \\land \\neg q \\land r) \\lor (\\neg p \\land \\neg q \\land r) \\]\n\nAnswer: The DNF is \\((p \\land q \\land r) \\lor (p \\land \\neg q \\land r) \\lor (\\neg p \\land \\neg q \\land r)\\).\n\n\n\n5.4. Finding Conjunctive Normal Form (CNF)\nQuestion: Find the CNF for the function \\(\\Psi(p, q)\\) defined by \\(p \\leftrightarrow q\\).\n\n\n\n\\(p\\)\n\\(q\\)\n\\(p \\leftrightarrow q\\)\n\n\n\n\nT\nT\nT\n\n\nT\nF\nF\n\n\nF\nT\nF\n\n\nF\nF\nT\n\n\n\n\n\nClick to see the solution\n\n\nIdentify the ‘false’ rows: The function is false for the input combinations (T, F) and (F, T).\nCreate a disjunction for each ‘false’ row that is false for that specific input. To do this, negate each literal in the row and combine them with OR.\n\nFor (T, F), we negate the literals to get \\(\\neg p\\) and \\(\\neg(\\neg q) = q\\). The clause is \\(\\neg p \\lor q\\).\nFor (F, T), we negate the literals to get \\(\\neg(\\neg p) = p\\) and \\(\\neg q\\). The clause is \\(p \\lor \\neg q\\).\n\nCombine the disjunctions with conjunctions (ANDs): \\[ (\\neg p \\lor q) \\land (p \\lor \\neg q) \\]\n\nAnswer: The CNF is \\((\\neg p \\lor q) \\land (p \\lor \\neg q)\\).\n\n\n\n5.5. Converting to Algebraic Normal Form (ANF)\nQuestion: Convert the expression \\((a \\land \\neg b) \\to a\\) to ANF.\n\n\nClick to see the solution\n\n\nSubstitute the logical operators with their ANF equivalents.\n\n\\(\\neg b \\equiv b \\oplus 1\\)\n\\(X \\to Y \\equiv 1 \\oplus X \\oplus XY\\)\n\nFirst, convert the term inside the parenthesis, \\(a \\land \\neg b\\): \\[ a \\land (b \\oplus 1) = a(b \\oplus 1) = ab \\oplus a \\]\nNow, substitute this result into the implication formula, where \\(X = ab \\oplus a\\) and \\(Y = a\\): \\[ 1 \\oplus (ab \\oplus a) \\oplus (ab \\oplus a)a \\]\nDistribute the final \\(a\\) term: \\[ 1 \\oplus ab \\oplus a \\oplus (aba \\oplus aa) \\]\nSimplify using \\(a \\cdot a = a^2 = a\\): \\[ 1 \\oplus ab \\oplus a \\oplus (ab \\oplus a) \\]\nGroup like terms. Remember that \\(X \\oplus X = 0\\) in modulo 2 arithmetic: \\[ 1 \\oplus (ab \\oplus ab) \\oplus (a \\oplus a) \\] \\[ 1 \\oplus 0 \\oplus 0 \\]\nFinal simplification: \\[ 1 \\]\n\nAnswer: The ANF is \\(1\\), which means the original expression is a tautology.\n\n\n\n5.6. Negating a Complex Expression\nQuestion: Apply De Morgan’s laws to negate and simplify the expression \\((\\neg a \\lor b) \\land (c \\lor \\neg d)\\).\n\n\nClick to see the solution\n\n\nEnclose the entire expression in a negation: \\[ \\neg((\\neg a \\lor b) \\land (c \\lor \\neg d)) \\]\nApply De Morgan’s Law to the central AND (\\(\\land\\)) operator. This splits the negation and flips the operator to OR (\\(\\lor\\)): \\[ \\neg(\\neg a \\lor b) \\lor \\neg(c \\lor \\neg d) \\]\nApply De Morgan’s Law to the first part, \\(\\neg(\\neg a \\lor b)\\): \\[ (\\neg(\\neg a) \\land \\neg b) \\lor \\neg(c \\lor \\neg d) \\]\nApply the Double Negation Law to \\(\\neg(\\neg a)\\): \\[ (a \\land \\neg b) \\lor \\neg(c \\lor \\neg d) \\]\nApply De Morgan’s Law to the second part, \\(\\neg(c \\lor \\neg d)\\): \\[ (a \\land \\neg b) \\lor (\\neg c \\land \\neg(\\neg d)) \\]\nApply the Double Negation Law to \\(\\neg(\\neg d)\\): \\[ (a \\land \\neg b) \\lor (\\neg c \\land d) \\]\n\nAnswer: The negated and simplified expression is \\((a \\land \\neg b) \\lor (\\neg c \\land d)\\).\n\n\n\n5.7. Simplification Using Logical Laws\nQuestion: Prove that \\((p \\to q) \\land (p \\to r) \\equiv p \\to (q \\land r)\\).\n\n\nClick to see the solution\n\n\nStart with the left-hand side (LHS) and convert implications to their \\(\\neg p \\lor q\\) form: \\[ (\\neg p \\lor q) \\land (\\neg p \\lor r) \\]\nThis expression is in the form \\((A \\lor B) \\land (A \\lor C)\\). We can use the Distributive Law in reverse, where \\(A = \\neg p\\), \\(B = q\\), and \\(C = r\\): \\[ \\neg p \\lor (q \\land r) \\]\nNow, convert this expression back from its OR form into an implication, using the equivalence \\(\\neg X \\lor Y \\equiv X \\to Y\\): \\[ p \\to (q \\land r) \\]\nThis matches the right-hand side (RHS) of the original statement.\n\nAnswer: Since the left-hand side can be transformed into the right-hand side using logical equivalence laws, the equivalence is proven.",
    "crumbs": [
      "Discrete Mathematics",
      "2. Logical Equivalence, Normal Forms (DNF, CNF, ANF)"
    ]
  },
  {
    "objectID": "Analytical Geometry and Linear Algebra I /lec_3.html",
    "href": "Analytical Geometry and Linear Algebra I /lec_3.html",
    "title": "3. Matrices, Determinants, and Vector Products",
    "section": "",
    "text": "1. Summary\n\n1.1 Introduction to Matrices\nA matrix is a rectangular grid or array of numbers, symbols, or expressions arranged in rows and columns. It’s a fundamental tool for organizing and manipulating data. A matrix is typically denoted by a capital letter, such as A.\nThe dimensions of a matrix describe its size and are given as m x n, where m is the number of rows and n is the number of columns. The individual items in a matrix are called its elements or entries. The element in the i-th row and j-th column is denoted as \\(a_{ij}\\).\nFor example, a 2x3 matrix A would look like this: \\[ A = \\begin{pmatrix} a_{11} & a_{12} & a_{13} \\\\ a_{21} & a_{22} & a_{23} \\end{pmatrix} \\]\n\n\n1.2 Types of Matrices\nCertain types of matrices have special properties and names:\n\nSquare Matrix: A matrix where the number of rows equals the number of columns (m = n).\nIdentity Matrix (\\(I\\)): A square matrix with ones on the main diagonal (from the top-left to the bottom-right) and zeros everywhere else. It is the matrix equivalent of the number 1, as multiplying any matrix by the identity matrix leaves it unchanged (\\(AI = A\\)).\nZero Matrix: A matrix where all elements are zero.\nDiagonal Matrix: A square matrix where all elements outside the main diagonal are zero. The elements on the diagonal can be any number.\nSymmetric Matrix: A square matrix that is equal to its transpose (\\(A = A^T\\)). This means the element \\(a_{ij}\\) is equal to the element \\(a_{ji}\\) for all i and j.\nTriangular Matrix: A square matrix where all elements above or below the main diagonal are zero. If the elements below are zero, it’s an upper triangular matrix. If the elements above are zero, it’s a lower triangular matrix.\n\n\n\n1.3 Basic Matrix Operations\n\nAddition and Subtraction: These operations can only be performed on matrices of the same dimensions. The operation is done element-wise, meaning you add or subtract the corresponding elements in each matrix. If \\(C = A + B\\), then \\(c_{ij} = a_{ij} + b_{ij}\\).\nScalar Multiplication: Multiplying a matrix by a scalar (a single number) involves multiplying every element of the matrix by that scalar. If \\(B = \\lambda A\\), then \\(b_{ij} = \\lambda a_{ij}\\).\nTranspose: The transpose of a matrix, denoted \\(A^T\\), is formed by swapping its rows and columns. The first row of A becomes the first column of \\(A^T\\), the second row becomes the second column, and so on. If A is an m x n matrix, \\(A^T\\) will be an n x m matrix.\nTrace: The trace of a square matrix, denoted tr(A), is the sum of the elements on its main diagonal.\n\n\n\n1.4 Matrix Multiplication\nMultiplying two matrices, A and B, is more complex. For the product AB to be defined, the number of columns in matrix A must be equal to the number of rows in matrix B. If A is m x n and B is n x p, the resulting matrix C will have dimensions m x p.\nThe element \\(c_{ij}\\) of the resulting matrix is calculated by taking the dot product of the i-th row of A and the j-th column of B.\nA critical property of matrix multiplication is that it is not commutative, which means that in general, \\(AB \\neq BA\\). The order of multiplication matters. However, it is associative (\\((AB)C = A(BC)\\)) and distributive (\\(A(B + C) = AB + AC\\)).\n\n\n1.5 The Determinant of a Matrix\nThe determinant is a special scalar value that can only be calculated from a square matrix. It is denoted as det(A) or \\(|A|\\). The determinant provides important information about the matrix:\n\nInvertibility: If det(A) is not zero, the matrix has an inverse. If det(A) is zero, the matrix is singular and does not have an inverse.\nGeometric Interpretation: The determinant represents the scaling factor of a linear transformation. For instance, the absolute value of the determinant of a 2x2 matrix tells you how the area of a shape changes when transformed by the matrix.\n\nFor a 2x2 matrix \\(A = \\begin{pmatrix} a & b \\\\ c & d \\end{pmatrix}\\), the determinant is det(A) = ad - bc.\nFor a 3x3 matrix, the calculation is more involved and can be done using Sarrus’s Rule or Laplace (Cofactor) Expansion.\n\n\n1.6 The Matrix Inverse\nThe inverse of a square matrix A, denoted \\(A^{-1}\\), is a matrix that, when multiplied by A, results in the identity matrix (\\(AA^{-1} = A^{-1}A = I\\)). Only non-singular (determinant is not zero) square matrices have an inverse.\nTo find the inverse of a 3x3 matrix, one common method is the adjugate method:\n\nMatrix of Minors: For each element, find its minor, which is the determinant of the 2x2 matrix that remains after deleting the element’s row and column.\nMatrix of Cofactors: Create the cofactor matrix by applying a “checkerboard” pattern of signs (+, -, +, -, etc.) to the matrix of minors. The cofactor \\(C_{ij}\\) is \\((-1)^{i+j}M_{ij}\\), where \\(M_{ij}\\) is the minor.\nAdjugate Matrix: Find the adjugate matrix, adj(A), by taking the transpose of the cofactor matrix.\nCalculate Inverse: The inverse is then found using the formula: \\(A^{-1} = \\frac{1}{\\det(A)}\\text{adj}(A)\\).\n\n\n\n1.7 The Vector Cross Product\nThe cross product is an operation between two vectors in 3D space, denoted a x b. The result is a new vector that is perpendicular to both of the original vectors.\nThe direction of the resulting vector is determined by the right-hand rule: if you curl the fingers of your right hand from vector a to vector b, your thumb points in the direction of a x b.  Because of this directional property, the cross product is anti-commutative: a x b = - (b x a).\nThe magnitude of the cross product, \\(|| \\mathbf{a} \\times \\mathbf{b} ||\\), is equal to the area of the parallelogram formed by the two vectors. This is calculated as \\(|| \\mathbf{a} || \\, || \\mathbf{b} || \\sin(\\theta)\\), where \\(\\theta\\) is the angle between them. The area of the triangle formed by these vectors is half of this value.\n\n\n1.8 Triple Products\n\nScalar Triple Product: This product, written as \\(\\mathbf{a} \\cdot (\\mathbf{b} \\times \\mathbf{c})\\), combines the dot product and cross product. The result is a scalar. Geometrically, its absolute value represents the volume of the parallelepiped formed by the three vectors. If the scalar triple product is zero, it means the three vectors are coplanar (they lie on the same plane). \nVector Triple Product: This product, written as \\(\\mathbf{a} \\times (\\mathbf{b} \\times \\mathbf{c})\\), involves two cross products and results in a vector. It can be simplified using the “BAC-CAB” identity: \\[ \\mathbf{a} \\times (\\mathbf{b} \\times \\mathbf{c}) = (\\mathbf{a} \\cdot \\mathbf{c})\\mathbf{b} - (\\mathbf{a} \\cdot \\mathbf{b})\\mathbf{c} \\]\n\nAnother important identity involving the vector triple product is the Jacobi identity: \\[ \\mathbf{a} \\times (\\mathbf{b} \\times \\mathbf{c}) + \\mathbf{b} \\times (\\mathbf{c} \\times \\mathbf{a}) + \\mathbf{c} \\times (\\mathbf{a} \\times \\mathbf{b}) = \\mathbf{0} \\]\n\n\n\n2. Definitions\n\nMatrix: A rectangular array of numbers arranged in rows and columns.\nScalar: A single numerical quantity.\nSquare Matrix: A matrix with an equal number of rows and columns.\nIdentity Matrix (\\(I\\)): A square matrix with ones on the main diagonal and zeros elsewhere.\nDeterminant (det(A)): A scalar value computed from a square matrix that determines its invertibility and geometric scaling factor.\nSingular Matrix: A square matrix whose determinant is zero, meaning it has no inverse.\nMatrix Inverse (\\(A^{-1}\\)): For a square matrix A, it is the matrix that yields the identity matrix when multiplied with A.\nTranspose (\\(A^T\\)): A matrix formed by interchanging the rows and columns of the original matrix.\nTrace (tr(A)): The sum of the elements on the main diagonal of a square matrix.\nVector Cross Product (\\(\\mathbf{a} \\times \\mathbf{b}\\)): A binary operation on two vectors in 3D space, resulting in a vector perpendicular to both original vectors.\nScalar Triple Product (\\(\\mathbf{a} \\cdot (\\mathbf{b} \\times \\mathbf{c})\\)): An operation that computes the volume of the parallelepiped defined by three vectors. The result is a scalar.\nVector Triple Product (\\(\\mathbf{a} \\times (\\mathbf{b} \\times \\mathbf{c})\\)): An operation involving three vectors that results in a new vector.\n\n\n\n3. Formulas\n\n2x2 Determinant: For \\(A = \\begin{pmatrix} a & b \\\\ c & d \\end{pmatrix}\\), \\(\\det(A) = ad - bc\\).\n2x2 Matrix Inverse: \\(A^{-1} = \\frac{1}{ad-bc} \\begin{pmatrix} d & -b \\\\ -c & a \\end{pmatrix}\\).\nGeneral Matrix Inverse: \\(A^{-1} = \\frac{1}{\\det(A)} \\text{adj}(A)\\).\nCross Product (Coordinate Form): For \\(\\mathbf{a} = \\langle a_1, a_2, a_3 \\rangle\\) and \\(\\mathbf{b} = \\langle b_1, b_2, b_3 \\rangle\\), \\[ \\mathbf{a} \\times \\mathbf{b} = \\det \\begin{pmatrix} \\mathbf{i} & \\mathbf{j} & \\mathbf{k} \\\\ a_1 & a_2 & a_3 \\\\ b_1 & b_2 & b_3 \\end{pmatrix} \\]\nScalar Triple Product (Determinant Form): \\[ \\mathbf{a} \\cdot (\\mathbf{b} \\times \\mathbf{c}) = \\det \\begin{pmatrix} a_1 & a_2 & a_3 \\\\ b_1 & b_2 & b_3 \\\\ c_1 & c_2 & c_3 \\end{pmatrix} \\]\nVector Triple Product Identity: \\(\\mathbf{a} \\times (\\mathbf{b} \\times \\mathbf{c}) = (\\mathbf{a} \\cdot \\mathbf{c})\\mathbf{b} - (\\mathbf{a} \\cdot \\mathbf{b})\\mathbf{c}\\).\nArea of Parallelogram: Area \\(= || \\mathbf{a} \\times \\mathbf{b} ||\\).\nArea of Triangle: Area \\(= \\frac{1}{2} || \\mathbf{a} \\times \\mathbf{b} ||\\).\nVolume of Parallelepiped: Volume \\(= |\\mathbf{a} \\cdot (\\mathbf{b} \\times \\mathbf{c})|\\).\n\n\n\n4. Mistakes\n\nAssuming Matrix Multiplication is Commutative: Always remember that \\(AB\\) is generally not equal to \\(BA\\). Why it’s wrong: The process of matrix multiplication (dot product of rows with columns) is dependent on order. Swapping the matrices changes which rows are multiplied by which columns, leading to a different result.\nForgetting the Sign Pattern in Cofactor Expansion: When calculating a determinant or a matrix of cofactors, it is easy to forget the \\((-1)^{i+j}\\) checkerboard pattern of signs. Why it’s wrong: These signs are a crucial part of the definition of the determinant and cofactors. Omitting them will lead to an incorrect value for the determinant and inverse.\nMultiplying Matrices with Incompatible Dimensions: Trying to multiply an m x n matrix by a p x q matrix where n ≠ p. Why it’s wrong: The definition of matrix multiplication requires the inner dimensions to match because the dot product is taken between rows of the first matrix (length n) and columns of the second (length p). If they don’t match, the operation is undefined.\nConfusing the Adjugate with the Cofactor Matrix: Using the cofactor matrix directly to find the inverse instead of its transpose (the adjugate). Why it’s wrong: The formula for the inverse specifically requires the adjugate, which is the transpose of the cofactors. Using the cofactor matrix directly will result in an incorrect inverse.\nIncorrectly Applying the Vector Triple Product Rule: Misremembering the BAC-CAB rule, for example as \\((a \\cdot b)c - (a \\cdot c)b\\). Why it’s wrong: The rule is precise. The positive term is the dot product of the “outer” vectors (\\(\\mathbf{a}, \\mathbf{c}\\)) multiplied by the “middle” vector (\\(\\mathbf{b}\\)). Getting the order or signs wrong changes the resulting vector completely.\n\n\n\n5. Examples\n\n5.1. Matrix Multiplication\nQuestion: Given matrices \\(A = \\begin{pmatrix} 2 & 1 & 0 \\\\ -1 & 3 & 4 \\end{pmatrix}\\) and \\(B = \\begin{pmatrix} 5 & -2 \\\\ 1 & 1 \\\\ 0 & -3 \\end{pmatrix}\\), compute the product \\(AB\\).\n\n\nClick to see the solution\n\n\nCheck dimensions: A is a 2x3 matrix and B is a 3x2 matrix. The inner dimensions match (3 and 3), so multiplication is possible. The resulting matrix will be 2x2.\nCalculate the element in the 1st row, 1st column: Take the dot product of the first row of A and the first column of B. \\[ (2)(5) + (1)(1) + (0)(0) = 10 + 1 + 0 = 11 \\]\nCalculate the element in the 1st row, 2nd column: Take the dot product of the first row of A and the second column of B. \\[ (2)(-2) + (1)(1) + (0)(-3) = -4 + 1 + 0 = -3 \\]\nCalculate the element in the 2nd row, 1st column: Take the dot product of the second row of A and the first column of B. \\[ (-1)(5) + (3)(1) + (4)(0) = -5 + 3 + 0 = -2 \\]\nCalculate the element in the 2nd row, 2nd column: Take the dot product of the second row of A and the second column of B. \\[ (-1)(-2) + (3)(1) + (4)(-3) = 2 + 3 - 12 = -7 \\]\nAssemble the final matrix: \\[ \\begin{pmatrix} 11 & -3 \\\\ -2 & -7 \\end{pmatrix} \\]\n\nAnswer: \\(AB = \\begin{pmatrix} 11 & -3 \\\\ -2 & -7 \\end{pmatrix}\\)\n\n\n\n5.2. Determinant of a 3x3 Matrix\nQuestion: Find the determinant of the matrix \\(A = \\begin{pmatrix} 1 & 2 & 3 \\\\ 0 & 1 & 4 \\\\ 5 & 6 & 0 \\end{pmatrix}\\).\n\n\nClick to see the solution\n\n\nUse cofactor expansion along the first row. The formula is \\(a_{11}C_{11} + a_{12}C_{12} + a_{13}C_{13}\\).\nCalculate the first term (\\(a_{11}C_{11}\\)): \\[ 1 \\cdot (-1)^{1+1} \\det \\begin{pmatrix} 1 & 4 \\\\ 6 & 0 \\end{pmatrix} = 1 \\cdot ((1)(0) - (4)(6)) = 1 \\cdot (-24) = -24 \\]\nCalculate the second term (\\(a_{12}C_{12}\\)): \\[ 2 \\cdot (-1)^{1+2} \\det \\begin{pmatrix} 0 & 4 \\\\ 5 & 0 \\end{pmatrix} = 2 \\cdot (-1) \\cdot ((0)(0) - (4)(5)) = -2 \\cdot (-20) = 40 \\]\nCalculate the third term (\\(a_{13}C_{13}\\)): \\[ 3 \\cdot (-1)^{1+3} \\det \\begin{pmatrix} 0 & 1 \\\\ 5 & 6 \\end{pmatrix} = 3 \\cdot (1) \\cdot ((0)(6) - (1)(5)) = 3 \\cdot (-5) = -15 \\]\nSum the terms: \\[ -24 + 40 - 15 = 1 \\]\n\nAnswer: \\(\\det(A) = 1\\)\n\n\n\n5.3. Inverse of a 3x3 Matrix\nQuestion: Find the inverse of the matrix \\(A = \\begin{pmatrix} 1 & 2 & 3 \\\\ 0 & 1 & 4 \\\\ 5 & 6 & 0 \\end{pmatrix}\\).\n\n\nClick to see the solution\n\n\nFind the determinant: From the previous example, we know \\(\\det(A) = 1\\). Since it’s not zero, the inverse exists.\nFind the matrix of minors: \\[ M = \\begin{pmatrix} -24 & -20 & -5 \\\\ -18 & -15 & -4 \\\\ 5 & 4 & 1 \\end{pmatrix} \\]\nFind the matrix of cofactors by applying the checkerboard pattern of signs: \\[ C = \\begin{pmatrix} -24 & 20 & -5 \\\\ 18 & -15 & 4 \\\\ 5 & -4 & 1 \\end{pmatrix} \\]\nFind the adjugate matrix by transposing the cofactor matrix: \\[ \\text{adj}(A) = C^T = \\begin{pmatrix} -24 & 18 & 5 \\\\ 20 & -15 & -4 \\\\ -5 & 4 & 1 \\end{pmatrix} \\]\nCalculate the inverse using the formula \\(A^{-1} = \\frac{1}{\\det(A)}\\text{adj}(A)\\): \\[ A^{-1} = \\frac{1}{1} \\begin{pmatrix} -24 & 18 & 5 \\\\ 20 & -15 & -4 \\\\ -5 & 4 & 1 \\end{pmatrix} \\]\n\nAnswer: \\(A^{-1} = \\begin{pmatrix} -24 & 18 & 5 \\\\ 20 & -15 & -4 \\\\ -5 & 4 & 1 \\end{pmatrix}\\)\n\n\n\n5.4. Area of a Triangle in 3D\nQuestion: Find the area of the triangle with vertices at points A(1, 2, 0), B(3, 0, -3), and C(5, 2, 6).\n\n\nClick to see the solution\n\n\nDefine two vectors forming the sides of the triangle: \\[ \\vec{AB} = B - A = \\langle 3-1, 0-2, -3-0 \\rangle = \\langle 2, -2, -3 \\rangle \\] \\[ \\vec{AC} = C - A = \\langle 5-1, 2-2, 6-0 \\rangle = \\langle 4, 0, 6 \\rangle \\]\nCompute the cross product \\(\\vec{AB} \\times \\vec{AC}\\): \\[ \\vec{AB} \\times \\vec{AC} = \\det \\begin{pmatrix} \\mathbf{i} & \\mathbf{j} & \\mathbf{k} \\\\ 2 & -2 & -3 \\\\ 4 & 0 & 6 \\end{pmatrix} \\] \\[ = \\mathbf{i}((-2)(6) - (-3)(0)) - \\mathbf{j}((2)(6) - (-3)(4)) + \\mathbf{k}((2)(0) - (-2)(4)) \\] \\[ = \\mathbf{i}(-12 - 0) - \\mathbf{j}(12 + 12) + \\mathbf{k}(0 + 8) \\] \\[ = \\langle -12, -24, 8 \\rangle \\]\nFind the magnitude of the cross product: \\[ || \\langle -12, -24, 8 \\rangle || = \\sqrt{(-12)^2 + (-24)^2 + 8^2} = \\sqrt{144 + 576 + 64} = \\sqrt{784} = 28 \\]\nCalculate the triangle’s area, which is half the magnitude: \\[ \\text{Area} = \\frac{1}{2} \\times 28 = 14 \\]\n\nAnswer: The area of the triangle is 14 square units.\n\n\n\n5.5. Volume of a Parallelepiped\nQuestion: Compute the volume of the parallelepiped formed by the vectors \\(\\mathbf{a} = \\langle 1, 1, 0 \\rangle\\), \\(\\mathbf{b} = \\langle 0, 1, 1 \\rangle\\), and \\(\\mathbf{c} = \\langle 1, 0, 1 \\rangle\\).\n\n\nClick to see the solution\n\n\nSet up the scalar triple product as the determinant of the matrix formed by the vectors: \\[ V = |\\mathbf{a} \\cdot (\\mathbf{b} \\times \\mathbf{c})| = \\left| \\det \\begin{pmatrix} 1 & 1 & 0 \\\\ 0 & 1 & 1 \\\\ 1 & 0 & 1 \\end{pmatrix} \\right| \\]\nCalculate the determinant: \\[ 1 \\det \\begin{pmatrix} 1 & 1 \\\\ 0 & 1 \\end{pmatrix} - 1 \\det \\begin{pmatrix} 0 & 1 \\\\ 1 & 1 \\end{pmatrix} + 0 \\det \\begin{pmatrix} 0 & 1 \\\\ 1 & 0 \\end{pmatrix} \\] \\[ = 1((1)(1) - (1)(0)) - 1((0)(1) - (1)(1)) + 0 \\] \\[ = 1(1) - 1(-1) = 1 + 1 = 2 \\]\nTake the absolute value: \\[ V = |2| = 2 \\]\n\nAnswer: The volume of the parallelepiped is 2 cubic units.\n\n\n\n5.6. Vector Triple Product\nQuestion: Let \\(\\mathbf{a} = \\langle 1, 2, 0 \\rangle\\), \\(\\mathbf{b} = \\langle 3, 0, 1 \\rangle\\), and \\(\\mathbf{c} = \\langle -1, 1, 4 \\rangle\\). Verify the identity \\(\\mathbf{a} \\times (\\mathbf{b} \\times \\mathbf{c}) = (\\mathbf{a} \\cdot \\mathbf{c})\\mathbf{b} - (\\mathbf{a} \\cdot \\mathbf{b})\\mathbf{c}\\).\n\n\nClick to see the solution\n\n\nCalculate the left side: \\(\\mathbf{a} \\times (\\mathbf{b} \\times \\mathbf{c})\\) First, find \\(\\mathbf{b} \\times \\mathbf{c}\\): \\[ \\mathbf{b} \\times \\mathbf{c} = \\det \\begin{pmatrix} \\mathbf{i} & \\mathbf{j} & \\mathbf{k} \\\\ 3 & 0 & 1 \\\\ -1 & 1 & 4 \\end{pmatrix} = \\mathbf{i}(0-1) - \\mathbf{j}(12 - (-1)) + \\mathbf{k}(3-0) = \\langle -1, -13, 3 \\rangle \\] Next, find \\(\\mathbf{a} \\times (\\mathbf{b} \\times \\mathbf{c})\\): \\[ \\mathbf{a} \\times \\langle -1, -13, 3 \\rangle = \\det \\begin{pmatrix} \\mathbf{i} & \\mathbf{j} & \\mathbf{k} \\\\ 1 & 2 & 0 \\\\ -1 & -13 & 3 \\end{pmatrix} = \\mathbf{i}(6-0) - \\mathbf{j}(3-0) + \\mathbf{k}(-13 - (-2)) = \\langle 6, -3, -11 \\rangle \\]\nCalculate the right side: \\((\\mathbf{a} \\cdot \\mathbf{c})\\mathbf{b} - (\\mathbf{a} \\cdot \\mathbf{b})\\mathbf{c}\\) First, find the dot products: \\[ \\mathbf{a} \\cdot \\mathbf{c} = (1)(-1) + (2)(1) + (0)(4) = -1 + 2 = 1 \\] \\[ \\mathbf{a} \\cdot \\mathbf{b} = (1)(3) + (2)(0) + (0)(1) = 3 \\] Next, compute the full expression: \\[ (1)\\mathbf{b} - (3)\\mathbf{c} = 1\\langle 3, 0, 1 \\rangle - 3\\langle -1, 1, 4 \\rangle \\] \\[ = \\langle 3, 0, 1 \\rangle - \\langle -3, 3, 12 \\rangle = \\langle 3 - (-3), 0 - 3, 1 - 12 \\rangle = \\langle 6, -3, -11 \\rangle \\]\nCompare the results: Both sides equal \\(\\langle 6, -3, -11 \\rangle\\).\n\nAnswer: The identity is verified, as both sides of the equation result in the vector \\(\\langle 6, -3, -11 \\rangle\\).\n\n\n\n5.7. Jacobi Identity\nQuestion: Prove the Jacobi identity for vectors \\(\\mathbf{a} = \\langle 1, 0, 0 \\rangle\\), \\(\\mathbf{b} = \\langle 0, 1, 0 \\rangle\\), and \\(\\mathbf{c} = \\langle 0, 0, 1 \\rangle\\).\n\n\nClick to see the solution\n\n\nCalculate the first term: \\(\\mathbf{a} \\times (\\mathbf{b} \\times \\mathbf{c})\\) \\[ \\mathbf{b} \\times \\mathbf{c} = \\langle 0, 1, 0 \\rangle \\times \\langle 0, 0, 1 \\rangle = \\langle 1, 0, 0 \\rangle = \\mathbf{a} \\] \\[ \\mathbf{a} \\times (\\mathbf{b} \\times \\mathbf{c}) = \\mathbf{a} \\times \\mathbf{a} = \\mathbf{0} \\]\nCalculate the second term: \\(\\mathbf{b} \\times (\\mathbf{c} \\times \\mathbf{a})\\) \\[ \\mathbf{c} \\times \\mathbf{a} = \\langle 0, 0, 1 \\rangle \\times \\langle 1, 0, 0 \\rangle = \\langle 0, 1, 0 \\rangle = \\mathbf{b} \\] \\[ \\mathbf{b} \\times (\\mathbf{c} \\times \\mathbf{a}) = \\mathbf{b} \\times \\mathbf{b} = \\mathbf{0} \\]\nCalculate the third term: \\(\\mathbf{c} \\times (\\mathbf{a} \\times \\mathbf{b})\\) \\[ \\mathbf{a} \\times \\mathbf{b} = \\langle 1, 0, 0 \\rangle \\times \\langle 0, 1, 0 \\rangle = \\langle 0, 0, 1 \\rangle = \\mathbf{c} \\] \\[ \\mathbf{c} \\times (\\mathbf{a} \\times \\mathbf{b}) = \\mathbf{c} \\times \\mathbf{c} = \\mathbf{0} \\]\nSum the three terms: \\[ \\mathbf{0} + \\mathbf{0} + \\mathbf{0} = \\mathbf{0} \\]\n\nAnswer: The Jacobi identity holds, as the sum is the zero vector, \\(\\mathbf{0}\\).",
    "crumbs": [
      "Analytical Geometry and Linear Algebra I ",
      "3. Matrices, Determinants, and Vector Products"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "InnoNotes",
    "section": "",
    "text": "Created by Zakhar Podyakov with ❤️ If you find any mistakes or have suggestions for improvement, please write to me. Telegram | Github| InnoNotes Github Innopolis Mafia 🤘"
  },
  {
    "objectID": "Introduction to Programming/lec_3.html",
    "href": "Introduction to Programming/lec_3.html",
    "title": "3. Pointers, Declarations, Preprocessing, File I/O in C",
    "section": "",
    "text": "1. Summary\n\n1.1 Introduction to Pointers in C\nA pointer is a fundamental concept in C programming. It is essentially a variable whose value is the memory address of another variable. Instead of holding data directly (like an integer or a character), a pointer “points to” the location where the data is stored. This allows for indirect manipulation of data, dynamic memory allocation, and efficient handling of complex data structures.\nThe primary operators used with pointers are:\n\nAddress-of operator (&): Returns the memory address of a variable.\nDereference operator (*): Accesses the value stored at the memory address held by a pointer.\n\n\n\n\n1.2 Common Problems with Pointers\nDue to their low-level nature, pointers introduce several potential pitfalls that programmers must carefully manage.\n\nOwnership and Destruction: A pointer declaration does not specify who is responsible for freeing the memory it points to. This ambiguity can lead to two major errors:\n\nMemory Leaks: If memory is dynamically allocated and no part of the code frees it, the memory remains occupied for the program’s lifetime, even if it’s no longer accessible. This happens when the last pointer to the allocated memory goes out of scope.\nDouble Free: Attempting to free the same memory block more than once can corrupt memory management data structures, leading to unpredictable crashes.\n\nDangling Pointers: A dangling pointer is a pointer that points to a memory location that has already been deallocated (freed). Dereferencing a dangling pointer results in undefined behavior, as the memory may have been reallocated for another purpose or could contain garbage data.\n\n\n\nDistinguishing Single Objects vs. Arrays: A pointer of type T* can point to a single object of type T or to the first element of an array of T’s. The C language provides no built-in way to distinguish between these two cases, which can lead to errors when performing pointer arithmetic or deallocating memory (e.g., using free() on an array that requires delete[] in C++).\n\n\n\n1.3 Declarations in C\nA declaration in C introduces one or more identifiers (like variable or function names) into the program and specifies their meaning and properties. A single declaration provides up to four pieces of information:\n\nStorage Class: Determines the lifetime and visibility of the entity (e.g., static, extern, auto).\nType Specifier: Defines the data type of the entity (e.g., int, double, struct S).\nEntity Name: The identifier being declared (e.g., a, my_function).\nInitializer: An optional initial value for the entity (e.g., = 777).\n\nC’s declaration syntax follows a principle often called “declaration follows use.” This means the declaration mimics the syntax of an expression that would yield a value of the base type.\n\nint *p;: Dereferencing p (*p) yields an int. Therefore, p is a pointer to an int.\nint a[10];: Accessing an element of a (a[i]) yields an int. Therefore, a is an array of ints.\nint f();: Calling f (f()) yields an int. Therefore, f is a function returning an int.\n\nThis can lead to complex declarations: * int *f(int);: f is a function that takes an int and returns a pointer to an int. * int (*f)(int);: f is a pointer to a function that takes an int and returns an int.\nThe typedef keyword provides a way to create an alias for a complex type, which greatly improves code readability.\n\n\n\n1.4 The C Preprocessor\nThe C preprocessor is a tool that processes the source code before compilation. It operates on a text-to-text basis, performing substitutions and transformations based on preprocessor directives—lines that begin with a # symbol. It does not understand C syntax or semantics.\nKey directives include:\n\n#include: Replaces the directive with the entire content of a specified file. This is how header files (like stdio.h) are incorporated into your code.\n#define: Creates a macro. In its simplest form, it’s a find-and-replace for a token. It can also define function-like macros with parameters, but these are prone to errors if not written carefully (e.g., by wrapping all parameters and the entire macro body in parentheses).\n#if, #ifdef, #ifndef, #else, #elif, #endif: These directives provide conditional compilation. They allow the preprocessor to include or exclude blocks of code based on certain conditions, such as whether a macro is defined. A common use case is the include guard, which prevents a header file from being included multiple times in a single compilation unit.\n\n\n\n\n1.5 File I/O in C\nFile input/output (I/O) in C is handled through the standard library, primarily defined in the &lt;stdio.h&gt; header. The central concept is the file stream, which is an abstraction that allows a programmer to treat files and other I/O devices (like the console) in a uniform way.\nA file stream is represented by a pointer to a FILE object, often called a file handle.\nThe standard workflow for file I/O is:\n\nOpen the file: Use the fopen() function, providing a file path and a mode string (e.g., \"r\" for reading, \"w\" for writing, \"a\" for appending). fopen() returns a FILE pointer if successful or NULL on failure.\nPerform I/O: Read from or write to the file using functions like:\n\nfscanf() / fprintf(): For formatted input/output, similar to scanf() and printf().\nfgets() / fputs(): For reading/writing strings (lines).\nfgetc() / fputc(): For reading/writing single characters.\nfread() / fwrite(): For binary I/O of raw data blocks.\n\nClose the file: Use the fclose() function, passing the FILE pointer. This is a critical step that flushes any buffered data to the disk and releases system resources associated with the file. Forgetting to close a file can lead to data loss.\n\n\n\n\n2. Definitions\n\nPointer: A variable that stores the memory address of another object.\nDereferencing: The action of accessing the value stored at the memory address pointed to by a pointer, using the * operator.\nDynamic Memory Allocation: The process of requesting memory from the operating system at runtime (e.g., using malloc()). This memory is not managed by the compiler’s scope rules and must be manually deallocated.\nMemory Leak: A situation where dynamically allocated memory is no longer needed by the program but is not deallocated (freed), making it unusable for the remainder of the program’s execution.\nDangling Pointer: A pointer that refers to a memory location that has been freed or deallocated.\nPreprocessor: A program that processes source code before compilation, performing tasks like file inclusion, macro expansion, and conditional compilation.\nMacro: An identifier defined with #define that is replaced by its corresponding value or code block by the preprocessor before compilation.\nTypedef: A keyword in C used to create a synonym or alias for an existing data type, often used to simplify complex type declarations.\nFile Handle: A pointer to a FILE structure (FILE *), which holds all the necessary information to manage a file stream, such as its current position, buffer status, and error indicators.\n\n\n\n4. Mistakes\n\nDereferencing an Uninitialized or NULL Pointer: An uninitialized pointer holds a garbage value, and a NULL pointer points to nothing. Attempting to access the memory they “point to” results in undefined behavior, which often leads to a program crash (segmentation fault). Why it’s wrong: You are trying to read from or write to a memory address that is either invalid or not owned by your program.\nForgetting to Free Dynamically Allocated Memory: If you allocate memory with malloc() but fail to release it with free() when it’s no longer needed, you create a memory leak. Why it’s wrong: Over time, memory leaks can exhaust available system memory, causing the program or even the entire system to slow down or crash.\nUsing a Pointer After free(): Accessing memory through a pointer after it has been freed is a classic dangling pointer error. Why it’s wrong: The memory management system may have already reassigned that memory block to another part of your program or to a different application. Writing to it can corrupt data, and reading from it can yield garbage values.\nReturning a Pointer to a Local Variable: A function’s local variables exist on the stack and are destroyed when the function returns. Returning a pointer to such a variable creates a dangling pointer. Why it’s wrong: The caller receives a pointer to a memory address that is no longer valid. Any attempt to use it will result in undefined behavior.\nIncorrect Macro Definitions: Defining a macro like #define SQUARE(x) x*x can lead to incorrect results due to operator precedence. For example, SQUARE(a+b) expands to a+b*a+b, not (a+b)*(a+b). Why it’s wrong: The preprocessor performs simple text substitution without understanding C’s rules. Always wrap macro parameters and the entire macro body in parentheses: #define SQUARE(x) ((x)*(x)).\nNot Checking the Return Value of fopen(): The fopen() function returns NULL if it fails to open a file (e.g., file not found, no permissions). Proceeding to use this NULL pointer with functions like fgets() or fclose() will cause a crash. Why it’s wrong: It’s a specific case of dereferencing a NULL pointer. Robust code must always verify that the file was opened successfully before attempting to use the file handle.\n\n\n\n5. Examples\n\n5.1. Basic Pointer Manipulation\nQuestion: Write a C program that declares an integer x with a value of 100. Declare a pointer p, make it point to x, and then use the pointer to change the value of x to 200. Print the final value of x.\n\n\nClick to see the solution\n\n#include &lt;stdio.h&gt;\n\nint main() {\n    // 1. Declare an integer and a pointer.\n    int x;\n    int *p;\n\n    // 2. Initialize the integer and make the pointer point to it.\n    x = 100;\n    p = &x; // Assign the address of x to p\n\n    // 3. Use the pointer to modify the value.\n    // *p accesses the value at the address p is holding.\n    *p = 200;\n\n    // 4. Print the result.\n    printf(\"The final value of x is: %d\\n\", x);\n\n    return 0;\n}\nAnswer: The program will print The final value of x is: 200.\n\n\n\n5.2. Dynamic Memory Allocation\nQuestion: Write a C program to dynamically allocate memory for an integer, assign it the value 42, print the value, and then free the memory.\n\n\nClick to see the solution\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt; // Required for malloc() and free()\n\nint main() {\n    // 1. Declare a pointer to hold the address of the dynamic memory.\n    int *ptr;\n\n    // 2. Allocate memory for one integer using malloc().\n    // sizeof(int) ensures portability.\n    ptr = (int *)malloc(sizeof(int));\n\n    // 3. Check if malloc() was successful.\n    if (ptr == NULL) {\n        printf(\"Memory allocation failed!\\n\");\n        return 1; // Exit with an error code\n    }\n\n    // 4. Assign a value to the allocated memory.\n    *ptr = 42;\n\n    // 5. Print the value.\n    printf(\"Value in dynamically allocated memory: %d\\n\", *ptr);\n\n    // 6. Free the allocated memory to prevent a leak.\n    free(ptr);\n    ptr = NULL; // Good practice to nullify pointer after freeing\n\n    return 0;\n}\nAnswer: The program will print Value in dynamically allocated memory: 42.\n\n\n\n5.3. Passing Pointers to Functions (Swap)\nQuestion: Create a function swap that takes pointers to two integers as arguments and swaps their values. Demonstrate its use in the main function.\n\n\nClick to see the solution\n\n#include &lt;stdio.h&gt;\n\n// 1. Define the swap function that accepts pointers.\nvoid swap(int *a, int *b) {\n    int temp = *a; // Store the value at address 'a'\n    *a = *b;       // Put the value at address 'b' into address 'a'\n    *b = temp;     // Put the stored original value into address 'b'\n}\n\nint main() {\n    // 2. Initialize two integers.\n    int x = 10;\n    int y = 20;\n\n    printf(\"Before swap: x = %d, y = %d\\n\", x, y);\n\n    // 3. Call swap, passing the addresses of x and y.\n    swap(&x, &y);\n\n    printf(\"After swap: x = %d, y = %d\\n\", x, y);\n\n    return 0;\n}\nAnswer: The program’s output will be: Before swap: x = 10, y = 20 After swap: x = 20, y = 10\n\n\n\n5.4. Pointer to a Function\nQuestion: Create two functions, add(int, int) and subtract(int, int). Create a pointer to a function that can point to either of them. Use the pointer to call both functions with inputs 5 and 3 and print the results.\n\n\nClick to see the solution\n\n#include &lt;stdio.h&gt;\n\nint add(int a, int b) {\n    return a + b;\n}\n\nint subtract(int a, int b) {\n    return a - b;\n}\n\nint main() {\n    // 1. Declare a pointer to a function that takes two ints and returns an int.\n    int (*operation)(int, int);\n    int result;\n\n    // 2. Point it to the 'add' function and call it.\n    operation = &add;\n    result = operation(5, 3); // or (*operation)(5, 3)\n    printf(\"Result of addition: %d\\n\", result);\n\n    // 3. Point it to the 'subtract' function and call it.\n    operation = &subtract;\n    result = operation(5, 3);\n    printf(\"Result of subtraction: %d\\n\", result);\n\n    return 0;\n}\nAnswer: The output will be: Result of addition: 8 Result of subtraction: 2\n\n\n\n5.5. Fixing a Faulty Macro\nQuestion: The following macro is intended to calculate the square of a number but fails for expressions like SQUARE(2+3). Correct the macro. #define SQUARE(x) x*x\n\n\nClick to see the solution\n\n\nIdentify the problem: The expression SQUARE(2+3) expands to 2+3*2+3, which evaluates to 2 + 6 + 3 = 11 due to operator precedence, not the expected 5*5=25.\nAdd parentheses around parameters: To ensure the parameter x is evaluated as a single unit, wrap every instance of it in parentheses. The macro becomes #define SQUARE(x) (x)*(x).\nAdd parentheses around the whole body: To protect the macro from the surrounding context, wrap the entire body in parentheses.\n\nCorrected Macro:\n#define SQUARE(x) ((x)*(x))\nExample Usage:\n#include &lt;stdio.h&gt;\n\n#define SQUARE(x) ((x)*(x))\n\nint main() {\n    int result = SQUARE(2+3);\n    printf(\"The result is: %d\\n\", result); // Prints 25\n    return 0;\n}\nAnswer: The corrected macro is #define SQUARE(x) ((x)*(x)).\n\n\n\n5.6. Reading from a File\nQuestion: Write a program that creates a file named data.txt, writes “Hello, World!” to it, closes it, and then re-opens it for reading to print its content to the console.\n\n\nClick to see the solution\n\n#include &lt;stdio.h&gt;\n\nint main() {\n    FILE *file_ptr;\n    char buffer; // A buffer to hold the line read from the file\n\n    // 1. Open file for writing (\"w\" mode).\n    file_ptr = fopen(\"data.txt\", \"w\");\n    if (file_ptr == NULL) {\n        printf(\"Could not create file for writing.\\n\");\n        return 1;\n    }\n    \n    // 2. Write to the file and close it.\n    fprintf(file_ptr, \"Hello, World!\\n\");\n    fclose(file_ptr);\n    printf(\"Wrote to data.txt successfully.\\n\");\n\n    // 3. Open the same file for reading (\"r\" mode).\n    file_ptr = fopen(\"data.txt\", \"r\");\n    if (file_ptr == NULL) {\n        printf(\"Could not open file for reading.\\n\");\n        return 1;\n    }\n\n    // 4. Read the line from the file and print it.\n    if (fgets(buffer, sizeof(buffer), file_ptr) != NULL) {\n        printf(\"Content of data.txt: %s\", buffer);\n    }\n    \n    // 5. Close the file.\n    fclose(file_ptr);\n\n    return 0;\n}\nAnswer: The program will first print Wrote to data.txt successfully. and then Content of data.txt: Hello, World!.\n\n\n\n5.7. Using an Include Guard\nQuestion: Create a header file math_utils.h that defines a simple PI constant. Protect it with an include guard to prevent multiple inclusion errors. Then, create a main.c file that includes it twice to show the guard works.\n\n\nClick to see the solution\n\nStep 1: Create math_utils.h\n// math_utils.h\n\n// 1. The include guard starts here.\n#ifndef MATH_UTILS_H\n#define MATH_UTILS_H\n\n// 2. The actual content of the header file.\n#define PI 3.14159\n\n// 3. The include guard ends here.\n#endif // MATH_UTILS_H\nStep 2: Create main.c\n// main.c\n#include &lt;stdio.h&gt;\n\n// 4. Include the header file the first time.\n// The preprocessor sees that MATH_UTILS_H is not defined,\n// defines it, and includes the content.\n#include \"math_utils.h\"\n\n// 5. Include the header file the second time.\n// The preprocessor sees that MATH_UTILS_H is now defined,\n// so it skips the content between #ifndef and #endif.\n#include \"math_utils.h\"\n\nint main() {\n    printf(\"The value of PI is: %f\\n\", PI);\n    return 0;\n}\nExplanation: Without the include guard, the preprocessor would try to #define PI twice, causing a compilation error. With the guard, the second #include does nothing, and the program compiles and runs correctly.\nAnswer: The program will compile successfully and print The value of PI is: 3.141590.",
    "crumbs": [
      "Introduction to Programming",
      "3. Pointers, Declarations, Preprocessing, File I/O in C"
    ]
  },
  {
    "objectID": "Academic Writing and Argumentation/lec_1.html",
    "href": "Academic Writing and Argumentation/lec_1.html",
    "title": "1. Effective Sentence Structure",
    "section": "",
    "text": "1. Summary\n\n1.1 What is a Sentence?\nA sentence is a fundamental unit of language that expresses a complete thought. To be considered a sentence, a group of words must satisfy four basic grammatical rules:\n\nIt must contain a complete idea.\nIt must have a specific grammatical structure, centered around a subject and a verb.\nIt must begin with a capital letter.\nIt must end with a punctuation mark (such as a period, question mark, or exclamation point).\n\n\n\n1.2 The Clause\nThe core of every sentence is a clause. A clause is a group of words that contains both a subject (who or what performs the action) and a verb (the action or state of being). The simple formula is:\nSubject + Verb = Clause\nIf a group of words lacks a subject, a verb, or both, it is not a clause. It is called a sentence fragment. A fragment cannot stand on its own because it does not express a complete thought.\n\nExample of a fragment: “In the building at night.” (This has no subject or verb).\nExample of a fragment: “Have learned a lot today.” (This has a verb phrase but is missing a subject).\n\n\n\n1.3 Clause Types\nClauses are divided into two main categories: independent and dependent. The combination of these clause types determines the structure of a sentence.\n\n1.3.1 Independent Clause\nAn independent clause (or main clause) contains a subject and a verb and expresses a complete thought. It is grammatically complete and can stand alone as its own sentence.\n\nExample: “I like pizza.”\nExample: “He has read a lot of books.”\n\n\n\n1.3.2 Dependent Clause\nA dependent clause (or subordinate clause) also contains a subject and a verb, but it does not express a complete thought. It cannot stand alone as a sentence. It begins with a subordinating conjunction (e.g., because, although, when, if) which makes the clause reliant on an independent clause to complete its meaning.\n\nExample: “Although I like pizza…” (The thought is incomplete).\nExample: “…because he has read a lot of books.” (This explains a reason but doesn’t state the main idea).\n\n\n\n\n1.4 Sentence Types\nThere are four main types of sentences in English, categorized by the number and type of clauses they contain.\n\n\n1.4.1 Simple Sentence\nA simple sentence consists of exactly one independent clause. It has a single subject and verb combination and expresses a single complete thought.\n\nExample: “A woman went to the gym.”\nExample: “The black rabbit died yesterday.”\n\n\n\n1.4.2 Compound Sentence\nA compound sentence consists of two or more independent clauses joined together. These clauses are typically linked by a coordinating conjunction. The most common coordinating conjunctions can be remembered with the acronym FANBOYS:\n\nFor\nAnd\nNor\nBut\nOr\nYet\nSo\n\n\nPunctuation Rule: When joining two independent clauses with a coordinating conjunction, a comma must be placed before the conjunction.\nIndependent Clause 1 + , + Coordinating Conjunction + Independent Clause 2\n\n\nExample: “A woman went to the gym, and everybody liked her immediately.”\nExample: “The black rabbit died yesterday, so we have bought a white elephant today.”\n\n\n\n1.4.3 Complex Sentence\nA complex sentence contains one independent clause and at least one dependent clause. The dependent clause is linked to the independent clause by a subordinating conjunction (e.g., because, since, although, while, when).\nPunctuation Rules: The punctuation of a complex sentence depends on the order of the clauses.\n\nNo Comma: If the independent clause comes first, followed by the dependent clause, no comma is needed. Independent Clause + Subordinating Conjunction + Dependent Clause \n\nExample: “The woman went to the gym because she wanted to get fit.”\n\nUse a Comma: If the dependent clause comes first, it must be followed by a comma before the independent clause. Subordinating Conjunction + Dependent Clause + , + Independent Clause \n\nExample: “Because she wanted to get fit, the woman went to the gym.”\n\n\n\n\n1.4.4 Compound-Complex Sentence\nA compound-complex sentence is the most intricate structure. It combines elements of both compound and complex sentences. It must contain at least two independent clauses and at least one dependent clause.\n\nExample: “Although he organized his sources by theme, Mongo decided to arrange them chronologically, and he carefully followed the MEAL plan for organization.”\n\nDependent Clause: “Although he organized his sources by theme”\nIndependent Clause 1: “Mongo decided to arrange them chronologically”\nIndependent Clause 2: “he carefully followed the MEAL plan for organization”\n\n\nWarning: Use compound-complex sentences carefully. While powerful, they can make your writing less readable if overused or constructed poorly.\n\n\n\n\n2. Definitions\n\nSentence: A grammatically complete unit of expression, containing a subject and verb, and conveying a complete thought.\nClause: A group of words containing a subject and a verb, forming the basic building block of a sentence.\nIndependent Clause: A clause that expresses a complete thought and can stand alone as a sentence.\nDependent Clause: A clause that contains a subject and verb but does not express a complete thought and cannot stand alone. It begins with a subordinating conjunction.\nSentence Fragment: An incomplete sentence that is missing a subject, a verb, or both, and therefore does not express a complete thought.\nSimple Sentence: A sentence consisting of only one independent clause.\nCompound Sentence: A sentence consisting of two or more independent clauses, joined by a coordinating conjunction (like and, but, or).\nComplex Sentence: A sentence consisting of one independent clause and at least one dependent clause.\nCompound-Complex Sentence: A sentence consisting of two or more independent clauses and at least one dependent clause.\nCoordinating Conjunction: A word that connects two independent clauses (e.g., For, And, Nor, But, Or, Yet, So - FANBOYS).\nSubordinating Conjunction: A word that introduces a dependent clause and connects it to an independent clause (e.g., because, if, although, when).\n\n\n\n3. Mistakes\n\nWriting sentence fragments: Treating a dependent clause or a phrase as a complete sentence. Why it’s wrong: A sentence must express a complete thought and have both a subject and a main verb to be grammatically correct. Fragments leave the reader waiting for more information.\nCreating a comma splice: Joining two independent clauses with only a comma, without a coordinating conjunction. Why it’s wrong: A comma alone is not strong enough to connect two complete thoughts. This error creates a run-on sentence. Use a comma and a conjunction (e.g., , but), a semicolon (;), or separate them into two sentences.\nForgetting the comma after an introductory dependent clause: Failing to place a comma after a dependent clause that starts a sentence. Why it’s wrong: The comma signals the end of the introductory element and the beginning of the main part of the sentence, which prevents confusion for the reader.\nUsing a comma in a complex sentence when the independent clause comes first: Placing a comma before a subordinating conjunction like because or while when it appears in the middle of a sentence. Why it’s wrong: No separation is needed when the main clause is presented first; the subordinating conjunction smoothly integrates the dependent clause.\nOverusing compound-complex sentences: Constructing long, convoluted sentences that are difficult to follow. Why it’s wrong: While grammatically correct, these sentences can obscure the main point and make the text less readable and engaging. Clarity should always be the priority.",
    "crumbs": [
      "Academic Writing and Argumentation",
      "1. Effective Sentence Structure"
    ]
  },
  {
    "objectID": "Academic Writing and Argumentation/lec_2.html",
    "href": "Academic Writing and Argumentation/lec_2.html",
    "title": "2. Principles of Effective Writing",
    "section": "",
    "text": "1. Summary\n\n1.1 Be Formal\nFormal academic writing is characterized by an objective, professional, and impersonal tone. The goal is to present information and arguments in a clear and respectful manner, avoiding the casualness of everyday conversation. This involves deliberate choices in vocabulary, grammar, and punctuation.\n\n1.1.1 Avoid Contracted Forms Contractions are shortened forms of words where an apostrophe replaces one or more letters (e.g., don't, isn't, wasn't). These are standard in spoken language but are considered too informal for academic work. Always write out the full words to maintain a formal tone. For example, instead of writing “The data wasn’t conclusive,” you should write “The data was not conclusive.”\n1.1.2 Avoid Spoken Language Academic writing requires more precise and formal vocabulary than conversational language. Avoid using slang, colloquialisms, or overly simple words. For instance, instead of saying “The results were pretty good,” a more formal alternative would be “The results were encouraging.” Similarly, replace vague, informal quantities like “a huge number of connections” with the more specific and formal term “numerous connections.”\n1.1.3 Avoid Punctuation Showing Attitude Punctuation marks like exclamation points convey emotion (e.g., surprise, excitement), which is generally inappropriate for objective academic writing. The focus should be on the factual presentation of information. Instead of writing “Turnout was less than 20 percent!”, you can convey the same sense of surprise through careful word choice, such as “Surprisingly, turnout in the election was less than 20 percent.”\n\n\n\n1.2 Be Concise\nConciseness is the art of conveying your message using the fewest words necessary without sacrificing clarity or completeness. Wordy and convoluted sentences can obscure your main points. Streamlining your writing makes it more powerful and easier for the reader to understand.\n\n1.2.1 Avoid Phrasal Verbs A phrasal verb is a combination of a verb and a preposition or adverb (e.g., bring up, look into, go on). While common in speech, they can be informal or ambiguous. Whenever possible, replace them with a single, more formal verb. For example, instead of “The committee brought up this issue,” use “The committee raised this issue.”\n1.2.2 Avoid Negatives Sentences written in the positive form are often clearer and more direct than those written in the negative. Unnecessary negative constructions can make sentences more complex. For example, “not many” can be simplified to “few,” and “did not accept” can be written more directly as “rejected.”\n1.2.3 Avoid Redundant Pairs Redundant pairs are phrases that use two words with the same meaning. This adds unnecessary wordiness. For example, in “first and foremost,” both words mean the first in a series, so using just “First” is more concise. Other examples include “any and all” (use “any”) and “each and every” (use “each”).\n1.2.4 Avoid Redundant Modifiers A redundant modifier is an adverb or adjective that repeats an idea already contained within the word it modifies. For example, since finish implies completion, the phrase “completely finish” is redundant; simply use “finish.” Likewise, “basic fundamentals” is redundant because fundamentals are inherently basic; use “fundamentals.”\n1.2.5 Avoid Metaconcepts Metaconcepts are abstract nouns that describe concepts about concepts (e.g., process, strategy, approach, framework). These words can often be removed to make a sentence more direct without losing meaning. For instance, “The re-factoring strategy seemed to be ineffective” can be streamlined to “Re-factoring seemed to be ineffective.” Similarly, “The process of data generation is explained” is more direct as “Data generation is explained.”\n\n\n\n1.3 Be Precise\nPrecision means choosing the exact word to convey your intended meaning. It involves eliminating ambiguity and vagueness, ensuring that your reader understands your points exactly as you intend them.\n\n1.3.1 Avoid Vague Words Words like good, bad, thing, and big are subjective and lack specific meaning. In an academic context, you must use more descriptive and objective language. Instead of stating “The device performance is bad,” provide a more specific critique like “The device performance is substandard.” Instead of “This design is good,” explain why: “This design is effective.”\n1.3.2 Use Complete Lists In formal writing, avoid using abbreviations like “etc.” (et cetera) when presenting a complete, finite list. Using “etc.” can create ambiguity because the reader may not know what other items the list includes. For example, instead of “The periodic table divides elements into metals, non-metals, etc.,” you should write out the full list: “The periodic table divides elements into metals, non-metals, and semi-metals or metalloids.” The use of “etc.” is only appropriate when providing a few examples from a much larger, open-ended set.\n\n\n\n1.4 Be Cautious (Hedging)\nAcademic knowledge is constantly evolving, and very few claims are absolutely certain. Cautious language, or hedging, is the practice of qualifying your statements to reflect the level of certainty. It shows that you are aware of the limitations of your claims and is a hallmark of credible academic writing.\n\n1.4.1 Avoid Generalizations Sweeping statements using absolute words like everyone, always, or never are risky because a single counterexample can prove them false. It is more accurate and defensible to use qualified language. Instead of “Everyone has access to the Internet nowadays,” a more accurate statement is “Internet access is widespread nowadays.”\n1.4.2 Avoid Emotions Academic arguments should be based on logic and evidence, not personal feelings. Emotionally charged words introduce bias and weaken the objectivity of your writing. For example, calling an idea “stupid” is unprofessional. A more academic approach would be to state, “It is debatable to think that economic means can solve these problems.”\n1.4.3 Use Hedging Language To make your claims more accurate, use hedging words and phrases. These include modal verbs (may, might, can), adverbs (mostly, often, likely), and phrases (appears to be, suggests that). For example, instead of the absolute statement, “The virus is widespread in central Asia,” a more cautious version is “The virus appears to be widespread in central Asia.”\n\n\n\n1.5 Be Clear\nClarity in writing means structuring your sentences so that the reader can follow your ideas effortlessly. Clear writing is characterized by simple sentence structures, strong verbs, and a logical flow of information.\n\n1.5.1 Avoid Nominalization Nominalization is the process of turning a verb or an adjective into a noun (e.g., investigate becomes investigation, effective becomes effectiveness). Overusing nominalizations, especially as the subject of a sentence with a weak verb like “to be,” makes writing dense and abstract. To improve clarity, turn the noun back into its verb form. Instead of “An investigation of the material was performed by the team,” write “The team investigated the material.”\n1.5.2 Avoid Passive Voice (Usually) In the active voice, the subject of the sentence performs the action (e.g., “The researcher conducted the experiment”). In the passive voice, the subject receives the action (e.g., “The experiment was conducted by the researcher”). The active voice is generally more direct, concise, and vigorous. However, the passive voice is sometimes appropriate, such as when describing research methods (“The samples were heated to 100°C”) or when the actor is unknown or unimportant.\n1.5.3 Make Verbs Show Action Strong, active verbs make your writing more engaging and clear. Over-reliance on forms of the verb “to be” (is, are, was, were) can lead to dull and wordy prose. Revise sentences to use verbs that show direct action. For example, “The airline service that is provided by commercial carriers is extremely poor” is weaker than “Commercial air carriers tend to provide poor service.”\n1.5.4 Use Actors or Concrete Nouns for Subjects Sentences are easiest to understand when the subject is the “actor” performing the action.\n\nAvoid Expletives: Phrases like There is/are and It is are called expletives. They delay the true subject of the sentence. Instead of “There are three ways to solve this problem,” rewrite it as “This problem has three solutions.”\nAvoid Isolated Demonstrative Pronouns: Pronouns like this, that, these, and those can be ambiguous when they stand alone. To ensure clarity, follow the pronoun with a noun. Instead of “This is important to consider,” specify what “This” refers to: “This idea is important to consider.”\nAvoid Gerundial Phrases: A gerund (an “-ing” verb acting as a noun) phrase as a subject can be wordy. Recasting the sentence with a clear actor often improves clarity. For example, “Eating uncooked horse meat can cause health problems with students” is clearer as “If students eat uncooked horse meat, they can have health problems.”\n\n1.5.5 Place Subjects and Verbs Close Together For a sentence to be readable, the reader must be able to easily identify its core components: the subject and the verb. Separating them with long clauses or phrases forces the reader to hold information in their memory, making the sentence difficult to parse. Restructure sentences to keep the subject and its verb close together.\n\n\n\n1.6 Be Careful with I, We, and You\nThe use of personal pronouns in academic writing varies by discipline, but some general principles apply.\n\n1.6.1 How to Use “I” In many fields, it is now acceptable to use “I” to describe your own research actions or to guide the reader.\n\nUse “I” to state research steps: “I collected and compiled the results.”\nUse “I” to state your intentions: “In this chapter, I will review the literature.”\nDo not use “I” to state personal opinions. Phrases like “I think that…” weaken your argument because academic claims should be based on evidence, not belief. Instead of “I think it is likely that…”, write “Educators are likely to use…”.\n\n1.6.2 How to Use “We” The pronoun “we” should be used precisely.\n\nUse “we” to refer specifically to yourself and your co-authors: “As researchers, we found that…”\nDo not use “we” to refer vaguely to yourself and the reader or to society in general. This can sound presumptuous. Instead of “We can stop obesity in our society…”, state the agent of the action directly: “Moderate physical activity can stop obesity.”\n\n1.6.3 How to Use “You” The pronoun “you” directly addresses the reader and is considered too informal for most academic writing. It creates a conversational tone that undermines objectivity. Always replace “you” with a more formal, third-person construction. For example, instead of “You can see the results in Table 3,” write “Table 3 shows the results.”\n\n\n\n\n2. Mistakes\n\nUsing contractions like don't or isn't: This is an error because academic writing requires a formal tone. Why it’s wrong: Contractions are shortcuts used in informal, spoken language and are considered unprofessional in formal documents.\nMaking absolute generalizations with words like everyone or always: This is a mistake because such sweeping claims are rarely accurate and can be easily disproven. Why it’s wrong: A single counterexample can invalidate the claim, which undermines the author’s credibility and the overall strength of the argument.\nStarting sentences with weak expletives like There is or It is: This is a stylistic error that adds unnecessary words and delays the introduction of the true subject. Why it’s wrong: It creates weaker, less direct sentences by burying the main noun and verb, making the text less engaging and harder to read.\nUsing vague, subjective words like good, bad, or thing: This is an error because academic writing demands precision and objectivity. Why it’s wrong: These words rely on personal judgment and lack the specific, measurable, and objective detail needed to make a clear and defensible academic point.\nRelying on the passive voice unnecessarily: While the passive voice has specific uses, overusing it often makes writing wordy and evasive. Why it’s wrong: It can obscure who is performing the action, which can make the text less clear, less direct, and less authoritative.\nStating personal opinions with phrases like I believe or I think: This weakens an academic argument. Why it’s wrong: An argument’s validity should stem from the evidence and logical reasoning presented, not from the author’s personal conviction. These phrases shift the focus from the evidence to the author.",
    "crumbs": [
      "Academic Writing and Argumentation",
      "2. Principles of Effective Writing"
    ]
  },
  {
    "objectID": "Academic Writing and Argumentation/lec_5.html",
    "href": "Academic Writing and Argumentation/lec_5.html",
    "title": "5. Avoiding Plagiarism, Referencing, Summarizing, Paraphrasing",
    "section": "",
    "text": "1. Summary\n\n1.1 Understanding Plagiarism\nPlagiarism is the act of presenting someone else’s work or ideas as your own without giving proper credit. In academic and professional writing, it is considered a serious offense with significant consequences, including failing an assignment, being reported to a disciplinary board, or even expulsion. A common guideline defines plagiarism as using more than three words verbatim from a source without proper referencing.\nIt’s important to distinguish between plagiarism and similarity. While plagiarism is the uncredited use of another’s work, similarity can occur legitimately when citing sources. Tools that detect similarity might flag names, titles, established terminology, numerical data, or common phrases that are difficult to reword. The key difference is attribution; properly referenced text may be similar, but it is not plagiarized.\n\n\n1.2 The Core Principles of Referencing\nReferencing is the fundamental method for avoiding plagiarism. It involves systematically acknowledging the sources of information you have used in your writing. Proper referencing allows your readers to locate the original sources, demonstrates the breadth of your research, and situates your work within the existing academic conversation. The two primary components of referencing are in-text citations and a final reference list.\n\n\n1.3 In-Text Citations (IEEE Style)\nAn in-text citation is a brief reference within the body of your text that points the reader to the full source details in the reference list. The IEEE (Institute of Electrical and Electronics Engineers) style is a numbered system commonly used in technical fields.\nKey characteristics of IEEE in-text citations include:\n\nNumbered System: Citations are numbered in the order they appear in the text, starting with [1].\nSquare Brackets: The citation number is always enclosed in square brackets, e.g., [2].\nFormatting: The citation number should appear on the text line, have a space before it, and come inside the sentence’s punctuation (e.g., “…as shown in the study [3].”).\nMultiple Sources: To cite multiple sources at once, separate the numbers with commas (e.g., [4], [5]) or use a hyphen for a range (e.g., [6]-[8]).\nEt al.: This Latin phrase, short for et alia (“and others”), is used when a source has more than two authors. You should list the first author’s last name followed by et al. For example, a work by Wood, Taylor, and Azzarello would be cited as “Wood et al. [7] claim that…”.\n\n\n\n1.4 Direct Quotations and Ellipsis\nA direct quotation is an exact, word-for-word reproduction of a phrase or sentence from a source. To use a direct quotation correctly, you must enclose the borrowed text in quotation marks and provide an in-text citation, including the page number if available (e.g., [7, p. 14]). Quotations are used to preserve the original author’s precise language or to provide strong evidence for an argument.\nAn ellipsis (a set of three dots, ...) is used within a quotation to indicate that you have omitted some unnecessary words from the original text. It is crucial that the omission does not alter the original meaning of the source material. For example: “the proposed circuit has improved signal attenuation ... and has been experiencing less performance degradation.”\n\n\n1.5 The Reference List\nThe reference list appears at the end of your document and provides the full publication details for every source cited in your text. Each entry is numbered to correspond with the in-text citations. This allows any reader to find the exact sources you consulted. The list should be ordered numerically, matching the sequence of citations in the paper.\n\n\n1.6 The Art of Summarizing\nSummarizing involves condensing the main ideas of a source into a concise overview written in your own words. Unlike a detailed paraphrase, a summary focuses only on the main points, omitting the supporting details. You should summarize when the finer details are irrelevant to your argument or when a source is not significant enough to warrant a more detailed explanation. A summary still requires a citation to the original source.\n\n\n1.7 Effective Paraphrasing\nParaphrasing is restating information or ideas from a source using your own vocabulary and sentence structure. A successful paraphrase demonstrates that you have fully understood the original text. It is different from a quotation because it does not use the author’s exact words, and it is different from a summary because it can be just as detailed as the original. Paraphrasing is often preferred over quoting because it improves the flow and readability of your writing while still grounding your arguments in credible sources.\n\n\n1.8 A 6-Step Guide to Paraphrasing\nTo ensure your paraphrase is a true representation of your own understanding and not just a minor rewording of the original, follow these six steps: 1. Read the Original: Read the passage several times until you are confident you understand its meaning. 2. Note Key Concepts: Identify the main ideas and any shared language—terms that are difficult or impossible to change, such as proper nouns, technical terminology, or numerical data. 3. Write from Memory: Set the original text aside and write your version of the idea. This forces you to use your own words and sentence structure. 4. Compare: Compare your paraphrase with the original passage. Check that you have preserved the original meaning and have not used the same phrasing. 5. Revise: Change any phrases or sentences that are still too similar to the original. 6. Cite: Add an in-text citation (e.g., [1]) to give credit to the original author.\n\n\n1.9 Using Reporting Verbs\nReporting verbs are used to introduce information from a source (e.g., “Smith [9] argues that…”). The choice of verb is important, as it can convey your stance on the source’s idea.  Instead of relying on overused, neutral verbs like “says” or “states,” select a stronger, more precise verb to accurately reflect the author’s position and critically evaluate the information. For example, instead of “The study says the result is positive,” you could write “The study celebrates the positive result” or “The study concedes the result is positive.” Using varied and accurate reporting verbs makes your writing more dynamic, precise, and analytical. For instance, writing “The Asian Police Alliance [34] blames the rise in drug trafficking on Western pop culture” is more impactful and specific than saying they say it is the cause.\n\n\n\n2. Mistakes\n\nPatchwriting: This involves changing only a few words in a sentence from a source or rearranging the sentence order slightly. Why it’s wrong: This is a form of plagiarism because it closely follows the original author’s vocabulary and sentence structure without using quotation marks. A proper paraphrase requires you to use your own words and sentence construction.\nIncorrect Citation Phrasing: Using awkward phrasing like “In reference [1], Jones discusses…” or “In Jones [2], a new approach is proposed.” Why it’s wrong: While not technically plagiarism, it is poor academic style. The preferred, more direct phrasing is “Jones [1] discusses…” or “Jones [2] proposed a new approach…”.\nMisrepresenting a Source with Ellipsis: Using an ellipsis (...) to omit words in a way that changes the author’s original meaning. For example, changing “The study found no significant evidence of a cure” to “The study found ... evidence of a cure.” Why it’s wrong: This is a serious form of academic dishonesty as it deliberately misleads the reader about the source’s findings.\nForgetting to Cite a Summary or Paraphrase: Assuming that because you used your own words, you don’t need to provide a citation. Why it’s wrong: The ideas or information still belong to the original author. Plagiarism includes using someone’s ideas, not just their words, without giving credit.\nMismatching In-Text Citations and the Reference List: Citing a source in your text (e.g., [5]) but forgetting to add the corresponding entry to the numbered reference list at the end of the paper. Why it’s wrong: This makes it impossible for a reader to find the source you are referencing, defeating the purpose of the citation.\nUsing Too Many Direct Quotations: Filling your paper with long, block quotations instead of paraphrasing the information. Why it’s wrong: Over-quoting suggests that you have not fully understood the material or are unable to explain it in your own words. It makes the writing choppy and less original.",
    "crumbs": [
      "Academic Writing and Argumentation",
      "5. Avoiding Plagiarism, Referencing, Summarizing, Paraphrasing"
    ]
  },
  {
    "objectID": "Academic Writing and Argumentation/lec_4.html",
    "href": "Academic Writing and Argumentation/lec_4.html",
    "title": "4. Paragraphs, Structure, Transitions",
    "section": "",
    "text": "1. Summary\n\n1.1 Defining the Paragraph\nA paragraph is the fundamental basic building block of any longer text. It is defined as a group of sentences focused entirely on a single subject. The core principle of effective writing dictates that one paragraph should contain only one idea. If a new idea or subtopic emerges, a new paragraph must be started.\n\n\n\n1.2 Characteristics of an Effective Paragraph\nAn effective paragraph must possess five critical characteristics:\n\nUnified: It focuses exclusively on one main idea (the controlling idea). All sentences must directly develop this central idea without deviation.\nLogical: The sentences must flow smoothly, establishing clear relationships between concepts. This is often achieved through the known-new contract.\nWell-structured: It follows a recognized format, typically including a head, a body, and a conclusion.\nClear: The language and ideas are immediately understandable to the reader.\nConcise: It is efficient, using only necessary words and sentences to fully develop the idea.\n\n\n\n1.3 Paragraph Structure: The Burger Model\nAn effective paragraph is usually organized into three distinct parts, often visualized using the burger analogy:\n\nParagraph Head (Top Bun): Typically one or two sentences that introduce the topic and the writer’s stance. This is the topic sentence.\nSupporting Sentences (Meat and Fillings): These form the body of the paragraph. They expand, explain, and prove the main idea stated in the head. This section generally makes up two-thirds of the paragraph’s word count and requires at least three supporting points.\nConcluding Sentence (Bottom Bun): The final sentence that wraps up the discussion of that single idea, often rephrasing the head or summarizing the supporting points.\n\n\n\n\n1.4 The Paragraph Head (Topic Sentence)\nThe Paragraph Head (or topic sentence) is crucial as it states the primary purpose of the paragraph and often provides a smooth transition from the preceding paragraph.\nA well-written paragraph head is composed of two elements:\n\nThe Topic: What the paragraph is generally about.\nThe Controlling Idea: What the writer intends to say or prove about that topic. This limits the scope and dictates what the supporting sentences must discuss.\n\nFor example, if the topic is “Video games,” the controlling idea might be that “they are beneficial for several reasons.” The resulting topic sentence would be: “Video games are beneficial for social, psychological, and physical reasons.”\n\n\n1.5 Writing Supporting Sentences\nSupporting sentences are the evidence and explanation that develop the controlling idea. They usually follow a two-part approach:\n1. Explanation The writer must explain the controlling idea multiple times (usually three) using different approaches, such as providing: * Examples: Specific instances that illustrate the point. * Reasons: Causes or justifications for the main idea. * Steps: If the paragraph describes a process.\n2. Details Each explanation must be grounded in specific details to provide credibility and depth. Details can take several forms: * Facts: Information generally accepted as truth. * Anecdotes: Short, relevant stories or incidents based on experience. * Statistics: Numerical data, often derived from surveys or studies. * Expert’s Opinion: References to statements or theories from knowledgeable authorities.\n\n\n\n1.6 The Concluding Sentence\nThe concluding sentence is the last sentence in the paragraph and serves to signal the end of the discussion on that particular topic.\nCrucially, it should never introduce new details or ideas.\nThere are two main strategies for writing an effective concluding sentence:\n\nRephrasing: Repeating the controlling idea found in the paragraph head, but using entirely different language and syntax.\nSummarizing: Synthesizing the main points made in the supporting sentences to create a unified final statement.\n\n\n\n1.7 Ensuring Logical Flow: Transitions\nFor sentences to flow smoothly, they must connect logically. This is managed through two main techniques: the known-new contract and the use of transitions.\n\n1.7.1 The Known-New Contract (Topic and Stress)\nTo maintain logical flow (cohesion), sentences should adhere to the known-new contract:\n\nBeginning of the sentence (Topic/Known): Start with information the reader already possesses (i.e., information carried over from the previous sentence’s ending).\nEnd of the sentence (Stress/New): Place the most unfamiliar, important, or new information at the end of the sentence.\n\nThis creates a chain effect, where the new information (stress) of one sentence becomes the known information (topic) of the next.\n\n\n1.7.2 Direct Transitions\nDirect transitions are specific set phrases or words used to indicate the logical relationship between two sentences or ideas. They help guide the reader through the argument.\n\nOrdering: First, Second, Finally, Primarily.\nAdding: Furthermore, Moreover, In addition.\nCausation: Therefore, Consequently, As a result.\nContrast: However, Nevertheless, On the other hand.\n\n\n\n1.7.3 Indirect Transitions (Links)\nIndirect transitions provide cohesion by linking ideas or words subtly throughout the paragraph:\n\nWord-links: Simple repetition of key words or phrases (e.g., repeating “Michael Schlotzky” or “student”).\nIdea-links: Using synonyms, pronouns, or descriptive phrases to refer back to previously mentioned people, objects, or concepts (e.g., referring to “Michael Schlotzky” as “the young man” or “this truant”).\n\n\n\n\n\n2. Mistakes\n\nAnnouncing the topic instead of stating the main idea: A weak paragraph head often states what the paper will do (e.g., “This paper will discuss the difference between A and B”). Why it’s wrong: The topic sentence should directly state the main argument or conclusion (e.g., “A and B are different”) so the reader immediately understands the purpose of the paragraph.\nCreating a paragraph head that lacks a controlling idea: Some topic sentences state only the subject (“The difference between authorization and authentication”). Why it’s wrong: This fails to limit the scope of the paragraph, leaving the reader unsure of the argument the supporting sentences will develop.\nIncluding sentences that deviate from the main idea (lack of unification): Inserting information that is interesting but irrelevant to the controlling idea of the paragraph. Why it’s wrong: This confuses the reader, weakens the argument, and violates the fundamental rule of one paragraph, one idea.\nIntroducing new supporting details in the concluding sentence: Using the final sentence to provide a new piece of evidence, example, or fact. Why it’s wrong: The concluding sentence must summarize or rephrase existing content; new details belong in the body of the paragraph and require explanation and development.\nFailing to establish a known-new contract across sentences: Arranging sentences such that the beginning of a sentence introduces an entirely new concept unrelated to the stress of the previous sentence. Why it’s wrong: This makes the prose choppy and difficult to follow, breaking the logical chain of thought for the reader.\nUsing insufficient supporting sentences: Writing a paragraph with only one or two brief supporting sentences to prove the controlling idea. Why it’s wrong: The main idea remains underdeveloped, unsubstantiated, and unconvincing. An effective paragraph requires several well-detailed supporting sentences (at least three) to fully develop the argument.",
    "crumbs": [
      "Academic Writing and Argumentation",
      "4. Paragraphs, Structure, Transitions"
    ]
  },
  {
    "objectID": "Academic Writing and Argumentation/lec_6.html",
    "href": "Academic Writing and Argumentation/lec_6.html",
    "title": "6. Descriptive Paragraph",
    "section": "",
    "text": "1. Summary\n\n1.1 Introduction to Descriptive Paragraphs\nA descriptive paragraph is a focused piece of writing that aims to create a clear and vivid picture of a subject in the reader’s mind. Its primary goal is to describe the main features of a person, object, place, or concept using clear, specific details. Rather than telling the reader something, it shows them by appealing to their senses and intellect, allowing them to form their own mental image of the topic.\n\n\n1.2 Common Applications\nDescriptive paragraphs are a fundamental tool in technical and academic writing. They are typically used in the following scenarios:\n\nDescribing an object: Explaining the physical or logical components of a piece of hardware, a tool, or any other tangible item.\nDescribing a process: Outlining the steps or stages of a procedure, workflow, or event in a logical sequence.\nProviding a classification or typology: Grouping items into categories based on shared characteristics and describing the features of each category, as seen in the malware example.\n\n\n\n1.3 The Structure of a Descriptive Paragraph\nA well-formed descriptive paragraph follows a clear and logical structure, ensuring the reader can easily understand the information presented. \n\nParagraph Head (Topic Sentence): This is the opening sentence that introduces the main subject of the paragraph. It should be direct and engaging, clearly stating what will be described without using announcing phrases like “This paragraph will describe…” or “I am going to tell you about…”.\nBody (Features and Details): The body of the paragraph is built around the main features or characteristics of the subject. Each feature is introduced and then supported by several details. These details must consist of relevant information—facts, explanations, or examples that are essential for the reader to understand the description. For instance, when describing a computer virus, a key feature is how it spreads, and a relevant detail would be its attachment to a file that executes when opened.\nConcluding Sentence: This is the final sentence of the paragraph. It provides closure by either summarizing the main features discussed or rephrasing the paragraph head in a new way, reinforcing the paragraph’s main idea.\n\n\n\n1.4 Key Writing Tips\nTo write an effective descriptive paragraph, especially in a technical or academic context, adhere to the following guidelines:\n\nUse Neutral Language: Rely on objective, neutral words that describe the subject accurately without arousing strong emotions. The goal is to inform, not to persuade.\nStrive for Clarity: Make your description as clear and unambiguous as possible. Avoid jargon where possible, and explain it if it’s necessary.\nAdd a Title: A concise title helps frame the topic for the reader.\nEnsure Grammatical Correctness: Check that all sentences are complete, containing both a subject and a verb.\nMaintain an Effective Academic Style: Your writing should be formal, concise, and logically structured.\nProofread Diligently: Ask a peer to proofread your first draft to catch errors you might have missed.\nLearn from Mistakes: Take note of frequent errors in your writing and make a conscious effort to avoid them in the future.\n\n\n\n\n2. Definitions\n\nDescriptive Paragraph: A paragraph focused on creating a clear, detailed picture of a person, place, object, or concept in the reader’s mind.\nParagraph Head: The topic sentence that introduces the subject of the paragraph.\nFeature: A main characteristic or distinct aspect of the subject being described.\nDetail: A specific piece of relevant information, such as a fact or an explanation, that elaborates on a feature.\nConcluding Sentence: The final sentence that summarizes the main points or restates the paragraph head to provide closure.\n\n\n\n3. Mistakes\n\nAnnouncing your topic directly: Using phrases like “I will now describe the CPU.” Why it’s wrong: This is considered poor style in academic writing. The paragraph head should introduce the topic naturally without explicitly stating the author’s intent.\nUsing vague or general language: Describing something as “good” or “interesting” without providing specific details. Why it’s wrong: Descriptive writing relies on precision. The reader cannot form a clear picture from terms that are subjective and lack concrete information.\nDisorganized information: Presenting features and details in a random, illogical order. Why it’s wrong: A lack of structure confuses the reader. Information should be organized logically (e.g., from general to specific, top to bottom, or by category) to be easily understood.\nOmitting a concluding sentence: Ending the paragraph abruptly after the last detail. Why it’s wrong: The concluding sentence is crucial for signaling that the description is complete and for reinforcing the main point, leaving the reader with a sense of closure.\nIncluding irrelevant information: Adding details that do not directly support the feature being described. Why it’s wrong: Extraneous information distracts the reader and weakens the paragraph’s focus and clarity.\nRelying on emotionally charged words: Using biased or subjective language instead of neutral, objective terms. Why it’s wrong: In technical and academic writing, the goal is objective clarity, not emotional persuasion. Emotional words can undermine the credibility of the description.",
    "crumbs": [
      "Academic Writing and Argumentation",
      "6. Descriptive Paragraph"
    ]
  },
  {
    "objectID": "Academic Writing and Argumentation/lec_3.html",
    "href": "Academic Writing and Argumentation/lec_3.html",
    "title": "3. Sentence Problems, Punctuation",
    "section": "",
    "text": "1. Summary\n\n1.1 Sentence Problems and How to Fix Them\nCorrect sentence structure is essential for clear and effective communication. Common problems can make writing confusing or unprofessional, but they are easily fixed once identified.\n\n\n1.1.1 Sentence Fragments\nA sentence fragment is an incomplete thought punctuated as if it were a complete sentence. It lacks a subject, a verb, or both, and cannot stand on its own.\n\nFragment: Three dogs and a goat. (Missing a verb/action).\nComplete Sentence: Three dogs and a goat ate all the food. (Now includes the verb “ate”).\nFragment: Because I could not find my shoes. (This is a dependent clause, an incomplete thought).\nComplete Sentence: I felt sad because I could not find my shoes. (The fragment is now attached to a complete sentence).\n\n\n\n1.1.2 Choppy Sentences\nChoppy sentences are short, simple sentences that occur one after another. While grammatically correct, they can make writing sound abrupt and disconnected. The solution is to combine these short sentences into longer, more fluid ones using conjunctions and transitions.\n\nChoppy: Our results were inconsistent. The program obviously contains an error. We need to talk to Paul Davis. We will ask him to review the program.\nImproved: We will ask Paul Davis to review the program for errors because it produced inconsistent results.\n\n\n\n1.1.3 Run-on Sentences\nA run-on sentence occurs when two or more independent clauses (complete thoughts) are joined together improperly.\n\nThere are two main types:\n\nFused Sentences: Two independent clauses are joined with no punctuation at all.\n\nFused: The experiment failed it had been left unobserved for too long.\nCorrected: The experiment failed because it had been left unobserved for too long. (Using a subordinating conjunction).\nCorrected: The experiment had been left unobserved for too long, so it failed. (Using a comma and a coordinating conjunction).\n\nComma-Splice Sentences: Two independent clauses are joined with only a comma, which is not strong enough punctuation to connect them.\n\nComma Splice: The experiment failed, it had been left unobserved for too long.\nCorrected: The experiment failed because it had been left unobserved for too long.\nCorrected: The experiment had been left unobserved for too long, so it failed.\n\n\n\n\n1.1.4 Loose Sentences\nA loose sentence is a long, rambling sentence that contains too many clauses and phrases, making the main point difficult to understand. The key ideas are often buried in a series of additions. To fix this, break the sentence into shorter, more direct sentences that clearly state the essential information.\n\nLoose: We got the contract, according to which we must be ready by June 1 with the necessary personnel and equipment to get the job done, so with this in mind a staff meeting that all group managers are expected to attend, is scheduled for February 12.\nImproved: We must close the contract by June 1, so a mandatory staff meeting is scheduled for February 12.\n\n\n\n1.1.5 Inappropriate or Excessive Coordination\nThis error occurs when too many independent clauses are linked together with coordinating conjunctions (like and, so, but), creating a long, stringy sentence that doesn’t show the proper relationship between ideas. The fix is to break the sentence into smaller ones or use subordination to clarify the relationship.\n\nInappropriate: Roses are a popular flower, and they are difficult to grow, so many people choose to purchase them as cut flowers instead, but that can be expensive.\nImproved: Roses are a popular flower that are difficult to grow. So, many people buy cut roses, but that can be expensive.\n\n\n\n1.1.6 Inappropriate or Excessive Subordination\nThis happens when a sentence has too many dependent clauses, creating a confusing and tangled structure. The main idea gets lost among less important details. The solution is to restructure the sentence into several shorter sentences, giving the main ideas more prominence.\n\nExcessive: Although Bwana thought that he was prepared, he failed the examination, which meant that he had to repeat the course before he could graduate which he did not want to do because it would conflict with his summer job.\nImproved: Bwana thought that he was prepared, but he failed the examination. Therefore, he would have to repeat the course before he could graduate. He did not want to do that because it would conflict with his summer job.\n\n\n\n1.1.7 Non-Parallel Structures\nParallel structure means using the same grammatical form for items in a list or series. When this rule is broken, the sentence has a non-parallel structure, which can be awkward and confusing.\n\nNon-Parallel: I like to swim, to sail, and rowing. (The items are a mix of infinitives and a gerund).\nParallel: I like to swim, to sail, and to row. (All infinitives).\nParallel: I like swimming, sailing, and rowing. (All gerunds).\n\n\n\n1.1.8 that vs. which\nThe choice between that and which depends on whether the clause that follows is essential or non-essential to the meaning of the sentence.\n\nUse that for Restrictive (Essential) Clauses: A restrictive clause provides information that is essential to identify the noun it describes. You cannot remove it without changing the sentence’s core meaning. These clauses are not set off by commas.\n\nExample: This animal is the pink elephant that I love. (The clause that I love is essential; it specifies which pink elephant we are talking about).\n\nUse which for Non-Restrictive (Non-Essential) Clauses: A non-restrictive clause provides extra, non-essential information. It can be removed without changing the sentence’s basic meaning. These clauses are always set off by commas.\n\nExample: This animal is a pink elephant, which I love. (The clause which I love is extra information. The main point is that the animal is a pink elephant).\n\n\n\n\n1.2 Using Commas\nCommas are punctuation marks that serve two main purposes: to tell readers where to pause and to separate groups of words to ensure clarity.\n\n\n1.2.1 Commas with Clauses\n\nIndependent Clauses: Use a comma before a coordinating conjunction (For, And, Nor, But, Or, Yet, So - FANBOYS) when it joins two independent clauses.\n\nExample: The student explained her question, yet the instructor still didn't seem to understand.\n\nDependent Clauses: Do not use a comma when two clauses are joined by a subordinating conjunction (like if, since, as, when, although, while, after, before, until, because) and the independent clause comes first.\n\nExample: A cannibal does not eat clowns because they taste funny.\n\nIntroductory Dependent Clauses: Use a comma after a dependent clause when it comes before the independent clause.\n\nExample: Since clowns taste funny, a cannibal does not eat them.\n\n\n\n\n1.2.2 Commas with Transitions\nUse a comma after a transitional word or phrase (e.g., Therefore, However, For example).\n\nExample: Clowns taste funny. Therefore, a cannibal does not eat them.\nExample: Dogs have masters. However, cats have servants.\n\n\n\n1.2.3 Commas in Lists\n\nUse commas to separate three or more items in a list. The comma before the and is known as the Oxford comma and is often used for clarity.\n\nExample: My bath toys were a hairdryer, a toaster, and a radio.\n\nIf a list contains only two items, do not use a comma.\n\nExample: My bath toys were a hairdryer and a toaster.\n\n\n\n\n1.2.4 Commas for Quotations\n\nReporting Clause First: He said, \"If you cannot see the bright side of life, polish the dull side.\"\nQuotation First: \"If you can't see the bright side of life, polish the dull side,\" he said.\nQuotation Divided: \"If you can't see the bright side of life,\" he said, \"polish the dull side.\"\n\n\n\n1.2.5 Commas with Parenthetical Expressions and Appositives\n\nA parenthetical expression is an extra piece of information that can be removed without changing the sentence’s meaning or grammar. It should be set off by commas.\n\nExample: Clowns, as most researchers know, taste funny.\n\nAn appositive is a word or phrase that renames a nearby noun. It provides more information about the noun and is also set off by commas.\n\nExample: Clowns, those sweaty artists, taste funny.\n\nImportant Note: Overusing parenthetical expressions and appositives can make text less readable by separating the subject and verb. For clearer writing, consider placing them at the beginning of a sentence or in a separate clause.\n\nLess Effective: Dogs, unlike cats, have masters.\nMore Effective: Unlike cats, dogs have masters.\nLess Effective: Dogs, the humans' best friends, have masters.\nMore Effective: Dogs are the humans' best friends, so dogs have masters.\n\n\n\n\n1.2.6 Commas for Contrast\nUse a comma to separate contrasting parts of a sentence.\n\nExample: Cats have servants, not masters.\nExample: Dogs have masters, not servants.\n\n\n\n1.3 Bulleted and Numbered Lists\nLists are an effective way to organize information. The punctuation rules depend on whether the list items are complete sentences.\n\n\n1.3.1 Incomplete Sentence Items\nWhen list items are phrases or fragments that complete an introductory stem, use the following format: * Introduce the list with a colon. * Begin each item with a lowercase letter. * Place a semicolon after each item. * Use a period after the final item.\n\nExample: My parents clearly hated me because they gave me the following toys to play in the bathtub with:\n\na hairdryer;\na toaster;\na radio.\n\n\n\n\n1.3.2 Complete Sentence Items\nWhen each item in the list is a complete sentence, use this format: * Introduce the list with a colon. * Begin each item with a capital letter. * Place a period after each item.\n\nExample: Cannibals do not eat clowns due to the following reasons:\n\nClowns run fast.\nClowns taste funny.\nClowns are scary.\n\n\n\n\n\n2. Mistakes\n\nComma Splice: Using only a comma to connect two complete sentences (independent clauses). Why it’s wrong: A comma is not strong enough to join two separate thoughts. You should use a period, a semicolon, or a comma followed by a coordinating conjunction (like and, but, so).\nFused Sentence: Joining two complete sentences with no punctuation at all. Why it’s wrong: This creates a run-on sentence that is confusing and forces the reader to guess where one idea ends and the next begins.\nSentence Fragment: Punctuating an incomplete thought as if it were a full sentence. Why it’s wrong: A sentence must contain at least one independent clause with a subject and a verb to be grammatically complete.\nNon-Parallel Structure: Mixing grammatical forms when listing items in a series (e.g., running, to jump, and played). Why it’s wrong: This disrupts the rhythm and logic of the sentence, making it harder to read and understand. All items in a series should have the same grammatical structure.\nSeparating Subject and Verb with a Comma: Placing a single comma between the subject of a sentence and its main verb. Why it’s wrong: The subject and verb are the core of a sentence and should not be separated. An exception is when a non-essential phrase (set off by two commas) is inserted between them.\nConfusing that and which: Using which for an essential (restrictive) clause or that for a non-essential (non-restrictive) clause. Why it’s wrong: This can change the fundamental meaning of the sentence. that is used for information necessary to identify the noun, while which (with a comma) adds extra, non-essential information.",
    "crumbs": [
      "Academic Writing and Argumentation",
      "3. Sentence Problems, Punctuation"
    ]
  },
  {
    "objectID": "Introduction to Programming/lec_2.html",
    "href": "Introduction to Programming/lec_2.html",
    "title": "2. Pointers, Strings, and Arrays in C",
    "section": "",
    "text": "1. Summary\n\n1.1 Memory, Values, and Addresses\nIn computing, a program’s data is stored in memory. It’s helpful to visualize memory as a huge, single sequence of cells, much like a long row of mailboxes. Each cell has two key attributes:\n\nAn address: This is a unique numerical identifier for the cell’s location, similar to a mailbox number. Addresses are typically represented in hexadecimal format (e.g., 0x7ffc...).\nA value: This is the actual data stored inside the cell, like the letter inside a mailbox.\n\nEvery variable you declare in a program, whether it’s an integer, a character, or something more complex, occupies one or more of these memory cells. The crucial concept is to distinguish between the address of a variable and the value it holds. For instance, an integer variable x with a value of 100 might be located at memory address 0x23451.\n\n\n\n1.2 Pointers\nA pointer is a special type of variable designed to hold a memory address as its value. Instead of storing data like an integer or a character directly, it stores the location of other data. This makes pointers an incredibly powerful tool for indirect data manipulation.\nA pointer is declared by specifying the type of data it will point to, followed by an asterisk (*). For example, int* p; declares a pointer p that is intended to hold the address of an integer.\nThere are two fundamental operators associated with pointers:\n\nThe address-of operator (&): This is a unary operator that, when placed before a variable name, returns its memory address. For example, &var1 gives the address where var1 is stored.\nThe dereference operator (*): This is also a unary operator that, when placed before a pointer variable, accesses the value at the address the pointer is holding. It essentially says, “go to the address stored in this pointer and get the value from there.”\n\nFor example, to make a pointer p point to an integer x, you would write p = &x;. To then retrieve the value of x using the pointer p, you would write *p.\n\n\n1.3 Arrays\nAn array is a data structure that stores a fixed-size, sequential collection of elements of the same data type. Imagine an array as a connected block of memory cells. You can access individual elements by their position, or index, which starts at 0.\nFor example, double balance[10]; declares an array named balance that can hold 10 elements of type double. The first element is balance[0] and the last is balance[9].\nA critical concept in C is the close relationship between arrays and pointers. The name of an array, when used in most expressions, decays into a pointer to its first element. This means that the expressions balance and &balance[0] are equivalent; both yield the memory address of the first element of the array.\nBecause of this, you can use pointer arithmetic to navigate an array. If p is a pointer to the first element of an array, then *(p + i) is equivalent to array[i]. It’s important to note that pointer arithmetic is automatically scaled by the size of the data type. If p is an int*, p + 1 increments the address not by 1 byte, but by sizeof(int) bytes to point to the next integer in memory.\n\n\n1.4 Strings in C\nIn the C programming language, a string is not a built-in data type. Instead, a string is implemented as a one-dimensional array of characters that is terminated by a special character called the null terminator.\nThe null terminator, represented as \\0, is a character with the ASCII value 0. It serves as a marker to signal the end of the string. Standard library functions that work with strings (like printing or calculating length) rely on this null character to know where to stop processing.\nThere are two common ways to initialize a string: 1. As a character array: char greeting[] = {'H', 'e', 'l', 'l', 'o', '\\0'};. In this case, you must explicitly include the \\0 at the end. 2. As a string literal: char greeting[] = \"Hello\";. This is the more common and convenient method. When you use double quotes, the compiler automatically allocates enough space for the characters and appends the \\0 terminator for you. This is why “Hello” requires an array of 6 characters, not 5.\nFailure to properly null-terminate a character array will lead to undefined behavior when it is treated as a string, as functions will read past the end of the intended data into adjacent memory.\n\n\n\n2. Definitions\n\nPointer: A variable that stores the memory address of another variable or a location in memory.\nArray: A data structure consisting of a fixed-size, contiguous collection of elements of the same data type, accessed by an integer index.\nC-Style String: A sequence of characters stored in a character array and terminated by a null character (\\0).\nNull Terminator (\\0): A special character with an ASCII value of zero that marks the end of a C-style string.\nAddress-of Operator (&): A unary operator that returns the memory address of its operand (the variable it is applied to).\nDereference Operator (*): A unary operator that accesses the value stored at the memory address held by a pointer. It is used to “de-reference” the pointer to get to the data it points to.\nDangling Pointer: A pointer that refers to a memory location that has already been freed or is otherwise no longer valid (e.g., pointing to a local variable that has gone out of scope).\n\n\n\n3. Mistakes\n\nForgetting the Null Terminator: When manually building a string character by character in an array, it’s easy to forget to add the \\0 at the end. Why it’s wrong: Standard string functions will not know where the string ends and will continue reading into adjacent memory, causing bugs and potential crashes.\nDereferencing an Uninitialized Pointer: Declaring a pointer like int* p; and then immediately trying to use it like *p = 10;. Why it’s wrong: The pointer p holds a garbage memory address. Writing to this random location corrupts memory and leads to undefined behavior. A pointer must first be assigned a valid address.\nReturning a Pointer to a Local Variable: A function creates a local variable and returns its address. Why it’s wrong: The local variable exists on the function’s stack frame, which is destroyed upon the function’s return. The returned pointer becomes a “dangling pointer” that points to invalid memory.\nArray Out-of-Bounds Access: Trying to access an element beyond the defined size of an array, such as accessing arr[10] in an array declared as int arr[10];. Why it’s wrong: The valid indices are 0 through 9. Accessing arr[10] reads from or writes to memory that is not part of the array, which can corrupt other variables or cause the program to crash.\nConfusing Pointer Assignment with Value Assignment: Writing p = q; when you meant *p = *q;. Why it’s wrong: p = q; makes pointer p point to the same memory address as pointer q. In contrast, *p = *q; copies the value from the location pointed to by q to the location pointed to by p. These are fundamentally different operations.\nAssuming sizeof gives the length of a string: Using sizeof(my_string) to find the number of characters in a string. Why it’s wrong: sizeof is a compile-time operator that returns the total memory size of the array in bytes, not the number of characters before the null terminator. To get the string length at runtime, you must use the strlen() function.\n\n\n\n4. Examples\n\n4.1. Swap Two Integers using Pointers\nQuestion: Write a C function swap that takes pointers to two integers as arguments and swaps their values.\n\n\nClick to see the solution\n\n#include &lt;stdio.h&gt;\n\nvoid swap(int* a, int* b) {\n    // 1. Declare a temporary integer variable to hold one of the values.\n    int temp;\n\n    // 2. Dereference pointer 'a' to get its value and store it in 'temp'.\n    temp = *a;\n\n    // 3. Dereference pointer 'b' to get its value, then dereference 'a' again\n    //    to assign this value to the variable 'a' points to.\n    *a = *b;\n\n    // 4. Assign the value stored in 'temp' (the original value of *a) to the\n    //    variable that 'b' points to.\n    *b = temp;\n}\n\nint main() {\n    int x = 10;\n    int y = 20;\n    printf(\"Before swap: x = %d, y = %d\\n\", x, y);\n    swap(&x, &y); // Pass the addresses of x and y\n    printf(\"After swap: x = %d, y = %d\\n\", x, y);\n    return 0;\n}\nAnswer: The function uses a temporary variable to hold the value of the first integer. It then uses the dereference operator * to access and modify the values at the memory addresses passed into it, effectively swapping them in the main function’s scope. The output will be: Before swap: x = 10, y = 20 After swap: x = 20, y = 10\n\n\n\n4.2. Calculate String Length\nQuestion: Write a C function my_strlen that takes a constant character pointer (a string) and returns its length, excluding the null terminator. Do not use the standard strlen library function.\n\n\nClick to see the solution\n\n#include &lt;stdio.h&gt;\n\nint my_strlen(const char* str) {\n    // 1. Initialize a counter for the length to 0.\n    int length = 0;\n\n    // 2. Use a while loop that continues as long as the character\n    //    at the current pointer location is not the null terminator ('\\0').\n    //    The expression *(str + length) is equivalent to str[length].\n    while (*(str + length) != '\\0') {\n        // 3. Increment the length counter for each non-null character.\n        length++;\n    }\n\n    // 4. Return the final count.\n    return length;\n}\n\nint main() {\n    char my_string[] = \"Hello, World!\";\n    int len = my_strlen(my_string);\n    printf(\"The length of the string is: %d\\n\", len);\n    return 0;\n}\nAnswer: The function iterates through the character array using pointer arithmetic, incrementing a counter until it encounters the \\0 character. The final count is the length of the string. The output will be 19. The output will be: The length of the string is: 13\n\n\n\n4.3. Reverse a String in Place\nQuestion: Write a C function that takes a character array (string) and reverses it in place using pointers.\n\n\nClick to see the solution\n\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt; // For strlen to find the end\n\nvoid reverse_string(char* str) {\n    // 1. Create two pointers. 'start' points to the beginning of the string.\n    char* start = str;\n    \n    // 2. 'end' points to the last character of the string (before the null terminator).\n    char* end = str + strlen(str) - 1;\n    \n    char temp;\n\n    // 3. Loop as long as the start pointer is before the end pointer.\n    while (start &lt; end) {\n        // 4. Swap the characters pointed to by 'start' and 'end'.\n        temp = *start;\n        *start = *end;\n        *end = temp;\n\n        // 5. Move the 'start' pointer forward and the 'end' pointer backward.\n        start++;\n        end--;\n    }\n}\n\nint main() {\n    char my_string[] = \"Quarto\";\n    printf(\"Original string: %s\\n\", my_string);\n    reverse_string(my_string);\n    printf(\"Reversed string: %s\\n\", my_string);\n    return 0;\n}\nAnswer: The function uses two pointers, one at the beginning and one at the end of the string. It swaps the characters they point to and then moves the pointers toward the center until they meet or cross, effectively reversing the entire string. The output will be: Original string: Quarto Reversed string: otrauQ\n\n\n\n4.4. Sum Array Elements using a Pointer\nQuestion: Write a C function that calculates the sum of all elements in an integer array using only pointer arithmetic to iterate through the array. The function should take a pointer to the first element and the size of the array.\n\n\nClick to see the solution\n\n#include &lt;stdio.h&gt;\n\nint sum_array(int* arr, int size) {\n    // 1. Initialize a sum variable to 0.\n    int sum = 0;\n    \n    // 2. Create a pointer 'ptr' and initialize it with the starting address of the array.\n    int* ptr = arr;\n    \n    // 3. Create a pointer 'end' that points to the memory location just after the last element.\n    //    This will serve as our loop termination condition.\n    int* end = arr + size;\n\n    // 4. Loop while the current pointer 'ptr' has not reached the 'end' pointer.\n    for (; ptr &lt; end; ptr++) {\n        // 5. Dereference the current pointer to get the integer value and add it to the sum.\n        sum += *ptr;\n    }\n\n    return sum;\n}\n\nint main() {\n    int numbers[] = {10, 20, 30, 40, 50};\n    int total = sum_array(numbers, 5);\n    printf(\"The sum of the array elements is: %d\\n\", total);\n    return 0;\n}\nAnswer: The function iterates through the array by incrementing a pointer from the start of the array to one element past the end. In each iteration, it dereferences the pointer to add the current element’s value to a running total. The output will be: The sum of the array elements is: 150\n\n\n\n4.5. Find the Maximum Value in an Array\nQuestion: Write a C function find_max that finds the largest integer in an array using pointers. The function should return a pointer to the element containing the maximum value.\n\n\nClick to see the solution\n\n#include &lt;stdio.h&gt;\n\nint* find_max(int* arr, int size) {\n    // 1. Handle the edge case of an empty or invalid array.\n    if (arr == NULL || size &lt;= 0) {\n        return NULL;\n    }\n\n    // 2. Create a pointer to hold the address of the maximum element found so far.\n    //    Initialize it to point to the first element of the array.\n    int* max_ptr = arr;\n    \n    // 3. Loop through the array from the second element to the end.\n    for (int i = 1; i &lt; size; i++) {\n        // 4. Compare the value at the current position (arr[i]) with the value\n        //    at the current maximum's position (*max_ptr).\n        if (arr[i] &gt; *max_ptr) {\n            // 5. If the current element is larger, update max_ptr to point to it.\n            max_ptr = &arr[i];\n        }\n    }\n\n    // 6. Return the pointer to the largest element.\n    return max_ptr;\n}\n\nint main() {\n    int numbers[] = {1, 99, 23, 56, 88};\n    int* max_element_ptr = find_max(numbers, 5);\n    \n    if (max_element_ptr != NULL) {\n        printf(\"The maximum value in the array is: %d\\n\", *max_element_ptr);\n    }\n    \n    return 0;\n}\nAnswer: The function assumes the first element is the maximum, then iterates through the rest of the array. If it finds a larger element, it updates its max_ptr to point to that new maximum element. It returns the final pointer. The output will be: The maximum value in the array is: 99\n\n\n\n4.6. Concatenate Two Strings\nQuestion: Write a C function my_strcat that appends the source string to the end of the destination string. Assume the destination array has enough space. The function should return a pointer to the destination string.\n\n\nClick to see the solution\n\n#include &lt;stdio.h&gt;\n\nchar* my_strcat(char* dest, const char* src) {\n    // 1. Create a pointer to the start of the destination string to return later.\n    char* ptr = dest;\n\n    // 2. Move the pointer 'dest' to the end of the destination string.\n    //    The loop stops when it finds the null terminator.\n    while (*dest != '\\0') {\n        dest++;\n    }\n\n    // 3. Copy characters from the source 'src' to the destination 'dest'\n    //    until the null terminator of the source is reached.\n    while (*src != '\\0') {\n        *dest = *src;\n        dest++;\n        src++;\n    }\n\n    // 4. Add the null terminator to the end of the newly combined string.\n    *dest = '\\0';\n\n    // 5. Return the original starting address of the destination string.\n    return ptr;\n}\n\nint main() {\n    char str1 = \"Hello, \";\n    char str2[] = \"World!\";\n    \n    printf(\"String 1 before: %s\\n\", str1);\n    my_strcat(str1, str2);\n    printf(\"String 1 after: %s\\n\", str1);\n    \n    return 0;\n}\nAnswer: The function first finds the end of the dest string by locating its null terminator. Then, it copies characters one by one from the src string to the end of the dest string. Finally, it adds a new null terminator to mark the end of the concatenated string. The output will be: String 1 before: Hello, String 1 after: Hello, World!\n\n\n\n4.7. Initialize and Print a 2D Array using Pointers\nQuestion: Declare a 2x3 integer array. Write a function that takes a pointer to this 2D array, its number of rows, and its number of columns to initialize it with sequential numbers. Write another function to print it using pointer notation.\n\n\nClick to see the solution\n\n#include &lt;stdio.h&gt;\n\n// Note the function parameter: int (*arr) is a pointer to an array of 3 integers.\nvoid initialize_array(int (*arr), int rows, int cols) {\n    int count = 1;\n    // 1. Iterate through each row.\n    for (int i = 0; i &lt; rows; i++) {\n        // 2. Iterate through each column in the current row.\n        for (int j = 0; j &lt; cols; j++) {\n            // 3. Use pointer notation to access the element.\n            //    arr[i] is the i-th array (row).\n            //    *(arr + i) is also a pointer to the i-th row.\n            //    *(*(arr + i) + j) is the element at row i, col j.\n            *(*(arr + i) + j) = count++;\n        }\n    }\n}\n\nvoid print_array(int (*arr), int rows, int cols) {\n    for (int i = 0; i &lt; rows; i++) {\n        for (int j = 0; j &lt; cols; j++) {\n            // 4. Print the element using the same pointer notation.\n            printf(\"%d\\t\", *(*(arr + i) + j));\n        }\n        printf(\"\\n\");\n    }\n}\n\nint main() {\n    int my_array;\n    \n    initialize_array(my_array, 2, 3);\n    print_array(my_array, 2, 3);\n    \n    return 0;\n}\nAnswer: The key is the function signature int (*arr)[3], which correctly declares a pointer to a complete row (an array of 3 integers). Inside the functions, the expression *(*(arr + i) + j) is used. arr + i moves the pointer to the i-th row, *(arr + i) dereferences it to get a pointer to the first element of that row, and adding j moves it to the j-th column. The final dereference * gets the value. The output will be: 1 2 3 4 5 6",
    "crumbs": [
      "Introduction to Programming",
      "2. Pointers, Strings, and Arrays in C"
    ]
  },
  {
    "objectID": "Introduction to Programming/lec_1.html",
    "href": "Introduction to Programming/lec_1.html",
    "title": "1. Introduction to C, Compilers, and Program Structure",
    "section": "",
    "text": "1. Summary\n\n1.1 The C Programming Language\nThe C programming language is a foundational, general-purpose language known for its efficiency and control over system hardware. Developed by Dennis Ritchie and Brian Kernighan, it is not considered a “very high-level” language, meaning it lacks some of the automatic safety features and abstractions of more modern languages. However, its generality and absence of restrictions make it highly effective for a wide range of tasks, particularly system-level programming like operating systems and embedded devices.\nKey characteristics of C include:\n\nMiddle-Level Language: C provides a balance between high-level abstractions (like functions and variables) and low-level control (like direct memory manipulation). It is sometimes called a “universal assembly language” because its constructs map closely to machine instructions.\nCompiled Language: C code is not executed directly. It must first be processed by a compiler, which translates the human-readable source code into machine code that the computer’s processor can understand and execute.\nStatically Typed: Every variable in C has a type (e.g., int for integer, float for floating-point number), and this type is fixed when the code is compiled. While C is typed, it is not strongly typed, as it allows for various explicit and implicit type conversions.\nProcedural: C follows a procedural paradigm, where programs are constructed from procedures, also known as functions or subroutines.\nUnsafe: C grants the programmer significant power, including direct memory access. This power comes with responsibility, as the language does not have built-in safeguards against common errors like accessing invalid memory locations, which can lead to program crashes or security vulnerabilities.\n\n\n\n1.2 Essential Tools for C Programming\nTo write and run a C program, you only need two fundamental tools: a Text Editor and a C Compiler.\n\nText Editor: This is any program used to write and edit plain text files. Examples include Notepad++, VS Code, Vim, or Emacs. The file containing C code is called a source file and is typically saved with a .c extension (e.g., program.c).\nC Compiler: This is a specialized program that translates the C source code into an executable file containing machine instructions. The most common compiler is GCC (GNU Compiler Collection). While an Integrated Development Environment (IDE) like CLion or Visual Studio can be helpful, it is not strictly necessary; an IDE simply bundles a text editor, compiler, debugger, and other tools into a single application.\n\n\n\n1.3 The Compilation Process\nCreating an executable program from C source code involves several stages, managed primarily by the compiler and a tool called the linker.\nA C program can be split across multiple .c files. Each file is considered a translation unit and is compiled independently. The overall process is as follows:\n\nPreprocessing: The preprocessor handles directives that start with #, such as #include &lt;stdio.h&gt;. It copies the contents of the specified header file (stdio.h) directly into the source file.\nCompilation (Source Code to Assembly): The compiler proper takes the preprocessed code and translates it into assembly language, which is a low-level, human-readable representation of machine instructions.\nAssembly (Assembly to Object Code): The assembler converts the assembly code into machine code. The result is an object file, which typically has a .o or .obj extension. This file contains the machine code for that specific translation unit but is not yet a complete, runnable program. It may have references to functions or variables defined in other files.\nLinking: The linker’s job is to combine one or more object files into a single executable file. It resolves any cross-file references (e.g., when a function in main.c calls a function defined in utils.c) and links necessary code from standard libraries (like the library containing printf). The final output is a runnable program.\n\n\n\n\n\n\n\n\n\nFigure 1: The C compilation and linking process for multiple source files.\n\n\n\n\n\n\n\n1.4 Program Structure and Memory Model\nA running program uses several distinct regions of memory, each with a specific purpose. This organization is known as the memory model.\n\nProgram (Code) Segment: This region contains the compiled machine instructions of the program. It is typically read-only to prevent the program from accidentally modifying itself.\nStatic/Global Data Segment: This holds global variables (declared outside any function) and static variables (declared with the static keyword). These variables exist for the entire lifetime of the program.\nHeap: This is a region of memory available for dynamic allocation. It is used for data whose size is not known at compile time or that must outlive the function that created it. In C, memory on the heap is managed manually using functions like malloc() and free(). The heap typically grows upwards toward higher memory addresses.\nStack: This region of memory is used to manage function calls. It stores local variables (variables declared inside a function), function parameters, and return addresses. The stack operates on a Last-In, First-Out (LIFO) principle. When a function is called, a new stack frame (or activation record) is pushed onto the stack. This frame contains all the data associated with that function call. When the function returns, its stack frame is popped off, and the memory becomes available for the next function call. The stack typically grows downwards toward lower memory addresses.\n\n\n\n\n\n\n\n\n\nFigure 2: Program Memory Model showing the four main memory segments: Code, Static/Global Data, Heap, and Stack\n\n\n\n\n\n\n\n1.5 Variables, Scope, and Storage Classes\nA variable is a name for a location in memory that stores a value. In C, variables must be declared before they are used, specifying their type and name.\nThe scope of a variable defines the portion of the code where the variable is visible and can be accessed. C uses lexical scoping, where scope is determined by the structure of the source code. The primary unit of scope is the block, which is any section of code enclosed in curly braces {}.\n\nBlock Scope: A variable declared inside a block (including function bodies, loops, and if statements) is only visible from its point of declaration to the end of that block.\nVariable Hiding (Shadowing): If a variable in an inner block has the same name as a variable in an outer block, the inner variable “hides” the outer one. The inner block will only be able to access its own local variable.\n\nStorage classes are keywords that determine a variable’s lifetime (how long it exists in memory) and linkage (its visibility across different translation units).\n\nauto: This is the default for variables declared inside a function. An auto variable has a local lifetime; it is created when its block is entered and destroyed when the block is exited. It is stored on the stack.\nstatic:\n\nWhen used inside a function, static gives a variable a static lifetime. The variable is created and initialized only once when the program starts and retains its value between function calls.\nWhen used for a global variable, static limits its visibility to only the file in which it is declared (internal linkage).\n\nextern: This keyword declares a variable without defining it. It tells the compiler that the variable exists and is defined in another source file. This is used to share global variables across multiple .c files.\n\n\n\n\n2. Definitions\n\nCompiler: A program that translates source code written in a high-level programming language (like C) into low-level machine code that a computer’s processor can execute.\nLinker: A program that takes one or more object files generated by a compiler and combines them into a single executable file, shared library, or another object file.\nSource File: A text file containing human-readable instructions written in a programming language. In C, these files typically have a .c extension.\nObject File: A file containing machine code generated by a compiler or assembler from a source file. It is not yet a complete program and must be processed by the linker.\nExecutable File: A file containing a complete program in machine code that can be run directly by the computer’s operating system.\nTranslation Unit: A single source file after it has been processed by the C preprocessor. It is the basic unit of compilation.\nStack: A region of computer memory that stores temporary variables created by each function. It operates in a Last-In, First-Out (LIFO) manner.\nHeap: A region of computer memory used for dynamic memory allocation, where the programmer can request and free blocks of memory as needed during runtime.\nScope: The region of a program’s source code where a declared variable is visible and can be used.\nStorage Class: A specifier (auto, static, extern, register) that determines the lifetime and visibility (linkage) of a variable or function.\n\n\n\n4. Mistakes\n\nForgetting Semicolons (;): Every statement in C must end with a semicolon. Why it’s wrong: The semicolon tells the compiler where one statement ends and the next begins. Forgetting it is a syntax error that will prevent the code from compiling.\nUsing Assignment (=) Instead of Comparison (==): Using a single equals sign in a conditional statement (e.g., if (x = 5)) assigns the value 5 to x and the expression evaluates to 5 (which is treated as true). Why it’s wrong: This almost always leads to incorrect logic. The double equals sign == is required to test for equality.\nInteger Division Truncation: When dividing two integers, C performs integer division, which discards any fractional part. For example, 7 / 2 evaluates to 3, not 3.5. Why it’s wrong: This can lead to unexpected and incorrect mathematical results if you need precise floating-point answers.\nIgnoring Compiler Warnings: Compilers often issue warnings about code that is syntactically correct but potentially problematic (e.g., using a variable before it has been initialized). Why it’s wrong: While the code might compile, warnings often point to logical errors or undefined behavior that can cause bugs or crashes at runtime.\nForgetting to Include Header Files: Using a function like printf without including the necessary header file (#include &lt;stdio.h&gt;) will cause a compilation error. Why it’s wrong: Header files contain the function declarations that tell the compiler what functions are available, what arguments they take, and what they return. Without this information, the compiler cannot verify the function call.\nAccessing an Array Out of Bounds: Trying to access an element beyond the defined size of an array (e.g., accessing arr[10] in an array of size 10, where valid indices are 0-9). Why it’s wrong: C does not check array boundaries. This leads to undefined behavior, which can corrupt memory, overwrite other variables, or crash the program.\n\n\n\n5. Examples\n\n5.1. Basic “Hello, World!” Program\nQuestion: Write, compile, and describe the output of a standard “Hello, World!” program in C.\n\n\nClick to see the solution\n\n\nWrite the C code and save it in a file named hello.c. The code uses the printf function to print a string to the console. The #include &lt;stdio.h&gt; line is necessary because the declaration for printf is in the standard input/output header file. The main function is the entry point of every C program.\n#include &lt;stdio.h&gt;\n\nint main() {\n    printf(\"Hello, World!\\n\");\n    return 0;\n}\nCompile the code using GCC from the command line. This command tells the compiler to take the source file hello.c and produce an executable file named hello. sh     gcc hello.c -o hello\nRun the executable. sh     ./hello\n\nAnswer: The program will print the following text to the console: Hello, World!\n\n\n\n5.2. Variable Declaration and Arithmetic\nQuestion: Write a C program that declares two integer variables, x and y, initializes them to 10 and 5 respectively, and then prints their sum, difference, product, and quotient.\n\n\nClick to see the solution\n\n\nInclude the standard I/O header to use printf.\nDefine the main function.\nDeclare and initialize two integer variables, x and y.\nUse printf for each operation. The %d format specifier is a placeholder for an integer value. The \\n character creates a new line after each output.\n#include &lt;stdio.h&gt;\n\nint main() {\n    int x = 10;\n    int y = 5;\n\n    printf(\"Sum: %d\\n\", x + y);\n    printf(\"Difference: %d\\n\", x - y);\n    printf(\"Product: %d\\n\", x * y);\n    printf(\"Quotient: %d\\n\", x / y);\n\n    return 0;\n}\n\nAnswer: The output of the program will be:\nSum: 15\nDifference: 5\nProduct: 50\nQuotient: 2\n\n\n\n5.3. Integer vs. Floating-Point Division\nQuestion: Write a program that demonstrates the difference between integer division and floating-point division using the numbers 7 and 2.\n\n\nClick to see the solution\n\n\nDeclare integer variables for the first case and perform the division. The result will be truncated.\nDeclare floating-point variables (using the float type) for the second case. To ensure floating-point division, at least one of the operands must be a float. We initialize the variables as 7.0f and 2.0f.\nPrint both results using the appropriate format specifiers (%d for integer, %f for float).\n#include &lt;stdio.h&gt;\n\nint main() {\n    // Integer division\n    int int_a = 7;\n    int int_b = 2;\n    int int_result = int_a / int_b;\n    printf(\"Integer Division (7 / 2): %d\\n\", int_result);\n\n    // Floating-point division\n    float float_a = 7.0f;\n    float float_b = 2.0f;\n    float float_result = float_a / float_b;\n    printf(\"Floating-Point Division (7.0 / 2.0): %f\\n\", float_result);\n\n    return 0;\n}\n\nAnswer: The program’s output highlights the difference clearly:\nInteger Division (7 / 2): 3\nFloating-Point Division (7.0 / 2.0): 3.500000\n\n\n\n5.4. Understanding Scope and Variable Shadowing\nQuestion: Analyze the following C code and predict its output. Explain why the output is what it is.\n#include &lt;stdio.h&gt;\n\nint main() {\n    int x = 10; // Outer x\n\n    printf(\"1. Outer x: %d\\n\", x);\n\n    { // Start of inner block\n        int x = 20; // Inner x, shadows the outer one\n        printf(\"2. Inner x: %d\\n\", x);\n    } // End of inner block\n\n    printf(\"3. Outer x again: %d\\n\", x);\n\n    return 0;\n}\n\n\nClick to see the solution\n\n\nFirst printf: The code is in the outer block of main. It accesses the x declared in this block, which has a value of 10.\nSecond printf: This statement is inside an inner block. A new variable, also named x, is declared and initialized to 20. This inner x shadows (hides) the outer x. Therefore, printf accesses the inner x, printing 20.\nEnd of Inner Block: When the inner block ends (at the }), its local variables (the inner x) are destroyed.\nThird printf: The code is now back in the outer block. The inner x no longer exists. The x being accessed is the original outer variable, which still has its value of 10.\n\nAnswer: The output of the program will be:\n1. Outer x: 10\n2. Inner x: 20\n3. Outer x again: 10\n\n\n\n5.5. A Simple if-else Conditional Program\nQuestion: Write a C program that prompts the user to enter an integer and then prints whether the number is positive, negative, or zero.\n\n\nClick to see the solution\n\n\nInclude stdio.h for printf and scanf.\nDeclare an integer variable to store the user’s input.\nUse printf to display a prompt message to the user.\nUse scanf to read an integer from the user’s input and store it in the variable. The & symbol is crucial; it passes the memory address of the variable so scanf knows where to store the value.\nUse an if-else if-else chain to check the value of the number and print the appropriate message.\n#include &lt;stdio.h&gt;\n\nint main() {\n    int number;\n\n    printf(\"Enter an integer: \");\n    scanf(\"%d\", &number);\n\n    if (number &gt; 0) {\n        printf(\"The number is positive.\\n\");\n    } else if (number &lt; 0) {\n        printf(\"The number is negative.\\n\");\n    } else {\n        printf(\"The number is zero.\\n\");\n    }\n\n    return 0;\n}\n\nAnswer: The output depends on the user’s input. For example, if the user enters -5, the output will be:\nEnter an integer: -5\nThe number is negative.\n\n\n\n5.6. Using the static Keyword in a Function\nQuestion: Write a function that counts how many times it has been called. Use a static local variable to achieve this. Then, call this function multiple times from main to demonstrate that it works.\n\n\nClick to see the solution\n\n\nDefine a function call_counter that takes no arguments and returns void.\nInside call_counter, declare an integer count with the static keyword and initialize it to 0. Because it is static, it will be initialized only once when the program starts, not every time the function is called.\nIncrement count and print its current value.\nIn the main function, use a loop to call call_counter several times (e.g., 5 times).\n#include &lt;stdio.h&gt;\n\nvoid call_counter() {\n    static int count = 0; // Initialized only once\n    count++;\n    printf(\"This function has been called %d time(s).\\n\", count);\n}\n\nint main() {\n    call_counter();\n    call_counter();\n    call_counter();\n    call_counter();\n    call_counter();\n\n    return 0;\n}\n\nAnswer: The program’s output demonstrates that the count variable retains its value between function calls:\nThis function has been called 1 time(s).\nThis function has been called 2 time(s).\nThis function has been called 3 time(s).\nThis function has been called 4 time(s).\nThis function has been called 5 time(s).\n\n\n\n5.7. A Simple while Loop\nQuestion: Write a program that uses a while loop to print the numbers from 1 to 5, each on a new line.\n\n\nClick to see the solution\n\n\nInclude stdio.h.\nIn main, declare an integer variable to act as a counter, and initialize it to 1. Let’s call it i.\nSet up the while loop with the condition i &lt;= 5. The loop will continue to execute as long as this condition is true.\nInside the loop, print the current value of i.\nCrucially, increment i inside the loop (i++). If you forget this step, the loop will run forever because the condition i &lt;= 5 will always be true (an infinite loop).\n#include &lt;stdio.h&gt;\n\nint main() {\n    int i = 1; // Initialize the counter\n\n    while (i &lt;= 5) { // Loop condition\n        printf(\"%d\\n\", i);\n        i++; // Increment the counter\n    }\n\n    return 0;\n}\n\nAnswer: The program will produce the following output:\n1\n2\n3\n4\n5",
    "crumbs": [
      "Introduction to Programming",
      "1. Introduction to C, Compilers, and Program Structure"
    ]
  },
  {
    "objectID": "Analytical Geometry and Linear Algebra I /lec_2.html",
    "href": "Analytical Geometry and Linear Algebra I /lec_2.html",
    "title": "2. Dot Product, Vector Projection, Orthogonality",
    "section": "",
    "text": "1. Summary\n\n1.1 The Inner Product\nAn inner product is a generalized concept that defines a way to multiply two vectors to get a scalar (a single number). The standard dot product is the most common example of an inner product. For a function to be considered an inner product, it must satisfy four key properties for any vectors \\(\\vec{u}\\), \\(\\vec{v}\\), \\(\\vec{w}\\) and any scalar \\(c\\):\n\nSymmetry: The order of vectors doesn’t matter. \\(\\langle \\vec{u}, \\vec{v} \\rangle = \\langle \\vec{v}, \\vec{u} \\rangle\\).\nLinearity: A scalar multiple can be factored out. \\(\\langle c\\vec{u}, \\vec{v} \\rangle = c\\langle \\vec{u}, \\vec{v} \\rangle\\).\nAdditivity: The product distributes over vector addition. \\(\\langle \\vec{u} + \\vec{w}, \\vec{v} \\rangle = \\langle \\vec{u}, \\vec{v} \\rangle + \\langle \\vec{w}, \\vec{v} \\rangle\\).\nPositive Definiteness: The inner product of a vector with itself is always non-negative, and it is zero if and only if the vector is the zero vector. \\(\\langle \\vec{v}, \\vec{v} \\rangle \\ge 0\\) and \\(\\langle \\vec{v}, \\vec{v} \\rangle = 0 \\iff \\vec{v} = \\vec{0}\\).\n\n\n\n1.2 The Dot Product\nThe dot product (also known as the Euclidean inner product) is the standard way to combine two vectors to produce a scalar. It has two primary definitions: an algebraic one and a geometric one. Both yield the same result.\n\n\n1.3 Algebraic Definition of the Dot Product\nThe algebraic definition is calculated by multiplying the corresponding components of two vectors and summing the results. For two vectors \\(\\vec{u} = (u_1, u_2, \\dots, u_n)\\) and \\(\\vec{v} = (v_1, v_2, \\dots, v_n)\\) in \\(\\mathbb{R}^n\\), the dot product is: \\[ \\vec{u} \\cdot \\vec{v} = u_1v_1 + u_2v_2 + \\dots + u_nv_n = \\sum_{i=1}^{n} u_i v_i \\] For example, in 3D space, if \\(\\vec{a} = (a_1, a_2, a_3)\\) and \\(\\vec{b} = (b_1, b_2, b_3)\\), then \\(\\vec{a} \\cdot \\vec{b} = a_1b_1 + a_2b_2 + a_3b_3\\).\n\n\n1.4 Geometric Definition of the Dot Product\nThe geometric definition relates the dot product to the magnitudes (lengths) of the vectors and the angle between them. For two vectors \\(\\vec{v}\\) and \\(\\vec{w}\\), with an angle \\(\\theta\\) between them: \\[ \\vec{v} \\cdot \\vec{w} = ||\\vec{v}|| \\cdot ||\\vec{w}|| \\cos(\\theta) \\] Here, \\(||\\vec{v}||\\) denotes the magnitude of vector \\(\\vec{v}\\). This definition is powerful because it connects a simple algebraic operation to a fundamental geometric property (the angle). \nThe sign of the dot product tells us about the angle \\(\\theta\\):\n\nIf \\(\\vec{v} \\cdot \\vec{w} &gt; 0\\), then \\(\\cos(\\theta) &gt; 0\\), so the angle is acute (\\(0^\\circ \\le \\theta &lt; 90^\\circ\\)).\nIf \\(\\vec{v} \\cdot \\vec{w} &lt; 0\\), then \\(\\cos(\\theta) &lt; 0\\), so the angle is obtuse (\\(90^\\circ &lt; \\theta \\le 180^\\circ\\)).\nIf \\(\\vec{v} \\cdot \\vec{w} = 0\\), then \\(\\cos(\\theta) = 0\\), so the angle is right (\\(\\theta = 90^\\circ\\)).\n\n\n\n1.5 Orthogonality\nTwo non-zero vectors are orthogonal (perpendicular) if and only if their dot product is zero. This follows directly from the geometric definition: if \\(\\theta = 90^\\circ\\), then \\(\\cos(90^\\circ) = 0\\), making the dot product zero, regardless of the vectors’ magnitudes. \\[ \\vec{v} \\perp \\vec{w} \\iff \\vec{v} \\cdot \\vec{w} = 0 \\]\n\n\n1.6 Vector Norm (Length)\nThe dot product provides a natural way to define the norm, or length, of a vector. The norm of a vector \\(\\vec{v}\\) is the square root of the dot product of the vector with itself. \\[ ||\\vec{v}|| = \\sqrt{\\vec{v} \\cdot \\vec{v}} \\] From the algebraic definition, for \\(\\vec{v} = (v_1, v_2, v_3)\\), this is the familiar distance formula: \\(||\\vec{v}|| = \\sqrt{v_1^2 + v_2^2 + v_3^2}\\).\n\n\n1.7 Projections\nProjections describe the “shadow” that one vector casts onto another.\n\n1.7.1 Scalar Projection\nThe scalar projection of vector \\(\\vec{v}\\) onto vector \\(\\vec{w}\\) is the signed length of the component of \\(\\vec{v}\\) that lies in the direction of \\(\\vec{w}\\). \\[ \\text{comp}_{\\vec{w}}(\\vec{v}) = \\frac{\\vec{v} \\cdot \\vec{w}}{||\\vec{w}||} \\] This value is a scalar. It is positive if the projection points in the same direction as \\(\\vec{w}\\) and negative if it points in the opposite direction.\n\n\n1.7.2 Vector Projection\nThe vector projection is the actual vector that represents the shadow. It has the magnitude of the scalar projection and the direction of \\(\\vec{w}\\).  \\[ \\text{proj}_{\\vec{w}}(\\vec{v}) = \\left( \\frac{\\vec{v} \\cdot \\vec{w}}{||\\vec{w}||^2} \\right) \\vec{w} \\] Notice the denominator is \\(||\\vec{w}||^2\\), which is equivalent to \\(\\vec{w} \\cdot \\vec{w}\\). The term in parentheses is a scalar that scales the vector \\(\\vec{w}\\).\n\n\n\n1.8 Decomposing a Vector\nAny vector \\(\\vec{v}\\) can be decomposed into two orthogonal components relative to another vector \\(\\vec{w}\\): 1. A component parallel to \\(\\vec{w}\\): \\(\\vec{v}_{||} = \\text{proj}_{\\vec{w}}(\\vec{v})\\). 2. A component orthogonal to \\(\\vec{w}\\): \\(\\vec{v}_{\\perp} = \\vec{v} - \\vec{v}_{||}\\).\n\n\n1.9 Direction Cosines\nFor a vector \\(\\vec{a} = (a_1, a_2, a_3)\\) in 3D space, the angles it forms with the positive x, y, and z axes are denoted \\(\\alpha\\), \\(\\beta\\), and \\(\\gamma\\), respectively. The cosines of these angles are called direction cosines and can be found using the dot product: * \\(\\cos(\\alpha) = \\frac{\\vec{a} \\cdot \\vec{i}}{||\\vec{a}||} = \\frac{a_1}{||\\vec{a}||}\\) * \\(\\cos(\\beta) = \\frac{\\vec{a} \\cdot \\vec{j}}{||\\vec{a}||} = \\frac{a_2}{||\\vec{a}||}\\) * \\(\\cos(\\gamma) = \\frac{\\vec{a} \\cdot \\vec{k}}{||\\vec{a}||} = \\frac{a_3}{||\\vec{a}||}\\) These cosines are related by the identity: \\[ \\cos^2(\\alpha) + \\cos^2(\\beta) + \\cos^2(\\gamma) = 1 \\]\n\n\n\n2. Definitions\n\nInner Product: A function that takes two vectors and produces a scalar, satisfying the properties of symmetry, linearity, additivity, and positive definiteness.\nDot Product: The most common type of inner product, calculated as the sum of the products of corresponding vector components (\\(\\sum u_i v_i\\)).\nOrthogonal Vectors: Two vectors whose dot product is zero, indicating they are perpendicular to each other.\nNorm (Vector Length): The magnitude of a vector, calculated as the square root of the dot product of the vector with itself (\\(||\\vec{v}|| = \\sqrt{\\vec{v} \\cdot \\vec{v}}\\)).\nScalar Projection: The signed length of the projection of one vector onto another, resulting in a scalar value.\nVector Projection: The vector that represents the “shadow” of one vector onto another. It is parallel to the vector being projected upon.\n\n\n\n3. Formulas\n\nAlgebraic Dot Product: \\(\\vec{u} \\cdot \\vec{v} = \\sum_{i=1}^{n} u_i v_i\\)\nGeometric Dot Product: \\(\\vec{v} \\cdot \\vec{w} = ||\\vec{v}|| \\cdot ||\\vec{w}|| \\cos(\\theta)\\)\nAngle Between Vectors: \\(\\theta = \\arccos\\left(\\frac{\\vec{v} \\cdot \\vec{w}}{||\\vec{v}|| \\cdot ||\\vec{w}||}\\right)\\)\nVector Norm: \\(||\\vec{v}|| = \\sqrt{\\vec{v} \\cdot \\vec{v}}\\)\nScalar Projection: \\(\\text{comp}_{\\vec{w}}(\\vec{v}) = \\frac{\\vec{v} \\cdot \\vec{w}}{||\\vec{w}||}\\)\nVector Projection: \\(\\text{proj}_{\\vec{w}}(\\vec{v}) = \\left(\\frac{\\vec{v} \\cdot \\vec{w}}{\\vec{w} \\cdot \\vec{w}}\\right) \\vec{w}\\)\nDirection Cosines Identity: \\(\\cos^2(\\alpha) + \\cos^2(\\beta) + \\cos^2(\\gamma) = 1\\)\n\n\n\n4. Mistakes\n\nDot product gives a vector: The result of a dot product is always a scalar (a single number), not another vector. Why it’s wrong: The operation is defined as a sum of products, which always resolves to a single numerical value.\nAssuming \\(\\vec{a} \\cdot \\vec{b} = \\vec{a} \\cdot \\vec{c}\\) implies \\(\\vec{b} = \\vec{c}\\): This is not true. Why it’s wrong: The dot product involves the angle between vectors. For example, if \\(\\vec{a} = (1, 0)\\), \\(\\vec{b} = (0, 5)\\), and \\(\\vec{c} = (0, 10)\\), then \\(\\vec{a} \\cdot \\vec{b} = 0\\) and \\(\\vec{a} \\cdot \\vec{c} = 0\\), but \\(\\vec{b} \\ne \\vec{c}\\).\nConfusing vector projection with scalar projection: One is a vector, the other is a scalar (a length). Why it’s wrong: The formulas are distinct. The vector projection formula includes multiplying by the direction vector \\(\\vec{w}\\) at the end, while the scalar projection formula does not.\nUsing \\(||\\vec{w}||\\) in the denominator for vector projection: The denominator in the vector projection formula is \\(||\\vec{w}||^2\\) (or \\(\\vec{w} \\cdot \\vec{w}\\)). Why it’s wrong: The term \\(\\frac{\\vec{v} \\cdot \\vec{w}}{||\\vec{w}||^2}\\) is the scalar needed to correctly scale the direction vector \\(\\vec{w}\\) to get the projected vector. Using just \\(||\\vec{w}||\\) would be dimensionally incorrect and produce the wrong magnitude.\nForgetting the square root when calculating the norm: The norm is \\(||\\vec{v}|| = \\sqrt{\\vec{v} \\cdot \\vec{v}}\\), not just \\(\\vec{v} \\cdot \\vec{v}\\). Why it’s wrong: \\(\\vec{v} \\cdot \\vec{v}\\) gives the squared length. To find the actual length, you must take the square root, consistent with the Pythagorean theorem.\n\n\n\n5. Examples\n\n5.1. Calculate a Dot Product\nQuestion: Calculate the dot product of vectors \\(\\vec{u} = (1, -2, 4)\\) and \\(\\vec{v} = (3, 0, -5)\\).\n\n\nClick to see the solution\n\n\nIdentify corresponding components: The components are \\((u_1, u_2, u_3) = (1, -2, 4)\\) and \\((v_1, v_2, v_3) = (3, 0, -5)\\).\nApply the algebraic formula: Multiply each pair of corresponding components. \\[ \\vec{u} \\cdot \\vec{v} = (1)(3) + (-2)(0) + (4)(-5) \\]\nSum the products: \\[ \\vec{u} \\cdot \\vec{v} = 3 + 0 - 20 = -17 \\]\n\nAnswer: The dot product is -17.\n\n\n\n5.2. Find the Angle Between Two Vectors\nQuestion: Find the angle \\(\\theta\\) between vectors \\(\\vec{a} = (3, -1)\\) and \\(\\vec{b} = (2, 4)\\).\n\n\nClick to see the solution\n\n\nCalculate the dot product \\(\\vec{a} \\cdot \\vec{b}\\): \\[ \\vec{a} \\cdot \\vec{b} = (3)(2) + (-1)(4) = 6 - 4 = 2 \\]\nCalculate the magnitude of \\(\\vec{a}\\): \\[ ||\\vec{a}|| = \\sqrt{3^2 + (-1)^2} = \\sqrt{9 + 1} = \\sqrt{10} \\]\nCalculate the magnitude of \\(\\vec{b}\\): \\[ ||\\vec{b}|| = \\sqrt{2^2 + 4^2} = \\sqrt{4 + 16} = \\sqrt{20} \\]\nUse the angle formula: \\[ \\cos(\\theta) = \\frac{\\vec{a} \\cdot \\vec{b}}{||\\vec{a}|| \\cdot ||\\vec{b}||} = \\frac{2}{\\sqrt{10} \\sqrt{20}} = \\frac{2}{\\sqrt{200}} = \\frac{2}{10\\sqrt{2}} = \\frac{1}{5\\sqrt{2}} \\]\nSolve for \\(\\theta\\): \\[ \\theta = \\arccos\\left(\\frac{1}{5\\sqrt{2}}\\right) \\approx 81.87^\\circ \\]\n\nAnswer: The angle is approximately \\(81.87^\\circ\\).\n\n\n\n5.3. Check for Orthogonality\nQuestion: Determine if the vectors \\(\\vec{u} = (2, -3)\\) and \\(\\vec{b} = (3, 2)\\) are orthogonal.\n\n\nClick to see the solution\n\n\nCalculate the dot product of the vectors: \\[ \\vec{u} \\cdot \\vec{b} = (2)(3) + (-3)(2) \\]\nSimplify the expression: \\[ 6 - 6 = 0 \\]\nCheck the result: Since the dot product is 0, the vectors are orthogonal.\n\nAnswer: Yes, the vectors are orthogonal.\n\n\n\n5.4. Find an Unknown Component\nQuestion: Find the value of \\(x\\) such that the vectors \\(\\vec{u} = (x, -1, 3)\\) and \\(\\vec{v} = (x, 5, 1)\\) are orthogonal.\n\n\nClick to see the solution\n\n\nSet the dot product to zero: For the vectors to be orthogonal, their dot product must be zero. \\[ \\vec{u} \\cdot \\vec{v} = (x)(x) + (-1)(5) + (3)(1) = 0 \\]\nSimplify the equation: \\[ x^2 - 5 + 3 = 0 \\] \\[ x^2 - 2 = 0 \\]\nSolve for \\(x\\): \\[ x^2 = 2 \\] \\[ x = \\pm\\sqrt{2} \\]\n\nAnswer: The values for \\(x\\) are \\(\\sqrt{2}\\) and \\(-\\sqrt{2}\\).\n\n\n\n5.5. Calculate Scalar Projection\nQuestion: Find the scalar projection of \\(\\vec{a} = (1, -2, 4)\\) onto \\(\\vec{b} = (2, 1, -2)\\).\n\n\nClick to see the solution\n\n\nCalculate the dot product \\(\\vec{a} \\cdot \\vec{b}\\): \\[ \\vec{a} \\cdot \\vec{b} = (1)(2) + (-2)(1) + (4)(-2) = 2 - 2 - 8 = -8 \\]\nCalculate the magnitude of \\(\\vec{b}\\): \\[ ||\\vec{b}|| = \\sqrt{2^2 + 1^2 + (-2)^2} = \\sqrt{4 + 1 + 4} = \\sqrt{9} = 3 \\]\nApply the scalar projection formula: \\[ \\text{comp}_{\\vec{b}}(\\vec{a}) = \\frac{\\vec{a} \\cdot \\vec{b}}{||\\vec{b}||} = \\frac{-8}{3} \\]\n\nAnswer: The scalar projection is \\(-\\frac{8}{3}\\).\n\n\n\n5.6. Calculate Vector Projection\nQuestion: Find the vector projection of \\(\\vec{a} = (4, 3)\\) onto \\(\\vec{b} = (2, 2)\\).\n\n\nClick to see the solution\n\n\\begin{tikzpicture}\n    % Axis\n    \\draw[-&gt;] (-1,0) -- (5,0) node[below] {$x$};\n    \\draw[-&gt;] (0,-1) -- (0,5) node[left] {$y$};\n    \n    % Vectors\n    \\draw[-&gt;, thick, blue] (0,0) -- (4,3) node[anchor=south west] {$\\vec{a} = (4,3)$};\n    \\draw[-&gt;, thick, red] (0,0) -- (2,2) node[anchor=north west] {$\\vec{b} = (2,2)$};\n    \n    % Projection\n    \\draw[dashed] (4,3) -- (3.5,3.5);\n    \\draw[-&gt;, thick, green] (0,0) -- (3.5,3.5) node[anchor=north] {proj$_{\\vec{b}}(\\vec{a})$};\n\\end{tikzpicture}\n\nCalculate the dot product \\(\\vec{a} \\cdot \\vec{b}\\): \\[ \\vec{a} \\cdot \\vec{b} = (4)(2) + (3)(2) = 8 + 6 = 14 \\]\nCalculate the dot product \\(\\vec{b} \\cdot \\vec{b}\\) (which is \\(||\\vec{b}||^2\\)): \\[ \\vec{b} \\cdot \\vec{b} = (2)(2) + (2)(2) = 4 + 4 = 8 \\]\nApply the vector projection formula: \\[ \\text{proj}_{\\vec{b}}(\\vec{a}) = \\left(\\frac{\\vec{a} \\cdot \\vec{b}}{\\vec{b} \\cdot \\vec{b}}\\right) \\vec{b} = \\left(\\frac{14}{8}\\right) (2, 2) \\]\nSimplify the expression: \\[ \\frac{7}{4} (2, 2) = \\left(\\frac{14}{4}, \\frac{14}{4}\\right) = \\left(\\frac{7}{2}, \\frac{7}{2}\\right) \\]\n\nAnswer: The vector projection is \\((\\frac{7}{2}, \\frac{7}{2})\\).\n\n\n\n5.7. Decompose a Vector\nQuestion: Decompose the vector \\(\\vec{a} = (5, 1, -3)\\) into two vectors, one parallel (\\(\\vec{a}_{||}\\)) and one orthogonal (\\(\\vec{a}_{\\perp}\\)) to \\(\\vec{b} = (1, 2, 2)\\).\n\n\nClick to see the solution\n\n\nFind the parallel component by calculating the vector projection: The parallel component is the projection of \\(\\vec{a}\\) onto \\(\\vec{b}\\). \\[ \\vec{a} \\cdot \\vec{b} = (5)(1) + (1)(2) + (-3)(2) = 5 + 2 - 6 = 1 \\] \\[ \\vec{b} \\cdot \\vec{b} = 1^2 + 2^2 + 2^2 = 1 + 4 + 4 = 9 \\] \\[ \\vec{a}_{||} = \\text{proj}_{\\vec{b}}(\\vec{a}) = \\left(\\frac{1}{9}\\right) (1, 2, 2) = \\left(\\frac{1}{9}, \\frac{2}{9}, \\frac{2}{9}\\right) \\]\nFind the orthogonal component by subtraction: The orthogonal component is the original vector minus the parallel component. \\[ \\vec{a}_{\\perp} = \\vec{a} - \\vec{a}_{||} = (5, 1, -3) - \\left(\\frac{1}{9}, \\frac{2}{9}, \\frac{2}{9}\\right) \\]\nPerform the subtraction: \\[ \\vec{a}_{\\perp} = \\left(5 - \\frac{1}{9}, 1 - \\frac{2}{9}, -3 - \\frac{2}{9}\\right) = \\left(\\frac{45-1}{9}, \\frac{9-2}{9}, \\frac{-27-2}{9}\\right) = \\left(\\frac{44}{9}, \\frac{7}{9}, -\\frac{29}{9}\\right) \\]\n\nAnswer: The parallel component is \\(\\vec{a}_{||} = (\\frac{1}{9}, \\frac{2}{9}, \\frac{2}{9})\\) and the orthogonal component is \\(\\vec{a}_{\\perp} = (\\frac{44}{9}, \\frac{7}{9}, -\\frac{29}{9})\\).",
    "crumbs": [
      "Analytical Geometry and Linear Algebra I ",
      "2. Dot Product, Vector Projection, Orthogonality"
    ]
  },
  {
    "objectID": "Analytical Geometry and Linear Algebra I /lec_1.html",
    "href": "Analytical Geometry and Linear Algebra I /lec_1.html",
    "title": "1. Vectors, Vector Spaces, Linear Independence, Basis, and Dimension",
    "section": "",
    "text": "1. Summary\n\n1.1 Introduction to Vectors\nA vector is a fundamental mathematical object that possesses both magnitude (or length) and direction. It’s distinct from a scalar, which is a simple numerical value (like temperature or speed) that has magnitude but no direction.\nVectors can be represented in two primary ways:\n\nGeometrically: As a directed line segment, or an arrow, in space. The arrow’s length represents the magnitude, and the direction it points represents its direction. A key property is that a vector is independent of its starting position; two arrows with the same length and direction represent the same vector, regardless of where they are in space.\nAlgebraically: As an ordered list of numbers, called components. For instance, in a 2D plane, a vector is represented by two components \\((x, y)\\), and in 3D space, by three components \\((x, y, z)\\). These components correspond to the vector’s projection onto the coordinate axes. By convention, vectors are often written as columns: \\[ \\vec{v} = \\begin{pmatrix} x \\\\ y \\end{pmatrix} \\]\n\n\n\n\n1.2 Basic Vector Operations\nStandard arithmetic operations are defined for vectors, allowing them to be manipulated algebraically.\n\n1.2.1 Vector Addition: To add two vectors, you add their corresponding components. Geometrically, this is represented by the “tip-to-tail” method: place the tail of the second vector at the tip of the first. The resulting vector (the sum) goes from the tail of the first vector to the tip of the second. \\[ \\vec{u} + \\vec{v} = \\begin{pmatrix} u_1 \\\\ u_2 \\end{pmatrix} + \\begin{pmatrix} v_1 \\\\ v_2 \\end{pmatrix} = \\begin{pmatrix} u_1 + v_1 \\\\ u_2 + v_2 \\end{pmatrix} \\] \n1.2.2 Scalar Multiplication: To multiply a vector by a scalar, you multiply each of its components by that scalar. This operation scales the vector, changing its magnitude. If the scalar is positive, the direction remains the same. If negative, the direction is reversed. \\[ c\\vec{v} = c\\begin{pmatrix} v_1 \\\\ v_2 \\end{pmatrix} = \\begin{pmatrix} cv_1 \\\\ cv_2 \\end{pmatrix} \\]\n1.2.3 Vector Subtraction: Subtraction is defined as adding the negative of a vector. That is, \\(\\vec{u} - \\vec{v}\\) is the same as \\(\\vec{u} + (-1)\\vec{v}\\). \\[ \\vec{u} - \\vec{v} = \\begin{pmatrix} u_1 \\\\ u_2 \\end{pmatrix} - \\begin{pmatrix} v_1 \\\\ v_2 \\end{pmatrix} = \\begin{pmatrix} u_1 - v_1 \\\\ u_2 - v_2 \\end{pmatrix} \\]\n\n\n\n1.3 Vector Magnitude and Normalization\n\n1.3.1 Norm of a Vector: The norm (or magnitude/length) of a vector is a non-negative scalar value representing its length. It is calculated using the Pythagorean theorem on its components. The norm of a vector \\(\\vec{v}\\) is denoted as \\(||\\vec{v}||\\). \\[ ||\\vec{v}|| = \\sqrt{v_1^2 + v_2^2 + \\dots + v_n^2} \\]\n1.3.2 Unit Vectors: A unit vector is any vector with a norm of 1. It is useful for representing direction without magnitude. To normalize a non-zero vector (i.e., to find the unit vector in its direction), you divide the vector by its own norm. \\[ \\hat{u} = \\frac{\\vec{v}}{||\\vec{v}||} \\]\n1.3.3 Distance Between Points: The straight-line distance between two points, say \\(P\\) and \\(Q\\), can be found by first calculating the vector \\(\\vec{PQ}\\) that connects them (\\(\\vec{PQ} = Q - P\\)) and then finding the norm of that vector. \\[ d(P, Q) = ||\\vec{PQ}|| = ||Q - P|| = \\sqrt{(q_1-p_1)^2 + (q_2-p_2)^2 + \\dots} \\]\n\n\n\n1.4 Vector Spaces and Subspaces\n\n1.4.1 Vector Space: A vector space is a collection of objects (called vectors) for which the operations of vector addition and scalar multiplication are defined and satisfy a set of ten rules, known as axioms. These axioms ensure that vectors behave consistently and predictably. Key axioms include closure (adding two vectors or multiplying by a scalar results in a vector still within the space), the existence of a zero vector, and the existence of an additive inverse for every vector. The set of all 2D vectors, denoted \\(\\mathbb{R}^2\\), is a common example of a vector space.\n1.4.2 Subspace: A subspace is a subset of a larger vector space that is itself a vector space. To verify if a subset is a subspace, a simplified test called the Subspace Test is used. A subset \\(H\\) is a subspace if it meets three conditions:\n\nIt contains the zero vector.\nIt is closed under addition (if \\(\\vec{u}\\) and \\(\\vec{v}\\) are in \\(H\\), then \\(\\vec{u} + \\vec{v}\\) must also be in \\(H\\)).\nIt is closed under scalar multiplication (if \\(\\vec{u}\\) is in \\(H\\) and \\(c\\) is any scalar, then \\(c\\vec{u}\\) must also be in \\(H\\)). For example, any line or plane passing through the origin in \\(\\mathbb{R}^3\\) is a subspace of \\(\\mathbb{R}^3\\).\n\n\n\n\n1.5 Linear Combinations, Span, and Basis\n\n1.5.1 Linear Combination and Span: A linear combination is a new vector formed by adding together scalar multiples of other vectors. For example, \\(\\vec{w} = c_1\\vec{v}_1 + c_2\\vec{v}_2\\) is a linear combination of \\(\\vec{v}_1\\) and \\(\\vec{v}_2\\). The span of a set of vectors is the set of all possible linear combinations that can be formed from them. The span of a set of vectors always forms a vector space (or a subspace). \n1.5.2 Linear Independence: A set of vectors is linearly independent if no vector in the set can be written as a linear combination of the others. This means that none of the vectors are redundant; each one contributes a unique direction. The only way to form the zero vector from a linear combination of linearly independent vectors is if all the scalar coefficients are zero.\n1.5.3 Linear Dependence: A set of vectors is linearly dependent if at least one vector can be expressed as a linear combination of the others. This indicates redundancy in the set.\n1.5.4 Basis and Dimension: A basis of a vector space is a set of vectors that is both linearly independent and spans the entire space. A basis provides a minimal set of “building blocks” for the space. While a vector space can have many different bases, the number of vectors in every basis for that space is always the same. This unique number is called the dimension of the vector space. For example, the dimension of \\(\\mathbb{R}^3\\) is 3, because a standard basis for it is the set of three vectors: \\(\\{(1,0,0), (0,1,0), (0,0,1)\\}\\).\n\n\n\n\n2. Definitions\n\nVector: A mathematical object that has both magnitude (length) and direction.\nScalar: A quantity that is fully described by a magnitude alone (a single number).\nNorm: The length or magnitude of a vector, denoted by \\(||\\vec{v}||\\).\nUnit Vector: A vector with a norm of 1, often used to represent direction.\nVector Space: A collection of vectors and a field of scalars that satisfy a set of ten axioms, defining a consistent system for vector addition and scalar multiplication.\nSubspace: A subset of a vector space that is itself a vector space under the same operations.\nLinear Combination: A sum of vectors, each multiplied by a scalar coefficient.\nSpan: The set of all possible linear combinations of a given set of vectors. The span of a set of vectors is always a subspace.\nLinearly Independent: A set of vectors where no vector can be written as a linear combination of the others.\nLinearly Dependent: A set of vectors where at least one vector can be written as a linear combination of the others.\nBasis: A set of vectors that is both linearly independent and spans the vector space. It is a minimal generating set for the space.\nDimension: The number of vectors in any basis for a vector space.\n\n\n\n3. Formulas\n\nVector Addition: \\(\\vec{u} + \\vec{v} = \\begin{pmatrix} u_1 + v_1 \\\\ u_2 + v_2 \\end{pmatrix}\\)\nScalar Multiplication: \\(c\\vec{v} = \\begin{pmatrix} cv_1 \\\\ cv_2 \\end{pmatrix}\\)\nVector Subtraction: \\(\\vec{u} - \\vec{v} = \\begin{pmatrix} u_1 - v_1 \\\\ u_2 - v_2 \\end{pmatrix}\\)\nNorm of a Vector in \\(\\mathbb{R}^n\\): \\(||\\vec{v}|| = \\sqrt{v_1^2 + v_2^2 + \\dots + v_n^2}\\)\nDistance between Points P and Q: \\(d(P, Q) = ||Q - P||\\)\nNormalization (Unit Vector): \\(\\hat{u} = \\frac{\\vec{v}}{||\\vec{v}||}\\)\nProjection of vector \\(\\vec{a}\\) onto vector \\(\\vec{b}\\): \\(\\text{proj}_{\\vec{b}}\\vec{a} = \\frac{\\vec{a} \\cdot \\vec{b}}{||\\vec{b}||^2} \\vec{b}\\)\nReflection of vector \\(\\vec{a}\\) over a line defined by vector \\(\\vec{b}\\): \\(\\text{ref}_{\\vec{b}}\\vec{a} = 2 \\cdot \\text{proj}_{\\vec{b}}\\vec{a} - \\vec{a}\\)\n\n\n\n4. Mistakes\n\nAdding a scalar and a vector: An operation like \\(5 + \\begin{pmatrix} 2 \\\\ 3 \\end{pmatrix}\\) is undefined. Why it’s wrong: Scalars and vectors are fundamentally different types of mathematical objects and cannot be directly added. You can only perform scalar multiplication.\nAssuming any set of n vectors in \\(\\mathbb{R}^n\\) is a basis: For example, the set \\(\\{\\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}, \\begin{pmatrix} 2 \\\\ 2 \\end{pmatrix}\\}\\) is not a basis for \\(\\mathbb{R}^2\\). Why it’s wrong: A basis must be linearly independent. In this case, the second vector is just twice the first, so they are linearly dependent and only span a line, not the entire plane.\nConfusing a subspace with any subset: A line in \\(\\mathbb{R}^2\\) that does not pass through the origin is a subset, but not a subspace. Why it’s wrong: A subspace must contain the zero vector and be closed under addition and scalar multiplication. A line not through the origin fails the zero vector test.\nMixing up linear independence and spanning: A set of vectors can be linearly independent but not span the entire space. For example, \\(\\{\\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix}, \\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\end{pmatrix}\\}\\) is a linearly independent set in \\(\\mathbb{R}^3\\), but it only spans the xy-plane, not all of \\(\\mathbb{R}^3\\).\nIncorrectly calculating the dot product: The dot product of two vectors results in a scalar, not another vector. Why it’s wrong: The definition of the dot product is \\(\\vec{u} \\cdot \\vec{v} = u_1v_1 + u_2v_2 + \\dots\\), which is a sum of products, resulting in a single number.\nForgetting to take the square root for the norm: The norm is the length, which is the square root of the sum of squared components. A common mistake is to forget the square root, which calculates the squared norm \\(||\\vec{v}||^2\\).\n\n\n\n5. Examples\n\n5.1. Vector Operations\nQuestion: Given vectors \\(\\vec{a} = \\begin{pmatrix} 2 \\\\ -5 \\end{pmatrix}\\) and \\(\\vec{b} = \\begin{pmatrix} -3 \\\\ 4 \\end{pmatrix}\\), calculate \\(3\\vec{a} - 2\\vec{b}\\).\n\n\nClick to see the solution\n\n\nCalculate the scalar multiple \\(3\\vec{a}\\): \\[ 3\\vec{a} = 3 \\begin{pmatrix} 2 \\\\ -5 \\end{pmatrix} = \\begin{pmatrix} 3 \\cdot 2 \\\\ 3 \\cdot (-5) \\end{pmatrix} = \\begin{pmatrix} 6 \\\\ -15 \\end{pmatrix} \\]\nCalculate the scalar multiple \\(2\\vec{b}\\): \\[ 2\\vec{b} = 2 \\begin{pmatrix} -3 \\\\ 4 \\end{pmatrix} = \\begin{pmatrix} 2 \\cdot (-3) \\\\ 2 \\cdot 4 \\end{pmatrix} = \\begin{pmatrix} -6 \\\\ 8 \\end{pmatrix} \\]\nSubtract the resulting vectors: \\[ 3\\vec{a} - 2\\vec{b} = \\begin{pmatrix} 6 \\\\ -15 \\end{pmatrix} - \\begin{pmatrix} -6 \\\\ 8 \\end{pmatrix} = \\begin{pmatrix} 6 - (-6) \\\\ -15 - 8 \\end{pmatrix} = \\begin{pmatrix} 12 \\\\ -23 \\end{pmatrix} \\]\n\nAnswer: The resulting vector is \\(\\begin{pmatrix} 12 \\\\ -23 \\end{pmatrix}\\).\n\n\n\n5.2. Norm and Distance\nQuestion: Find the distance between point \\(A = (3, -1, 4)\\) and point \\(B = (-1, 1, 2)\\).\n\n\nClick to see the solution\n\n\nFind the vector \\(\\vec{AB}\\) connecting the two points: \\[ \\vec{AB} = B - A = \\begin{pmatrix} -1 - 3 \\\\ 1 - (-1) \\\\ 2 - 4 \\end{pmatrix} = \\begin{pmatrix} -4 \\\\ 2 \\\\ -2 \\end{pmatrix} \\]\nCalculate the norm (magnitude) of the vector \\(\\vec{AB}\\): \\[ ||\\vec{AB}|| = \\sqrt{(-4)^2 + 2^2 + (-2)^2} \\]\nSimplify the expression: \\[ ||\\vec{AB}|| = \\sqrt{16 + 4 + 4} = \\sqrt{24} = 2\\sqrt{6} \\]\n\nAnswer: The distance is \\(2\\sqrt{6}\\).\n\n\n\n5.3. Unit Vector\nQuestion: Find the unit vector in the same direction as \\(\\vec{v} = \\begin{pmatrix} 1 \\\\ -2 \\\\ 3 \\end{pmatrix}\\).\n\n\nClick to see the solution\n\n\nFirst, calculate the norm of \\(\\vec{v}\\): \\[ ||\\vec{v}|| = \\sqrt{1^2 + (-2)^2 + 3^2} = \\sqrt{1 + 4 + 9} = \\sqrt{14} \\]\nDivide the vector \\(\\vec{v}\\) by its norm: \\[ \\hat{v} = \\frac{\\vec{v}}{||\\vec{v}||} = \\frac{1}{\\sqrt{14}} \\begin{pmatrix} 1 \\\\ -2 \\\\ 3 \\end{pmatrix} = \\begin{pmatrix} 1/\\sqrt{14} \\\\ -2/\\sqrt{14} \\\\ 3/\\sqrt{14} \\end{pmatrix} \\]\n\nAnswer: The unit vector is \\(\\begin{pmatrix} 1/\\sqrt{14} \\\\ -2/\\sqrt{14} \\\\ 3/\\sqrt{14} \\end{pmatrix}\\).\n\n\n\n5.4. Linear Independence\nQuestion: Determine if the vectors \\(\\vec{u} = \\begin{pmatrix} 1 \\\\ 2 \\\\ 1 \\end{pmatrix}\\), \\(\\vec{v} = \\begin{pmatrix} 3 \\\\ 1 \\\\ 4 \\end{pmatrix}\\), and \\(\\vec{w} = \\begin{pmatrix} 5 \\\\ 5 \\\\ 6 \\end{pmatrix}\\) are linearly independent.\n\n\nClick to see the solution\n\n\nSet up the equation for linear dependence: We need to check if there are non-zero scalars \\(a, b, c\\) such that \\(a\\vec{u} + b\\vec{v} + c\\vec{w} = \\vec{0}\\). \\[ a\\begin{pmatrix} 1 \\\\ 2 \\\\ 1 \\end{pmatrix} + b\\begin{pmatrix} 3 \\\\ 1 \\\\ 4 \\end{pmatrix} + c\\begin{pmatrix} 5 \\\\ 5 \\\\ 6 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\end{pmatrix} \\]\nWrite this as a system of linear equations: \\[ \\begin{cases} 1a + 3b + 5c = 0 \\\\ 2a + 1b + 5c = 0 \\\\ 1a + 4b + 6c = 0 \\end{cases} \\]\nSolve the system. We can use substitution or elimination. Subtracting the first equation from the second gives \\(a - 2b = 0\\), so \\(a = 2b\\). Subtracting the first equation from the third gives \\(b + c = 0\\), so \\(c = -b\\).\nSubstitute back into the first equation: \\[ (2b) + 3b + 5(-b) = 0 \\] \\[ 5b - 5b = 0 \\] \\[ 0 = 0 \\] This identity means there are infinitely many solutions. For example, if we choose \\(b=1\\), then \\(a=2\\) and \\(c=-1\\).\nConclusion: Since we found a non-trivial solution (\\(a=2, b=1, c=-1\\)), the vectors are not linearly independent. Specifically, \\(2\\vec{u} + \\vec{v} - \\vec{w} = \\vec{0}\\).\n\nAnswer: The vectors are linearly dependent.\n\n\n\n5.5. Subspace Test\nQuestion: Is the set \\(S\\) of all vectors in \\(\\mathbb{R}^2\\) of the form \\(\\begin{pmatrix} t \\\\ 2t \\end{pmatrix}\\) a subspace of \\(\\mathbb{R}^2\\)?\n\n\nClick to see the solution\n\n\nCheck for the zero vector: Let \\(t=0\\). The vector is \\(\\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}\\). The zero vector is in \\(S\\). Condition (1) is met.\nCheck for closure under addition: Let \\(\\vec{u} = \\begin{pmatrix} t_1 \\\\ 2t_1 \\end{pmatrix}\\) and \\(\\vec{v} = \\begin{pmatrix} t_2 \\\\ 2t_2 \\end{pmatrix}\\) be two arbitrary vectors in \\(S\\). Their sum is: \\[ \\vec{u} + \\vec{v} = \\begin{pmatrix} t_1 + t_2 \\\\ 2t_1 + 2t_2 \\end{pmatrix} = \\begin{pmatrix} (t_1 + t_2) \\\\ 2(t_1 + t_2) \\end{pmatrix} \\] This resulting vector is of the form \\(\\begin{pmatrix} t' \\\\ 2t' \\end{pmatrix}\\) where \\(t' = t_1 + t_2\\). So, the set is closed under addition. Condition (2) is met.\nCheck for closure under scalar multiplication: Let \\(\\vec{u} = \\begin{pmatrix} t \\\\ 2t \\end{pmatrix}\\) be a vector in \\(S\\) and \\(c\\) be any scalar. \\[ c\\vec{u} = c\\begin{pmatrix} t \\\\ 2t \\end{pmatrix} = \\begin{pmatrix} ct \\\\ c(2t) \\end{pmatrix} = \\begin{pmatrix} (ct) \\\\ 2(ct) \\end{pmatrix} \\] This resulting vector is of the form \\(\\begin{pmatrix} t'' \\\\ 2t'' \\end{pmatrix}\\) where \\(t''=ct\\). So, the set is closed under scalar multiplication. Condition (3) is met.\n\nAnswer: Yes, the set is a subspace because it satisfies all three conditions of the Subspace Test. This corresponds to a line through the origin.\n\n\n\n5.6. Vector Projection\nQuestion: Given \\(\\vec{a} = (2, 2, -1)\\) and \\(\\vec{b} = (0, 4, 3)\\), compute the projection of \\(\\vec{a}\\) onto \\(\\vec{b}\\).\n\n\nClick to see the solution\n\n\nCalculate the dot product \\(\\vec{a} \\cdot \\vec{b}\\): \\[ \\vec{a} \\cdot \\vec{b} = (2)(0) + (2)(4) + (-1)(3) = 0 + 8 - 3 = 5 \\]\nCalculate the squared norm of \\(\\vec{b}\\): \\[ ||\\vec{b}||^2 = 0^2 + 4^2 + 3^2 = 0 + 16 + 9 = 25 \\]\nApply the projection formula: \\[ \\text{proj}_{\\vec{b}}\\vec{a} = \\frac{\\vec{a} \\cdot \\vec{b}}{||\\vec{b}||^2} \\vec{b} = \\frac{5}{25} \\begin{pmatrix} 0 \\\\ 4 \\\\ 3 \\end{pmatrix} \\]\nSimplify the result: \\[ \\text{proj}_{\\vec{b}}\\vec{a} = \\frac{1}{5} \\begin{pmatrix} 0 \\\\ 4 \\\\ 3 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 4/5 \\\\ 3/5 \\end{pmatrix} \\]\n\nAnswer: The projection of \\(\\vec{a}\\) onto \\(\\vec{b}\\) is \\(\\begin{pmatrix} 0 \\\\ 4/5 \\\\ 3/5 \\end{pmatrix}\\).\n\n\n\n5.7. Vector Reflection\nQuestion: Using the vectors from the previous example, compute the reflection of \\(\\vec{a} = (2, 2, -1)\\) over the line defined by vector \\(\\vec{b} = (0, 4, 3)\\).\n\n\nClick to see the solution\n\n\nRecall the projection vector from the previous example: \\[ \\text{proj}_{\\vec{b}}\\vec{a} = \\begin{pmatrix} 0 \\\\ 4/5 \\\\ 3/5 \\end{pmatrix} \\]\nApply the reflection formula: \\(\\text{ref}_{\\vec{b}}\\vec{a} = 2 \\cdot \\text{proj}_{\\vec{b}}\\vec{a} - \\vec{a}\\): \\[ \\text{ref}_{\\vec{b}}\\vec{a} = 2 \\begin{pmatrix} 0 \\\\ 4/5 \\\\ 3/5 \\end{pmatrix} - \\begin{pmatrix} 2 \\\\ 2 \\\\ -1 \\end{pmatrix} \\]\nPerform the scalar multiplication: \\[ = \\begin{pmatrix} 0 \\\\ 8/5 \\\\ 6/5 \\end{pmatrix} - \\begin{pmatrix} 2 \\\\ 2 \\\\ -1 \\end{pmatrix} \\]\nPerform the vector subtraction: \\[ = \\begin{pmatrix} 0 - 2 \\\\ 8/5 - 10/5 \\\\ 6/5 - (-5/5) \\end{pmatrix} = \\begin{pmatrix} -2 \\\\ -2/5 \\\\ 11/5 \\end{pmatrix} \\]\n\nAnswer: The reflection of \\(\\vec{a}\\) over \\(\\vec{b}\\) is \\(\\begin{pmatrix} -2 \\\\ -2/5 \\\\ 11/5 \\end{pmatrix}\\).",
    "crumbs": [
      "Analytical Geometry and Linear Algebra I ",
      "1. Vectors, Vector Spaces, Linear Independence, Basis, and Dimension"
    ]
  },
  {
    "objectID": "Discrete Mathematics/lec_1.html",
    "href": "Discrete Mathematics/lec_1.html",
    "title": "1. Truth Tables, Normal Forms (DNF, CNF)",
    "section": "",
    "text": "1. Summary\n\n1.1 Propositions and Logical Values\nIn logic, a proposition is a statement that can be definitively determined as either True or False, but not both. It is the fundamental building block of logical expressions. For example, “The sky is blue” is a proposition. “What time is it?” is not, because it’s a question and cannot be assigned a truth value. In discrete mathematics and computing, we represent these values numerically:\n\nTrue is represented by 1.\nFalse is represented by 0.\n\n\n\n1.2 Logical Operators\nLogical operators are symbols used to connect propositions and form more complex logical expressions. Each operator has a specific rule for determining the truth value of the expression it forms.\n\n1.2.1 Negation (NOT) The Negation operator, denoted by ¬ (e.g., ¬P), inverts the truth value of a proposition. If P is true, ¬P is false. If P is false, ¬P is true. It corresponds to the word “not”.\n1.2.2 Conjunction (AND) The Conjunction operator, denoted by & or ∧ (e.g., P ∧ Q), connects two propositions. The result is True only if both propositions are true. If either or both are false, the result is false. It corresponds to the word “and”.\n1.2.3 Disjunction (OR) The Disjunction operator, denoted by ∨ (e.g., P ∨ Q), connects two propositions. The result is True if at least one of the propositions is true. It is only false when both propositions are false. This is also known as an inclusive OR.\n1.2.4 Implication (IF…THEN) The Implication operator, denoted by → (e.g., P → Q), represents a conditional statement. It is read as “if P, then Q”. The expression P → Q is only False when P is true and Q is false. In all other cases, it is true. This can seem counter-intuitive. Think of it as a promise: “If I pass the exam (P), then I will celebrate (Q)”. The only way the promise is broken is if I pass the exam but do not celebrate. If I don’t pass the exam, the promise is not broken, regardless of whether I celebrate or not.\n1.2.5 Equivalence (IF AND ONLY IF) The Equivalence operator, denoted by ↔︎ (e.g., P ↔︎ Q), is also known as a biconditional. The result is True only when both propositions have the same truth value (both true or both false).\n\n\n\n1.3 Truth Tables\nA truth table is a tool used to systematically determine the truth value of a complex logical formula for every possible combination of truth values of its component propositions.\n\nConstruction: To build a truth table for a formula with n distinct propositional variables, you need \\(2^n\\) rows to cover all possible scenarios.\nStructure: The initial columns list all combinations of truth values for the variables. Subsequent columns break down the complex formula into smaller parts, building up to the final result in the last column.\n\n\n\n\n1.4 Normal Forms\nA normal form in logic is a standardized way of writing a logical formula. Having a standard representation is useful for comparing formulas, simplifying them, and for automated processing in computer science. The two most common are Disjunctive Normal Form (DNF) and Conjunctive Normal Form (CNF).\n\n1.4.1 Disjunctive Normal Form (DNF) A formula is in Disjunctive Normal Form (DNF) if it is a disjunction (ORs) of conjuncts (ANDs of literals). A literal is a variable or its negation.\n\nStructure: \\((A \\land \\neg B) \\lor (C \\land D) \\lor (\\neg E)\\)\nIntuition: Think of DNF as describing the specific conditions that make the formula True. Each conjunct represents one “true” scenario. The entire formula is true if any one of these scenarios is met.\n\nAlgorithm to Find DNF from a Truth Table:\n\nIdentify all rows in the truth table where the final result is 1 (True).\nFor each of these rows, create a conjunct (an AND clause).\nWithin each conjunct, if a variable’s value in that row is 1, use the variable directly (e.g., A).\nIf a variable’s value is 0, use its negation (e.g., ¬A).\nConnect all the resulting conjuncts with the disjunction (∨) operator.\n\n1.4.2 Conjunctive Normal Form (CNF) A formula is in Conjunctive Normal Form (CNF) if it is a conjunction (ANDs) of disjuncts (ORs of literals).\n\nStructure: \\((A \\lor \\neg B) \\land (C \\lor D) \\land (\\neg E)\\)\nIntuition: Think of CNF as a set of rules or constraints, all of which must be satisfied for the formula to be true. The formula is made false if any single clause is false.\n\nAlgorithm to Find CNF from a Truth Table:\n\nIdentify all rows in the truth table where the final result is 0 (False).\nFor each of these rows, create a disjunct (an OR clause).\nWithin each disjunct, if a variable’s value in that row is 0, use the variable directly (e.g., A).\nIf a variable’s value is 1, use its negation (e.g., ¬A). (This is the opposite of the DNF rule).\nConnect all the resulting disjuncts with the conjunction (∧) operator.\n\n\n\n\n\n2. Definitions\n\nProposition: A declarative statement that is unambiguously either true or false.\nTruth Table: A table that displays the truth values of a logical formula for all possible combinations of truth values of its component variables.\nLiteral: A propositional variable (e.g., A) or its negation (e.g., ¬A).\nConjunct (Minterm): A conjunction (AND) of one or more literals. For example, A ∧ ¬B ∧ C.\nDisjunct (Maxterm): A disjunction (OR) of one or more literals. For example, A ∨ ¬B ∨ C.\nDisjunctive Normal Form (DNF): A logical formula written as a disjunction of conjuncts. It is an OR of ANDs.\nConjunctive Normal Form (CNF): A logical formula written as a conjunction of disjuncts. It is an AND of ORs.\n\n\n\n3. Formulas\n\nImplication Equivalence: The implication P → Q is logically equivalent to ¬P ∨ Q.\nBiconditional Equivalence: The equivalence P ↔︎ Q is logically equivalent to (P → Q) ∧ (Q → P), which further expands to (¬P ∨ Q) ∧ (P ∨ ¬Q).\nDe Morgan’s Laws:\n\n¬(P ∧ Q) ≡ ¬P ∨ ¬Q\n¬(P ∨ Q) ≡ ¬P ∧ ¬Q\n\nGeneral Formula for DNF: For a function \\(f(x_1, ..., x_n)\\): \\[ f = \\bigvee_{f(\\sigma_1, ..., \\sigma_n)=1} (x_1^{\\sigma_1} \\land ... \\land x_n^{\\sigma_n}) \\] Where \\(x^1\\) means \\(x\\) and \\(x^0\\) means \\(\\neg x\\).\nGeneral Formula for CNF: For a function \\(f(x_1, ..., x_n)\\): \\[ f = \\bigwedge_{f(\\sigma_1, ..., \\sigma_n)=0} (x_1^{\\overline{\\sigma_1}} \\lor ... \\lor x_n^{\\overline{\\sigma_n}}) \\] Where \\(x^{\\overline{1}}\\) means \\(\\neg x\\) and \\(x^{\\overline{0}}\\) means \\(x\\).\n\n\n\n4. Mistakes\n\nConfusing the Direction of Implication: Assuming that if P → Q is true, then Q → P must also be true. Why it’s wrong: “If it is raining, the ground is wet” is true. However, “If the ground is wet, it is raining” is not necessarily true (e.g., a sprinkler could be on). The implication is not symmetric.\nIncorrectly Negating Expressions: Writing ¬(A ∧ B) as ¬A ∧ ¬B. Why it’s wrong: This violates De Morgan’s laws. The correct negation is ¬A ∨ ¬B. The negation of “it is cold AND raining” is “it is NOT cold OR it is NOT raining”.\nMixing up DNF and CNF Creation Rules: Using the wrong rule for variables when constructing normal forms from a truth table. For example, using A for a 1 when building a CNF clause. Why it’s wrong: The rules are inverted. For CNF, you look at the 0 (false) rows, and a 1 in the input corresponds to a negated literal (¬A) in the clause.\nCreating Invalid Normal Form Structures: Writing a DNF with disjunctions (ORs) inside the conjuncts, such as (A ∨ B) ∧ C. Why it’s wrong: A DNF must be strictly an OR of ANDs. The term (A ∨ B) is not a valid conjunct.\nForgetting Rows in a Truth Table: Not listing all \\(2^n\\) possible combinations of inputs. Why it’s wrong: An incomplete truth table can lead to an incorrect analysis of the formula and incorrect DNF/CNF representations.\nMisinterpreting the P → Q case where P is False: Believing that if the premise P is false, the implication P → Q is also false. Why it’s wrong: In classical logic, an implication with a false premise is always considered true. This is known as the principle of “ex falso quodlibet” (from falsehood, anything follows).\n\n\n\n5. Examples\n\n5.1. Construct a Truth Table\nQuestion: Construct the full truth table for the expression (A ∨ B) → ¬A.\n\n\nClick to see the solution\n\n\nSet up columns: We need columns for the variables A and B, the intermediate expression A ∨ B, the negation ¬A, and the final expression (A ∨ B) → ¬A.\nList input combinations: For two variables, there are \\(2^2=4\\) combinations.\nEvaluate A ∨ B: This is true if A or B (or both) are true.\nEvaluate ¬A: This is the opposite of the value of A.\nEvaluate the final implication: The result is false only when the left side (A ∨ B) is true and the right side (¬A) is false.\n\n\n\n\nA\nB\nA ∨ B\n¬A\n(A ∨ B) → ¬A\n\n\n\n\n0\n0\n0\n1\n1\n\n\n0\n1\n1\n1\n1\n\n\n1\n0\n1\n0\n0\n\n\n1\n1\n1\n0\n0\n\n\n\nAnswer: The final truth values for the expression are (1, 1, 0, 0).\n\n\n\n5.2. Truth Table with Equivalence\nQuestion: Construct the truth table for (A → B) ↔︎ (¬B → ¬A).\n\n\nClick to see the solution\n\n\nSet up columns: We need columns for A, B, A → B, ¬B, ¬A, ¬B → ¬A, and the final expression.\nList input combinations: Four rows for variables A and B.\nEvaluate A → B: False only when A=1 and B=0.\nEvaluate negations: ¬A and ¬B.\nEvaluate ¬B → ¬A: False only when ¬B=1 and ¬A=0 (which means B=0 and A=1).\nEvaluate the final equivalence: The result is true when A → B and ¬B → ¬A have the same truth value.\n\n\n\n\nA\nB\nA → B\n¬B\n¬A\n¬B → ¬A\n(A → B) ↔︎ (¬B → ¬A)\n\n\n\n\n0\n0\n1\n1\n1\n1\n1\n\n\n0\n1\n1\n0\n1\n1\n1\n\n\n1\n0\n0\n1\n0\n0\n1\n\n\n1\n1\n1\n0\n0\n1\n1\n\n\n\nAnswer: The expression is a tautology; its truth values are (1, 1, 1, 1).\n\n\n\n5.3. Find DNF from a Truth Table\nQuestion: A function of two variables, T(x, y), has the truth table result (0, 1, 1, 0). Find its Disjunctive Normal Form (DNF). The input order is (0,0), (0,1), (1,0), (1,1).\n\n\nClick to see the solution\n\n\nIdentify the ‘True’ rows: The function T(x, y) is true (1) for the input combinations (x=0, y=1) and (x=1, y=0).\nCreate a conjunct for the first ‘True’ row (0, 1):\n\nx is 0, so we use ¬x.\ny is 1, so we use y.\nThe conjunct is (¬x ∧ y).\n\nCreate a conjunct for the second ‘True’ row (1, 0):\n\nx is 1, so we use x.\ny is 0, so we use ¬y.\nThe conjunct is (x ∧ ¬y).\n\nCombine the conjuncts with OR: Join the terms from steps 2 and 3 with ∨.\n\nAnswer: The DNF is (¬x ∧ y) ∨ (x ∧ ¬y). (This is the formula for XOR).\n\n\n\n5.4. Find CNF from a Truth Table\nQuestion: A function of two variables, T(x, y), has the truth table result (0, 1, 1, 0). Find its Conjunctive Normal Form (CNF).\n\n\nClick to see the solution\n\n\nIdentify the ‘False’ rows: The function T(x, y) is false (0) for the input combinations (x=0, y=0) and (x=1, y=1).\nCreate a disjunct for the first ‘False’ row (0, 0):\n\nx is 0, so we use x.\ny is 0, so we use y.\nThe disjunct is (x ∨ y).\n\nCreate a disjunct for the second ‘False’ row (1, 1):\n\nx is 1, so we use ¬x.\ny is 1, so we use ¬y.\nThe disjunct is (¬x ∨ ¬y).\n\nCombine the disjuncts with AND: Join the terms from steps 2 and 3 with ∧.\n\nAnswer: The CNF is (x ∨ y) ∧ (¬x ∨ ¬y).\n\n\n\n5.5. DNF and CNF for Three Variables\nQuestion: Find both the DNF and CNF for the function T(A, B, C) given by the result vector (0, 1, 0, 1, 1, 0, 1, 0).\n\n\nClick to see the solution\n\nPart 1: Disjunctive Normal Form (DNF)\n\nIdentify ‘True’ rows: The output is 1 for inputs: (0,0,1), (0,1,1), (1,0,0), and (1,1,0).\nCreate conjuncts for each ‘True’ row:\n\n(0,0,1) → (¬A ∧ ¬B ∧ C)\n(0,1,1) → (¬A ∧ B ∧ C)\n(1,0,0) → (A ∧ ¬B ∧ ¬C)\n(1,1,0) → (A ∧ B ∧ ¬C)\n\nCombine with OR: (¬A ∧ ¬B ∧ C) ∨ (¬A ∧ B ∧ C) ∨ (A ∧ ¬B ∧ ¬C) ∨ (A ∧ B ∧ ¬C)\n\nPart 2: Conjunctive Normal Form (CNF)\n\nIdentify ‘False’ rows: The output is 0 for inputs: (0,0,0), (0,1,0), (1,0,1), and (1,1,1).\nCreate disjuncts for each ‘False’ row:\n\n(0,0,0) → (A ∨ B ∨ C)\n(0,1,0) → (A ∨ ¬B ∨ C)\n(1,0,1) → (¬A ∨ B ∨ ¬C)\n(1,1,1) → (¬A ∨ ¬B ∨ ¬C)\n\nCombine with AND: (A ∨ B ∨ C) ∧ (A ∨ ¬B ∨ C) ∧ (¬A ∨ B ∨ ¬C) ∧ (¬A ∨ ¬B ∨ ¬C)\n\nAnswer: * DNF: (¬A ∧ ¬B ∧ C) ∨ (¬A ∧ B ∧ C) ∨ (A ∧ ¬B ∧ ¬C) ∨ (A ∧ B ∧ ¬C) * CNF: (A ∨ B ∨ C) ∧ (A ∨ ¬B ∨ C) ∧ (¬A ∨ B ∨ ¬C) ∧ (¬A ∨ ¬B ∨ ¬C)\n\n\n\n5.6. Convert Formula to DNF\nQuestion: Convert the formula P → (P ∧ Q) to its DNF by first creating its truth table.\n\n\nClick to see the solution\n\n\nCreate the truth table:\n\n\n\n\nP\nQ\nP ∧ Q\nP → (P ∧ Q)\n\n\n\n\n0\n0\n0\n1\n\n\n0\n1\n0\n1\n\n\n1\n0\n0\n0\n\n\n1\n1\n1\n1\n\n\n\n\nIdentify the ‘True’ rows: The final expression is true for inputs (0,0), (0,1), and (1,1).\nCreate conjuncts:\n\n(0,0) → (¬P ∧ ¬Q)\n(0,1) → (¬P ∧ Q)\n(1,1) → (P ∧ Q)\n\nCombine with OR: (¬P ∧ ¬Q) ∨ (¬P ∧ Q) ∨ (P ∧ Q)\n\nAnswer: The DNF is (¬P ∧ ¬Q) ∨ (¬P ∧ Q) ∨ (P ∧ Q).\n\n\n\n5.7. Convert Formula to CNF\nQuestion: Convert the formula P ↔︎ ¬Q to its CNF by first creating its truth table.\n\n\nClick to see the solution\n\n\nCreate the truth table:\n\n\n\n\nP\nQ\n¬Q\nP ↔︎ ¬Q\n\n\n\n\n0\n0\n1\n0\n\n\n0\n1\n0\n1\n\n\n1\n0\n1\n1\n\n\n1\n1\n0\n0\n\n\n\n\nIdentify the ‘False’ rows: The final expression is false for inputs (0,0) and (1,1).\nCreate disjuncts:\n\n(0,0) → (P ∨ Q)\n(1,1) → (¬P ∨ ¬Q)\n\nCombine with AND: (P ∨ Q) ∧ (¬P ∨ ¬Q)\n\nAnswer: The CNF is (P ∨ Q) ∧ (¬P ∨ ¬Q).",
    "crumbs": [
      "Discrete Mathematics",
      "1. Truth Tables, Normal Forms (DNF, CNF)"
    ]
  },
  {
    "objectID": "Computer Architecture/lec_1.html",
    "href": "Computer Architecture/lec_1.html",
    "title": "1. Computer Architecture, FPGA Boards",
    "section": "",
    "text": "1. Summary\n\n1.1 What is a Computer?\nA computer is an electronic machine designed to automatically execute a sequence of arithmetic or logical operations (a program). It processes input data based on a set of instructions and produces an output. At its core, a computer operates on binary data—strings of zeros and ones—manipulating this input to generate a binary result according to a given program.\n\n\n\n1.2 Core Components of a Computer\nThe fundamental structure of a modern computer, often referred to as its Computer Architecture, consists of several key components that interact to execute programs.\n\n1.2.1 CPU (Central Processing Unit): Often called the “brain” of the computer, the CPU is responsible for executing instructions. It is an intricate electrical circuit that performs calculations and manages the flow of information. The CPU itself is composed of smaller, specialized units:\n\nThe Arithmetic-Logic Unit (ALU) performs all arithmetic (addition, subtraction) and logical (AND, OR, NOT) operations.\nThe Control Unit (CU) directs the computer’s operations. It fetches the next instruction from memory, decodes it, and coordinates the other parts of the computer to execute it.\nRegisters are small, extremely fast storage locations within the CPU. They hold data that is actively being used by the CPU, such as the input arguments for an operation or its result.\n\n1.2.2 System Memory (RAM): Also known as Random Access Memory, this is the primary workspace for the computer. It stores the program instructions and data that the CPU needs to access quickly. Memory is volatile, meaning its contents are lost when the power is turned off.\n1.2.3 Storage Devices: Unlike RAM, storage devices (like Solid-State Drives or SSDs) provide long-term, non-volatile storage. They hold the operating system, applications, and user files, which are loaded into RAM as needed.\n1.2.4 Input/Output (I/O) Devices: These are peripheral components that allow the computer to interact with the outside world. Examples include keyboards, mice, monitors, printers, and network cards.\n1.2.5 Communication Bus: The bus is a set of electrical pathways that connects all the computer’s components, allowing them to exchange data. The speed of the bus is critical for overall system performance.\n\n\n\n1.3 The Memory Hierarchy\nNot all memory is created equal. To balance speed, cost, and capacity, computers use a memory hierarchy. Data moves between levels based on how frequently the CPU needs it.\n\nRegisters (inside the CPU): Fastest access, smallest capacity.\nCPU Cache (L1, L2, L3): A small amount of very fast memory located on or very close to the CPU chip. It stores copies of frequently used data from the main memory to reduce the time it takes to access it. L1 cache is the fastest and smallest, embedded directly into each CPU core. Higher-level caches (L2, L3) are progressively larger and slower.\nSystem Memory (RAM): Slower than cache but has a much larger capacity (e.g., gigabytes).\nStorage Devices (SSD): Slowest access speed but offers the largest capacity (e.g., terabytes).\n\nThis hierarchy creates a performance bottleneck known as the “memory wall problem”, where the CPU is often idle while waiting for data to arrive from slower levels of memory. Efficiently managing this hierarchy is a key challenge in computer architecture.\n\n\n\n1.4 Processors vs. FPGAs\nA standard CPU is a general-purpose processor. Its functionality is fixed at the time of manufacturing. It supports a specific, limited set of instructions (its instruction set), and this functionality cannot be changed or extended.\nAn FPGA (Field-Programmable Gate Array) is fundamentally different. It is not a processor, but rather an integrated circuit containing a matrix of configurable logic blocks and programmable interconnects.\n\n1.4.1 Key Differences:\n\nProgrammability: A CPU executes software instructions, but its underlying hardware is fixed. An FPGA’s hardware itself can be reprogrammed many times to perform custom tasks.\nInstruction Set: A CPU has a fixed instruction set. With an FPGA, you design the logic circuits yourself, effectively creating a custom set of instructions tailored precisely to your needs.\nSpeed & Efficiency: For general tasks, a CPU is efficient. For highly specific, parallelizable tasks (like real-time signal processing), a custom circuit on an FPGA can be significantly faster because the hardware is built for that one job.\nCost and Power: FPGAs are generally more expensive and consume more power than general-purpose processors.\n\n1.4.2 Use Cases for FPGAs: FPGAs are often used for prototyping and testing new processor designs before committing to expensive mass manufacturing. They are also ideal for tasks that require massive parallelism and low latency, such as in telecommunications, scientific instruments, and high-frequency trading.\n\n\n\n1.5 FPGA Programming and Boards\nFPGAs are programmed using a Hardware Description Language (HDL), such as Verilog or VHDL. These are not traditional programming languages; instead, they describe the structure and behavior of digital logic circuits. Software like Intel Quartus Prime is used to synthesize this HDL code into a configuration file that is then loaded onto the FPGA to implement the desired hardware design.\nEducational FPGA boards, like the DE10-Lite, come equipped with an FPGA chip and various I/O devices (LEDs, push buttons, switches, displays, sensors) that allow students to design and test real-world digital circuits.\n\n\n\n2. Definitions\n\nComputer: An electronic device that processes data by executing a sequence of instructions defined in a program.\nComputer Architecture: The fundamental design and operational structure of a computer system, detailing how its hardware components (CPU, memory, I/O) are organized and interact.\nCPU (Central Processing Unit): The primary component of a computer that executes program instructions and performs arithmetic, logic, and control operations.\nALU (Arithmetic-Logic Unit): A digital circuit within the CPU that performs integer arithmetic (add, subtract) and bitwise logic operations (AND, OR, NOT).\nCU (Control Unit): The component of the CPU that directs the operation of the processor by interpreting instructions and generating control signals for other components.\nRegister: A small, high-speed storage location directly within the CPU used to hold data and instructions temporarily during processing.\nSystem Memory (RAM): Volatile computer memory that stores data and machine code currently being used. It allows for fast read and write access.\nCPU Cache: A small, fast volatile memory, located closer to the CPU core, that stores copies of frequently used data from main memory to improve access times.\nMemory Hierarchy: A structure that uses a hierarchy of memory and storage devices with different performance characteristics to optimize data access and balance cost, speed, and capacity.\nFPGA (Field-Programmable Gate Array): An integrated circuit that can be configured by a user after manufacturing, allowing the hardware logic itself to be reprogrammed.\nVerilog HDL: A hardware description language used to model electronic systems, most commonly for designing and verifying digital circuits at the register-transfer level of abstraction.\nInstruction Set: The specific set of commands that a particular CPU can recognize and execute, defined by the processor’s architecture.\n\n\n\n3. Mistakes\n\nConfusing an FPGA with a CPU: Treating an FPGA as just a “faster CPU.” Why it’s wrong: They are fundamentally different. A CPU is a fixed-function processor that runs software instructions, while an FPGA is a blank slate of configurable hardware logic. An FPGA is not inherently faster; it’s only faster for tasks that can be efficiently implemented in custom, parallel hardware.\nAssuming FPGAs are always the better choice for performance: Believing an FPGA will outperform a CPU on any task. Why it’s wrong: For general-purpose computing (like running an operating system or a web browser), CPUs are far more efficient due to their specialized architecture and rich instruction sets. FPGAs excel only in very specific, often parallel, applications.\nIgnoring the Memory Hierarchy: Writing code without considering how data moves between the CPU cache and main memory. Why it’s wrong: The “memory wall”—the large speed gap between the CPU and RAM—is a primary performance bottleneck. Programs that access memory randomly and without locality of reference will perform poorly, as the CPU will constantly stall while waiting for data.\nTreating Verilog like a software programming language: Writing Verilog code sequentially, as one would in Python or C, and expecting it to execute line by line. Why it’s wrong: Verilog is a hardware description language. It describes physical circuits that operate in parallel. A misunderstanding of this core concept leads to designs that don’t synthesize into working hardware or behave unexpectedly.\nBelieving a processor’s functionality can be changed with software: Thinking you can add new hardware-level instructions to a CPU through a software update. Why it’s wrong: A CPU’s instruction set is physically etched into its silicon circuits during manufacturing and cannot be altered. While software can emulate new functionality, the underlying hardware capabilities remain fixed.\n\n\n\n4. Examples\n\n4.1 Simple Logic in Verilog\nQuestion: Write a Verilog module that implements a simple AND gate. It should take two single-bit inputs, a and b, and produce one single-bit output, y.\n\n\nClick to see the solution\n\n\nDefine the module: Start by declaring a module with a name (e.g., simple_and) and list its input and output ports. verilog     module simple_and(         input  logic a,         input  logic b,         output logic y     );\nAssign the logic: Use a continuous assign statement to describe the relationship between the inputs and the output. The & operator performs a bitwise AND operation. verilog     assign y = a & b;\nEnd the module: Close the module definition. verilog     endmodule\n\nAnswer: The complete Verilog module is:\nmodule simple_and(\n    input  logic a,\n    input  logic b,\n    output logic y\n);\n\nassign y = a & b;\n\nendmodule\n\n\n\n4.2 Controlling an LED with a Switch\nQuestion: On an FPGA board like the DE10-Lite, you have a switch (SW0) and an LED (LED0). Write a Verilog module to make the LED turn on when the switch is on, and turn off when the switch is off.\n\n\nClick to see the solution\n\n\nDefine the module and ports: Create a module named led_control with one input for the switch and one output for the LED. verilog     module led_control(         input  logic SW0,         output logic LED0     );\nConnect the switch to the LED: The simplest way to achieve this is to directly connect the input to the output. An assign statement creates a “wire” between the two. verilog     assign LED0 = SW0;\nEnd the module: Close the module definition. verilog     endmodule Answer: The Verilog module directly connects the switch’s state to the LED’s state:\n\nmodule led_control(\n    input  logic SW0,\n    output logic LED0\n);\n\nassign LED0 = SW0;\n\nendmodule\n\n\n\n4.3 CPU vs. FPGA Application Choice\nQuestion: You are designing a system for real-time video encoding that needs to process 4K video at 60 frames per second with very low latency. Would a general-purpose CPU or an FPGA be a better choice for the core processing unit? Explain why.\n\n\nClick to see the solution\n\n\nAnalyze the task requirements: The task involves processing a massive, continuous stream of data (4K video) with strict timing constraints (60 fps, low latency). The operations (e.g., color space conversion, compression algorithms) are highly repetitive and can be broken down into many small, parallel steps.\nEvaluate the CPU’s suitability: A CPU would process the video frames using software. While powerful, it executes instructions sequentially (even with multiple cores) and has overhead from the operating system. Achieving consistent low latency for every single frame would be extremely challenging.\nEvaluate the FPGA’s suitability: An FPGA can be configured to have a dedicated hardware pipeline for video processing. Multiple stages of the encoding algorithm can run simultaneously on different parts of the chip for different pixels or frames. This massive parallelism is ideal for video streams. Because it’s a dedicated hardware solution, it avoids OS overhead and can guarantee consistent, low-latency processing. Answer: An FPGA is the better choice. Why: Video encoding is a highly parallel task. An FPGA allows for the creation of a custom hardware pipeline where many calculations happen simultaneously, which is far more efficient and provides the low, predictable latency required for real-time processing, something a general-purpose CPU struggling with OS and other overheads cannot guarantee.\n\n\n\n\n4.4 Memory Hierarchy Access\nQuestion: A program is executing a for loop that repeatedly adds two numbers. The machine code instruction for the addition operation is currently being executed by the CPU. In which level of the memory hierarchy would you most likely find this instruction?\n\n\nClick to see the solution\n\n\nConsider the CPU’s immediate needs: The CPU can only execute instructions that are physically inside it.\nRecall the fastest memory level: The fastest and closest memory to the ALU and CU are the registers. The Control Unit fetches instructions from memory into a special-purpose register (often called the Instruction Register) just before decoding and execution.\nConsider the role of cache: Since the instruction is part of a loop, it’s being used repeatedly. Therefore, it is almost certain to have been copied from the slower main memory (RAM) into the much faster L1 instruction cache for quick access on subsequent loop iterations.\nCombine the points: The instruction must be in a register to be executed. Given it’s in a loop, it would also reside in the L1 cache to avoid fetching it from slow RAM every time. The most immediate location is a register. Answer: The instruction would be found in a CPU register (specifically, the instruction register) at the moment of execution. A copy of it would also reside in the L1 cache for fast re-access during the next iteration of the loop.\n\n\n\n\n4.5 2-to-1 Multiplexer in Verilog\nQuestion: A 2-to-1 multiplexer (MUX) is a circuit that selects one of two inputs (a or b) to pass to the output (y) based on a selector signal (sel). If sel is 0, y should be a. If sel is 1, y should be b. Implement this in a Verilog module.\n\n\nClick to see the solution\n\n\nDefine the module and its ports: The module requires three inputs (a, b, sel) and one output (y). verilog     module mux_2_to_1(         input  logic a,         input  logic b,         input  logic sel,         output logic y     );\nImplement the selection logic: A conditional assign statement using the ternary operator (? :) is a concise way to model this. The structure is condition ? value_if_true : value_if_false. verilog     assign y = (sel == 1) ? b : a; This line reads as: “Assign y the value of b if sel is 1; otherwise, assign it the value of a.”\nEnd the module: Close the module definition. verilog     endmodule Answer: The complete Verilog module for a 2-to-1 MUX is:\n\nmodule mux_2_to_1(\n    input  logic a,\n    input  logic b,\n    input  logic sel,\n    output logic y\n);\n\nassign y = sel ? b : a; // A more compact way of writing (sel == 1)\n\nendmodule\n\n\n\n4.6 Processor Instruction Set Limitation\nQuestion: Imagine a very simple processor whose instruction set only contains ADD, SUBTRACT, and STORE. You need to perform a multiplication, for example, 5 * 3. How could you accomplish this using only the available instructions?\n\n\nClick to see the solution\n\n\nUnderstand the core concept of multiplication: Multiplication is repeated addition. For example, 5 * 3 is the same as 5 + 5 + 5.\nFormulate an algorithm using available instructions:\n\nInitialize a result variable (in a register, let’s call it R1) to 0.\nUse the ADD instruction to add 5 to R1.\nUse the ADD instruction again to add 5 to R1. R1 now holds 10.\nUse the ADD instruction a third time to add 5 to R1. R1 now holds 15.\nUse the STORE instruction to save the value from R1 to a memory location.\n\nStructure the process: This would be implemented as a software loop. The program would use the ADD instruction three times. Answer: You can perform multiplication by implementing it as a series of additions. To calculate 5 * 3, you would write a short program that uses a loop to execute the ADD 5 instruction three times, accumulating the result in a register.\n\n\n\n\n4.7 Identifying FPGA Board Components\nQuestion: You are looking at a DE10-Lite FPGA board. You see a large, square chip in the center labeled “MAX 10”. What is the function of this component?\n\n\nClick to see the solution\n\n\nAnalyze the component’s description: The chip is large, centrally located, and has a specific model name (“MAX 10”).\nRecall the purpose of an FPGA board: The primary purpose of an FPGA development board is to provide a platform for programming and testing an FPGA.\nConnect the information: The central, most prominent chip on an FPGA board is almost always the FPGA itself. The “MAX 10” is a product family of FPGAs made by Altera (now Intel). Answer: The chip labeled “MAX 10” is the FPGA (Field-Programmable Gate Array) itself. It is the main component that you program with your hardware design using a language like Verilog.",
    "crumbs": [
      "Computer Architecture",
      "1. Computer Architecture, FPGA Boards"
    ]
  },
  {
    "objectID": "Mathematical Analysis I/lec_3.html",
    "href": "Mathematical Analysis I/lec_3.html",
    "title": "3. Functions and Their Graphs, Elementary Functions and Properties",
    "section": "",
    "text": "1. Summary\n\n1.1 Introduction to Functions, Domain, and Range\nA function is a fundamental concept in mathematics that describes a relationship between two sets of values. It can be thought of as a rule or a machine that takes an input from a set called the domain and produces a single, unique output in a set called the codomain. For every input, there is exactly one output.\n\nDomain: The domain of a function is the complete set of all possible input values (often represented by the variable \\(x\\)) for which the function is defined. For example, in the function \\(f(x) = \\sqrt{x}\\), we cannot take the square root of a negative number (in the set of real numbers), so the domain is all non-negative numbers, written as \\(x \\ge 0\\) or \\([0, \\infty)\\).\nRange: The range is the set of all possible output values (often represented by \\(y\\) or \\(f(x)\\)) that the function can produce. For the same function, \\(f(x) = \\sqrt{x}\\), the outputs are always non-negative, so the range is \\([0, \\infty)\\).\n\n\n\n\n1.2 The Graph of a Function\nA function can be visually represented by its graph on a Cartesian plane (the standard \\(x-y\\) coordinate system). The graph consists of all points \\((x, y)\\) where \\(x\\) is an input from the domain and \\(y = f(x)\\) is the corresponding output. Essentially, for any point on the graph, its \\(y\\)-coordinate represents the height of the function at that specific \\(x\\)-value. If \\(f(x)\\) is positive, the point is above the x-axis; if negative, it’s below.\n\n\n1.3 Special Step Functions: Floor and Ceiling\nTwo common functions that operate on real numbers are the floor and ceiling functions. They are examples of step functions because their graphs look like a series of steps.\n\nFloor Function (or Greatest Integer Function): Denoted as \\(\\lfloor x \\rfloor\\), this function returns the greatest integer that is less than or equal to \\(x\\). It effectively rounds a number down to the nearest integer.\n\nExamples: \\(\\lfloor 2.9 \\rfloor = 2\\), \\(\\lfloor -1.5 \\rfloor = -2\\), \\(\\lfloor 3 \\rfloor = 3\\).\n\nCeiling Function (or Least Integer Function): Denoted as \\(\\lceil x \\rceil\\), this function returns the smallest integer that is greater than or equal to \\(x\\). It effectively rounds a number up to the nearest integer.\n\nExamples: \\(\\lceil 2.1 \\rceil = 3\\), \\(\\lceil -1.5 \\rceil = -1\\), \\(\\lceil 3 \\rceil = 3\\).\n\n\n\n\n\n1.4 Monotone Functions\nA function is monotone if it consistently follows a single trend over an interval. This describes the function’s behavior as \\(x\\) increases.\n\nIncreasing Function: A function \\(f\\) is increasing if its output values either increase or stay the same as the input values increase. Formally, for any \\(x_1 &lt; x_2\\) in an interval, \\(f(x_1) \\le f(x_2)\\).\nStrictly Increasing Function: A function is strictly increasing if its output values always increase as the input values increase. For any \\(x_1 &lt; x_2\\), \\(f(x_1) &lt; f(x_2)\\). The function \\(f(x) = x^3\\) is strictly increasing everywhere.\nDecreasing Function: A function \\(f\\) is decreasing if its output values either decrease or stay the same as the input values increase. For any \\(x_1 &lt; x_2\\), \\(f(x_1) \\ge f(x_2)\\).\nStrictly Decreasing Function: A function is strictly decreasing if its output values always decrease as the input values increase. For any \\(x_1 &lt; x_2\\), \\(f(x_1) &gt; f(x_2)\\). The function \\(f(x) = -x\\) is strictly decreasing everywhere.\n\nThe function \\(f(x) = x^2\\) is strictly decreasing on the interval \\((-\\infty, 0]\\) and strictly increasing on \\([0, \\infty)\\).\n\n\n1.5 Combining Functions Arithmetically\nJust like numbers, functions can be combined using basic arithmetic operations: addition, subtraction, multiplication, and division. To combine two functions, \\(f(x)\\) and \\(g(x)\\), we simply perform the operation on their outputs. The domain of the new combined function is the intersection of the domains of \\(f\\) and \\(g\\).\n\nSum: \\((f + g)(x) = f(x) + g(x)\\)\nDifference: \\((f - g)(x) = f(x) - g(x)\\)\nProduct: \\((f \\cdot g)(x) = f(x) \\cdot g(x)\\)\nQuotient: \\((f / g)(x) = f(x) / g(x)\\). For the quotient, we have an additional restriction: the domain must exclude any \\(x\\) values for which \\(g(x) = 0\\) to avoid division by zero.\n\n\n\n1.6 Composition of Functions\nFunction composition is the process of applying one function to the result of another. The composition of \\(f\\) with \\(g\\), denoted \\((f \\circ g)(x)\\), means we first evaluate \\(g(x)\\) and then use that result as the input for \\(f\\). So, \\((f \\circ g)(x) = f(g(x))\\).\n\nDomain of a Composite Function: The domain of \\((f \\circ g)(x)\\) consists of all \\(x\\) in the domain of \\(g\\) for which the output \\(g(x)\\) is in the domain of \\(f\\).\nOrder Matters: It is crucial to remember that function composition is not commutative, meaning \\((f \\circ g)(x)\\) is generally not the same as \\((g \\circ f)(x)\\).\n\n\n\n\n1.7 One-to-One and Inverse Functions\n\nOne-to-One Function: A function is one-to-one if every output in its range corresponds to exactly one unique input in its domain. In other words, no two different inputs produce the same output. Graphically, this can be checked with the horizontal line test: if no horizontal line intersects the graph more than once, the function is one-to-one.\n\nExample: \\(f(x) = x^3\\) is one-to-one.\nNon-Example: \\(f(x) = x^2\\) is not one-to-one because, for example, \\(f(2)=4\\) and \\(f(-2)=4\\).\n\nInverse Function: Only one-to-one functions have an inverse function. The inverse function, denoted \\(f^{-1}(x)\\), “reverses” the action of the original function. If \\(f(a) = b\\), then \\(f^{-1}(b) = a\\).\n\nThe domain of \\(f^{-1}\\) is the range of \\(f\\).\nThe range of \\(f^{-1}\\) is the domain of \\(f\\).\nGraphically, the graph of \\(f^{-1}(x)\\) is a reflection of the graph of \\(f(x)\\) across the line \\(y=x\\).\n\n\n\n\n1.8 Even and Odd Functions\nThis classification relates to a function’s symmetry. The function’s domain must be symmetric with respect to the origin (if \\(x\\) is in the domain, then \\(-x\\) must also be).\n\nEven Function: A function \\(f\\) is even if \\(f(-x) = f(x)\\) for all \\(x\\) in its domain. The graph of an even function is symmetric with respect to the y-axis. Example: \\(f(x) = \\cos(x)\\) and \\(f(x) = x^2\\).\nOdd Function: A function \\(f\\) is odd if \\(f(-x) = -f(x)\\) for all \\(x\\) in its domain. The graph of an odd function is symmetric with respect to the origin. Example: \\(f(x) = \\sin(x)\\) and \\(f(x) = x^3\\).\n\n\n\n1.9 Elementary Functions and Their Properties\n\n1.9.1 Power, Polynomial, and Rational Functions\n\nA power function has the form \\(f(x) = x^a\\), where \\(a\\) is a constant.\nA polynomial function is a sum of power functions with non-negative integer exponents, of the form \\(p(x) = a_n x^n + a_{n-1} x^{n-1} + \\dots + a_1 x + a_0\\). The domain of any polynomial is all real numbers \\((-\\infty, \\infty)\\).\nA rational function is a ratio of two polynomials, \\(f(x) = p(x) / q(x)\\). Its domain is all real numbers except for the values of \\(x\\) that make the denominator \\(q(x)\\) equal to zero.\n\n\n\n1.9.2 Exponential and Logarithmic Functions\n\nAn exponential function has the form \\(f(x) = a^x\\), where the base \\(a\\) is a positive constant not equal to 1. The domain is \\((-\\infty, \\infty)\\) and the range is \\((0, \\infty)\\). If \\(a&gt;1\\), the function is strictly increasing. The most common base is \\(e \\approx 2.718\\).\nA logarithmic function, \\(f(x) = \\log_a(x)\\), is the inverse of the exponential function \\(a^x\\). It answers the question: “to what power must we raise base \\(a\\) to get \\(x\\)?”. Its domain is \\((0, \\infty)\\) and its range is \\((-\\infty, \\infty)\\). The natural logarithm, \\(\\ln(x)\\), has base \\(e\\).\n\n\n\n\n1.9.3 Trigonometric and Inverse Trigonometric Functions\n\nTrigonometric functions (sine, cosine, tangent, etc.) describe relationships between angles and side lengths in right triangles. They are defined for any real number angle and are periodic, meaning their values repeat in regular intervals.\nBecause they are periodic, trigonometric functions are not one-to-one. To define their inverse trigonometric functions (arcsin, arccos, etc.), we must restrict their domains to a principal interval where they are one-to-one. For example, \\(\\arcsin(x)\\) returns an angle in \\([-\\pi/2, \\pi/2]\\).\n\n\n\n\n1.9.4 Hyperbolic and Inverse Hyperbolic Functions\n\nHyperbolic functions (sinh, cosh, etc.) are combinations of the exponential functions \\(e^x\\) and \\(e^{-x}\\). For example, \\(\\sinh(x) = (e^x - e^{-x})/2\\). They share many properties and identities analogous to trigonometric functions.\nInverse hyperbolic functions are the inverses of the hyperbolic functions (with domain restrictions where necessary, such as for \\(\\cosh(x)\\)). They can be expressed in terms of natural logarithms. For example, \\(\\text{arsinh}(x) = \\ln(x + \\sqrt{x^2+1})\\).\n\n\n\n\n\n2. Definitions\n\nFunction: A rule that assigns to each element in a set called the domain, exactly one element from a set called the codomain.\nDomain: The set of all possible input values for which a function is defined.\nRange: The set of all possible output values of a function.\nFloor Function \\(\\lfloor x \\rfloor\\): The greatest integer less than or equal to \\(x\\).\nCeiling Function \\(\\lceil x \\rceil\\): The smallest integer greater than or equal to \\(x\\).\nMonotone Function: A function that is either entirely non-increasing or non-decreasing over an interval.\nOne-to-One Function: A function where each output value is produced by exactly one unique input value.\nInverse Function \\(f^{-1}(x)\\): A function that reverses the action of a one-to-one function \\(f(x)\\). If \\(f(a)=b\\), then \\(f^{-1}(b)=a\\).\nEven Function: A function whose graph is symmetric about the y-axis, satisfying \\(f(-x) = f(x)\\).\nOdd Function: A function whose graph has rotational symmetry about the origin, satisfying \\(f(-x) = -f(x)\\).\nPolynomial: A function expressed as a sum of terms, each being a constant multiplied by a power of a variable with a non-negative integer exponent.\nRational Function: A function that is the ratio of two polynomial functions.\nExponential Function: A function of the form \\(f(x) = a^x\\) where \\(a\\) is a positive constant base.\nLogarithmic Function: The inverse of an exponential function, written as \\(f(x) = \\log_a(x)\\).\nPeriodic Function: A function that repeats its values at regular intervals or periods.\nHyperbolic Functions: Functions defined using combinations of the exponential function \\(e^x\\), such as \\(\\sinh(x)\\) and \\(\\cosh(x)\\).\n\n\n\n3. Formulas\n\nSum of Functions: \\((f + g)(x) = f(x) + g(x)\\)\nDifference of Functions: \\((f - g)(x) = f(x) - g(x)\\)\nProduct of Functions: \\((f \\cdot g)(x) = f(x) \\cdot g(x)\\)\nQuotient of Functions: \\((f / g)(x) = f(x) / g(x)\\), where \\(g(x) \\neq 0\\)\nComposition of Functions: \\((f \\circ g)(x) = f(g(x))\\)\nInverse Function Property: \\(f(f^{-1}(x)) = x\\) and \\(f^{-1}(f(x)) = x\\)\nPythagorean Identity: \\(\\sin^2(x) + \\cos^2(x) = 1\\)\nHyperbolic Identity: \\(\\cosh^2(x) - \\sinh^2(x) = 1\\)\nHyperbolic Sine: \\(\\sinh(x) = \\frac{e^x - e^{-x}}{2}\\)\nHyperbolic Cosine: \\(\\cosh(x) = \\frac{e^x + e^{-x}}{2}\\)\nLogarithm Product Rule: \\(\\ln(ab) = \\ln(a) + \\ln(b)\\)\nLogarithm Quotient Rule: \\(\\ln(a/b) = \\ln(a) - \\ln(b)\\)\nLogarithm Power Rule: \\(\\ln(a^b) = b \\ln(a)\\)\nChange of Base Formula: \\(\\log_b(x) = \\frac{\\ln(x)}{\\ln(b)}\\)\nInverse Hyperbolic Sine (Log Form): \\(\\text{arsinh}(x) = \\ln(x + \\sqrt{x^2+1})\\)\n\n\n\n4. Mistakes\n\nConfusing Domain and Range: A common mistake is to mix up the set of valid inputs (domain) with the set of possible outputs (range). Why it’s wrong: The domain is determined by the function’s definition (e.g., avoiding square roots of negatives), while the range is the result of applying the function to its entire domain.\nAssuming Function Composition is Commutative: Believing that \\(f(g(x))\\) is always the same as \\(g(f(x))\\). Why it’s wrong: The order of operations matters. Applying \\(g\\) then \\(f\\) is a different process than applying \\(f\\) then \\(g\\), usually leading to different results.\nMistaking Inverse Notation for a Reciprocal: Interpreting \\(f^{-1}(x)\\) as \\(1/f(x)\\). Why it’s wrong: The \\(-1\\) notation signifies an inverse function, not a multiplicative inverse (reciprocal). For example, \\(\\sin^{-1}(x)\\) is \\(\\arcsin(x)\\), not \\(\\csc(x)\\).\nIncorrectly Applying Logarithm Rules: Applying rules incorrectly, such as stating \\(\\ln(x+y) = \\ln(x) + \\ln(y)\\). Why it’s wrong: The logarithm of a sum is not the sum of the logarithms. The correct rule is \\(\\ln(xy) = \\ln(x) + \\ln(y)\\).\nIgnoring Domain Restrictions for Inverse Trigonometric Functions: Forgetting that \\(\\arcsin(\\sin(x)) = x\\) is only true for \\(x\\) within the restricted range \\(-\\pi/2 \\le x \\le \\pi/2\\). Why it’s wrong: The output of \\(\\arcsin\\) is always in that restricted range, so for \\(x\\) values outside it, the result will be a different angle that has the same sine value.\nForgetting to Exclude Values from the Domain: When finding the domain of a rational function \\(f(x) = p(x)/q(x)\\), it’s easy to forget to set \\(q(x) \\neq 0\\). Why it’s wrong: Division by zero is an undefined mathematical operation, so any inputs that cause it must be excluded from the domain.\n\n\n\n5. Examples\n\n5.1. Domain and Range\nQuestion: Find the domain and range of the function \\(f(x) = \\sqrt{x - 3} + 5\\).\n\n\nClick to see the solution\n\n\nFind the domain: The expression inside the square root must be non-negative. \\[ x - 3 \\ge 0 \\] \\[ x \\ge 3 \\] The domain is \\([3, \\infty)\\).\nFind the range: The square root term, \\(\\sqrt{x-3}\\), can only produce non-negative values (\\(\\ge 0\\)). \\[ \\sqrt{x-3} \\ge 0 \\] We then add 5 to this value. \\[ \\sqrt{x-3} + 5 \\ge 5 \\] So, the output \\(f(x)\\) will always be greater than or equal to 5. The range is \\([5, \\infty)\\).\n\nAnswer: Domain: \\([3, \\infty)\\); Range: \\([5, \\infty)\\).\n\n\n\n5.2. Function Composition\nQuestion: Given \\(f(x) = x^2 + 1\\) and \\(g(x) = 2x - 3\\), find \\((f \\circ g)(x)\\) and \\((g \\circ f)(x)\\).\n\n\nClick to see the solution\n\n\nCalculate \\((f \\circ g)(x)\\): This means \\(f(g(x))\\). Substitute the entire expression for \\(g(x)\\) into \\(f(x)\\) wherever you see \\(x\\). \\[ (f \\circ g)(x) = f(2x - 3) = (2x - 3)^2 + 1 \\]\nExpand and simplify: \\[ (4x^2 - 12x + 9) + 1 = 4x^2 - 12x + 10 \\]\nCalculate \\((g \\circ f)(x)\\): This means \\(g(f(x))\\). Substitute the entire expression for \\(f(x)\\) into \\(g(x)\\). \\[ (g \\circ f)(x) = g(x^2 + 1) = 2(x^2 + 1) - 3 \\]\nExpand and simplify: \\[ 2x^2 + 2 - 3 = 2x^2 - 1 \\]\n\nAnswer: \\((f \\circ g)(x) = 4x^2 - 12x + 10\\); \\((g \\circ f)(x) = 2x^2 - 1\\).\n\n\n\n5.3. Even and Odd Functions\nQuestion: Determine if the function \\(f(x) = x^3 - x\\) is even, odd, or neither.\n\n\nClick to see the solution\n\n\nFind \\(f(-x)\\): Replace every instance of \\(x\\) in the function with \\(-x\\). \\[ f(-x) = (-x)^3 - (-x) \\]\nSimplify the expression: \\[ f(-x) = -x^3 + x \\]\nCompare \\(f(-x)\\) with \\(f(x)\\) and \\(-f(x)\\):\n\nIs \\(f(-x) = f(x)\\)? Is \\(-x^3 + x = x^3 - x\\)? No. So, it is not even.\nIs \\(f(-x) = -f(x)\\)? Let’s find \\(-f(x)\\): \\(-(x^3 - x) = -x^3 + x\\).\nYes, \\(f(-x)\\) is equal to \\(-f(x)\\).\n\n\nAnswer: The function is odd.\n\n\n\n5.4. Finding an Inverse Function\nQuestion: Find the inverse of the function \\(f(x) = \\frac{2x + 1}{x - 3}\\).\n\n\nClick to see the solution\n\n\nReplace \\(f(x)\\) with \\(y\\): \\[ y = \\frac{2x + 1}{x - 3} \\]\nSwap \\(x\\) and \\(y\\): \\[ x = \\frac{2y + 1}{y - 3} \\]\nSolve for \\(y\\): \\[ x(y - 3) = 2y + 1 \\] \\[ xy - 3x = 2y + 1 \\] \\[ xy - 2y = 3x + 1 \\] \\[ y(x - 2) = 3x + 1 \\] \\[ y = \\frac{3x + 1}{x - 2} \\]\nReplace \\(y\\) with \\(f^{-1}(x)\\): \\[ f^{-1}(x) = \\frac{3x + 1}{x - 2} \\]\n\nAnswer: The inverse function is \\(f^{-1}(x) = \\frac{3x + 1}{x - 2}\\).\n\n\n\n5.5. Logarithm Properties\nQuestion: Express \\(\\ln(x^2) - 2\\ln(y) + \\ln(xy)\\) as a single logarithm.\n\n\nClick to see the solution\n\n\nApply the power rule: \\(\\ln(a^b) = b\\ln(a)\\). The first term is already in a usable form, but \\(2\\ln(y)\\) becomes \\(\\ln(y^2)\\). \\[ \\ln(x^2) - \\ln(y^2) + \\ln(xy) \\]\nApply the quotient rule: \\(\\ln(a) - \\ln(b) = \\ln(a/b)\\) to the first two terms. \\[ \\ln\\left(\\frac{x^2}{y^2}\\right) + \\ln(xy) \\]\nApply the product rule: \\(\\ln(a) + \\ln(b) = \\ln(ab)\\). \\[ \\ln\\left(\\frac{x^2}{y^2} \\cdot xy\\right) \\]\nSimplify the expression inside the logarithm: \\[ \\ln\\left(\\frac{x^3 y}{y^2}\\right) = \\ln\\left(\\frac{x^3}{y}\\right) \\]\n\nAnswer: \\(\\ln\\left(\\frac{x^3}{y}\\right)\\).\n\n\n\n5.6. Evaluating Inverse Trigonometric Functions\nQuestion: Find the exact value of \\(\\cos(\\arcsin(-\\frac{1}{2}))\\).\n\n\nClick to see the solution\n\n\nEvaluate the inner function: Let \\(\\theta = \\arcsin(-\\frac{1}{2})\\). This means \\(\\sin(\\theta) = -\\frac{1}{2}\\) and \\(\\theta\\) must be in the range \\([-\\pi/2, \\pi/2]\\). The angle in this range whose sine is \\(-1/2\\) is \\(\\theta = -\\pi/6\\).\nSubstitute the angle back into the expression: The problem now becomes finding \\(\\cos(-\\pi/6)\\).\nUse the property of cosine: Cosine is an even function, so \\(\\cos(-\\theta) = \\cos(\\theta)\\). \\[ \\cos(-\\pi/6) = \\cos(\\pi/6) \\]\nEvaluate the result: The cosine of \\(\\pi/6\\) (or 30 degrees) is \\(\\frac{\\sqrt{3}}{2}\\).\n\nAnswer: \\(\\frac{\\sqrt{3}}{2}\\).\n\n\n\n5.7. Proof of Hyperbolic Identity\nQuestion: Prove the identity \\(\\cosh^2(x) - \\sinh^2(x) = 1\\) using the exponential definitions.\n\n\nClick to see the solution\n\n\nWrite out the definitions:\n\n\\(\\cosh(x) = \\frac{e^x + e^{-x}}{2}\\)\n\\(\\sinh(x) = \\frac{e^x - e^{-x}}{2}\\)\n\nSubstitute the definitions into the left side of the identity: \\[ \\left(\\frac{e^x + e^{-x}}{2}\\right)^2 - \\left(\\frac{e^x - e^{-x}}{2}\\right)^2 \\]\nSquare both terms: \\[ \\frac{(e^x + e^{-x})^2}{4} - \\frac{(e^x - e^{-x})^2}{4} \\] \\[ \\frac{e^{2x} + 2e^x e^{-x} + e^{-2x}}{4} - \\frac{e^{2x} - 2e^x e^{-x} + e^{-2x}}{4} \\]\nSimplify \\(e^x e^{-x}\\): Since \\(e^x e^{-x} = e^{x-x} = e^0 = 1\\), the expression becomes: \\[ \\frac{e^{2x} + 2 + e^{-2x}}{4} - \\frac{e^{2x} - 2 + e^{-2x}}{4} \\]\nCombine the fractions: \\[ \\frac{(e^{2x} + 2 + e^{-2x}) - (e^{2x} - 2 + e^{-2x})}{4} \\] \\[ \\frac{e^{2x} + 2 + e^{-2x} - e^{2x} + 2 - e^{-2x}}{4} \\]\nCancel terms and simplify: \\[ \\frac{4}{4} = 1 \\] This equals the right side of the identity.\n\nAnswer: The proof is complete as the left side simplifies to 1.",
    "crumbs": [
      "Mathematical Analysis I",
      "3. Functions and Their Graphs, Elementary Functions and Properties"
    ]
  }
]