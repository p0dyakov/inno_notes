---
title: "3. Pointers, Declarations, Preprocessing, File I/O in C"
author: "Zakhar Podyakov"
date: "September 17, 2025"
format: html
engine: knitr
---

#### **1. Summary**

##### **1.1 Introduction to Pointers in C**

A **pointer** is a fundamental concept in C programming. It is essentially a variable whose value is the *memory address* of another variable. Instead of holding data directly (like an integer or a character), a pointer "points to" the location where the data is stored. This allows for indirect manipulation of data, dynamic memory allocation, and efficient handling of complex data structures.

The primary operators used with pointers are:

*   **Address-of operator (`&`)**: Returns the memory address of a variable.
*   **Dereference operator (`*`)**: Accesses the value stored at the memory address held by a pointer.

<!-- DIAGRAM HERE -->

##### **1.2 Common Problems with Pointers**

Due to their low-level nature, pointers introduce several potential pitfalls that programmers must carefully manage.

*   **Ownership and Destruction**: A pointer declaration does not specify who is responsible for freeing the memory it points to. This ambiguity can lead to two major errors:
    *   **Memory Leaks**: If memory is dynamically allocated and no part of the code frees it, the memory remains occupied for the program's lifetime, even if it's no longer accessible. This happens when the last pointer to the allocated memory goes out of scope.
    *   **Double Free**: Attempting to free the same memory block more than once can corrupt memory management data structures, leading to unpredictable crashes.

*   **Dangling Pointers**: A **dangling pointer** is a pointer that points to a memory location that has already been deallocated (freed). Dereferencing a dangling pointer results in *undefined behavior*, as the memory may have been reallocated for another purpose or could contain garbage data.

<!-- DIAGRAM HERE -->

*   **Distinguishing Single Objects vs. Arrays**: A pointer of type `T*` can point to a single object of type `T` or to the first element of an array of `T`'s. The C language provides no built-in way to distinguish between these two cases, which can lead to errors when performing pointer arithmetic or deallocating memory (e.g., using `free()` on an array that requires `delete[]` in C++).

##### **1.3 Declarations in C**

A **declaration** in C introduces one or more identifiers (like variable or function names) into the program and specifies their meaning and properties. A single declaration provides up to four pieces of information:

1.  **Storage Class**: Determines the lifetime and visibility of the entity (e.g., `static`, `extern`, `auto`).
2.  **Type Specifier**: Defines the data type of the entity (e.g., `int`, `double`, `struct S`).
3.  **Entity Name**: The identifier being declared (e.g., `a`, `my_function`).
4.  **Initializer**: An optional initial value for the entity (e.g., `= 777`).

C's declaration syntax follows a principle often called "declaration follows use." This means the declaration mimics the syntax of an expression that would yield a value of the base type.

*   `int *p;`: Dereferencing `p` (`*p`) yields an `int`. Therefore, `p` is a pointer to an `int`.
*   `int a[10];`: Accessing an element of `a` (`a[i]`) yields an `int`. Therefore, `a` is an array of `int`s.
*   `int f();`: Calling `f` (`f()`) yields an `int`. Therefore, `f` is a function returning an `int`.

This can lead to complex declarations:
*   `int *f(int);`: `f` is a function that takes an `int` and returns a pointer to an `int`.
*   `int (*f)(int);`: `f` is a pointer to a function that takes an `int` and returns an `int`.

The `typedef` keyword provides a way to create an alias for a complex type, which greatly improves code readability.

<!-- DIAGRAM HERE -->

##### **1.4 The C Preprocessor**

The C preprocessor is a tool that processes the source code *before* compilation. It operates on a text-to-text basis, performing substitutions and transformations based on **preprocessor directives**â€”lines that begin with a `#` symbol. It does not understand C syntax or semantics.

Key directives include:

*   `#include`: Replaces the directive with the entire content of a specified file. This is how header files (like `stdio.h`) are incorporated into your code.
*   `#define`: Creates a **macro**. In its simplest form, it's a find-and-replace for a token. It can also define function-like macros with parameters, but these are prone to errors if not written carefully (e.g., by wrapping all parameters and the entire macro body in parentheses).
*   `#if`, `#ifdef`, `#ifndef`, `#else`, `#elif`, `#endif`: These directives provide **conditional compilation**. They allow the preprocessor to include or exclude blocks of code based on certain conditions, such as whether a macro is defined. A common use case is the **include guard**, which prevents a header file from being included multiple times in a single compilation unit.

<!-- DIAGRAM HERE -->

##### **1.5 File I/O in C**

File input/output (I/O) in C is handled through the standard library, primarily defined in the `<stdio.h>` header. The central concept is the **file stream**, which is an abstraction that allows a programmer to treat files and other I/O devices (like the console) in a uniform way.

A file stream is represented by a pointer to a `FILE` object, often called a **file handle**.

The standard workflow for file I/O is:

1.  **Open the file**: Use the `fopen()` function, providing a file path and a *mode string* (e.g., `"r"` for reading, `"w"` for writing, `"a"` for appending). `fopen()` returns a `FILE` pointer if successful or `NULL` on failure.
2.  **Perform I/O**: Read from or write to the file using functions like:
    *   `fscanf()` / `fprintf()`: For formatted input/output, similar to `scanf()` and `printf()`.
    *   `fgets()` / `fputs()`: For reading/writing strings (lines).
    *   `fgetc()` / `fputc()`: For reading/writing single characters.
    *   `fread()` / `fwrite()`: For binary I/O of raw data blocks.
3.  **Close the file**: Use the `fclose()` function, passing the `FILE` pointer. This is a critical step that flushes any buffered data to the disk and releases system resources associated with the file. Forgetting to close a file can lead to data loss.

#### **2. Definitions**

*   **Pointer**: A variable that stores the memory address of another object.
*   **Dereferencing**: The action of accessing the value stored at the memory address pointed to by a pointer, using the `*` operator.
*   **Dynamic Memory Allocation**: The process of requesting memory from the operating system at runtime (e.g., using `malloc()`). This memory is not managed by the compiler's scope rules and must be manually deallocated.
*   **Memory Leak**: A situation where dynamically allocated memory is no longer needed by the program but is not deallocated (freed), making it unusable for the remainder of the program's execution.
*   **Dangling Pointer**: A pointer that refers to a memory location that has been freed or deallocated.
*   **Preprocessor**: A program that processes source code before compilation, performing tasks like file inclusion, macro expansion, and conditional compilation.
*   **Macro**: An identifier defined with `#define` that is replaced by its corresponding value or code block by the preprocessor before compilation.
*   **Typedef**: A keyword in C used to create a synonym or alias for an existing data type, often used to simplify complex type declarations.
*   **File Handle**: A pointer to a `FILE` structure (`FILE *`), which holds all the necessary information to manage a file stream, such as its current position, buffer status, and error indicators.

#### **4. Mistakes**

*   **Dereferencing an Uninitialized or NULL Pointer**: An uninitialized pointer holds a garbage value, and a `NULL` pointer points to nothing. Attempting to access the memory they "point to" results in undefined behavior, which often leads to a program crash (segmentation fault). **Why it's wrong**: You are trying to read from or write to a memory address that is either invalid or not owned by your program.
*   **Forgetting to Free Dynamically Allocated Memory**: If you allocate memory with `malloc()` but fail to release it with `free()` when it's no longer needed, you create a memory leak. **Why it's wrong**: Over time, memory leaks can exhaust available system memory, causing the program or even the entire system to slow down or crash.
*   **Using a Pointer After `free()`**: Accessing memory through a pointer after it has been freed is a classic dangling pointer error. **Why it's wrong**: The memory management system may have already reassigned that memory block to another part of your program or to a different application. Writing to it can corrupt data, and reading from it can yield garbage values.
*   **Returning a Pointer to a Local Variable**: A function's local variables exist on the stack and are destroyed when the function returns. Returning a pointer to such a variable creates a dangling pointer. **Why it's wrong**: The caller receives a pointer to a memory address that is no longer valid. Any attempt to use it will result in undefined behavior.
*   **Incorrect Macro Definitions**: Defining a macro like `#define SQUARE(x) x*x` can lead to incorrect results due to operator precedence. For example, `SQUARE(a+b)` expands to `a+b*a+b`, not `(a+b)*(a+b)`. **Why it's wrong**: The preprocessor performs simple text substitution without understanding C's rules. Always wrap macro parameters and the entire macro body in parentheses: `#define SQUARE(x) ((x)*(x))`.
*   **Not Checking the Return Value of `fopen()`**: The `fopen()` function returns `NULL` if it fails to open a file (e.g., file not found, no permissions). Proceeding to use this `NULL` pointer with functions like `fgets()` or `fclose()` will cause a crash. **Why it's wrong**: It's a specific case of dereferencing a `NULL` pointer. Robust code must always verify that the file was opened successfully before attempting to use the file handle.

#### **5. Examples**

##### **5.1. Basic Pointer Manipulation**
**Question:** Write a C program that declares an integer `x` with a value of 100. Declare a pointer `p`, make it point to `x`, and then use the pointer to change the value of `x` to 200. Print the final value of `x`.
<details>
<summary>Click to see the solution</summary>

```c
#include <stdio.h>

int main() {
    // 1. Declare an integer and a pointer.
    int x;
    int *p;

    // 2. Initialize the integer and make the pointer point to it.
    x = 100;
    p = &x; // Assign the address of x to p

    // 3. Use the pointer to modify the value.
    // *p accesses the value at the address p is holding.
    *p = 200;

    // 4. Print the result.
    printf("The final value of x is: %d\n", x);

    return 0;
}
```

**Answer:** The program will print **`The final value of x is: 200`**.

</details>

##### **5.2. Dynamic Memory Allocation**
**Question:** Write a C program to dynamically allocate memory for an integer, assign it the value 42, print the value, and then free the memory.
<details>
<summary>Click to see the solution</summary>

```c
#include <stdio.h>
#include <stdlib.h> // Required for malloc() and free()

int main() {
    // 1. Declare a pointer to hold the address of the dynamic memory.
    int *ptr;

    // 2. Allocate memory for one integer using malloc().
    // sizeof(int) ensures portability.
    ptr = (int *)malloc(sizeof(int));

    // 3. Check if malloc() was successful.
    if (ptr == NULL) {
        printf("Memory allocation failed!\n");
        return 1; // Exit with an error code
    }

    // 4. Assign a value to the allocated memory.
    *ptr = 42;

    // 5. Print the value.
    printf("Value in dynamically allocated memory: %d\n", *ptr);

    // 6. Free the allocated memory to prevent a leak.
    free(ptr);
    ptr = NULL; // Good practice to nullify pointer after freeing

    return 0;
}
```

**Answer:** The program will print **`Value in dynamically allocated memory: 42`**.

</details>

##### **5.3. Passing Pointers to Functions (Swap)**
**Question:** Create a function `swap` that takes pointers to two integers as arguments and swaps their values. Demonstrate its use in the `main` function.
<details>
<summary>Click to see the solution</summary>

```c
#include <stdio.h>

// 1. Define the swap function that accepts pointers.
void swap(int *a, int *b) {
    int temp = *a; // Store the value at address 'a'
    *a = *b;       // Put the value at address 'b' into address 'a'
    *b = temp;     // Put the stored original value into address 'b'
}

int main() {
    // 2. Initialize two integers.
    int x = 10;
    int y = 20;

    printf("Before swap: x = %d, y = %d\n", x, y);

    // 3. Call swap, passing the addresses of x and y.
    swap(&x, &y);

    printf("After swap: x = %d, y = %d\n", x, y);

    return 0;
}
```

**Answer:** The program's output will be:
**Before swap: x = 10, y = 20**
**After swap: x = 20, y = 10**

</details>

##### **5.4. Pointer to a Function**
**Question:** Create two functions, `add(int, int)` and `subtract(int, int)`. Create a pointer to a function that can point to either of them. Use the pointer to call both functions with inputs 5 and 3 and print the results.
<details>
<summary>Click to see the solution</summary>

```c
#include <stdio.h>

int add(int a, int b) {
    return a + b;
}

int subtract(int a, int b) {
    return a - b;
}

int main() {
    // 1. Declare a pointer to a function that takes two ints and returns an int.
    int (*operation)(int, int);
    int result;

    // 2. Point it to the 'add' function and call it.
    operation = &add;
    result = operation(5, 3); // or (*operation)(5, 3)
    printf("Result of addition: %d\n", result);

    // 3. Point it to the 'subtract' function and call it.
    operation = &subtract;
    result = operation(5, 3);
    printf("Result of subtraction: %d\n", result);

    return 0;
}
```

**Answer:** The output will be:
**Result of addition: 8**
**Result of subtraction: 2**

</details>

##### **5.5. Fixing a Faulty Macro**
**Question:** The following macro is intended to calculate the square of a number but fails for expressions like `SQUARE(2+3)`. Correct the macro.
`#define SQUARE(x) x*x`
<details>
<summary>Click to see the solution</summary>

1.  **Identify the problem**: The expression `SQUARE(2+3)` expands to `2+3*2+3`, which evaluates to `2 + 6 + 3 = 11` due to operator precedence, not the expected `5*5=25`.
2.  **Add parentheses around parameters**: To ensure the parameter `x` is evaluated as a single unit, wrap every instance of it in parentheses. The macro becomes `#define SQUARE(x) (x)*(x)`.
3.  **Add parentheses around the whole body**: To protect the macro from the surrounding context, wrap the entire body in parentheses.

**Corrected Macro:**
```c
#define SQUARE(x) ((x)*(x))
```

**Example Usage:**
```c
#include <stdio.h>

#define SQUARE(x) ((x)*(x))

int main() {
    int result = SQUARE(2+3);
    printf("The result is: %d\n", result); // Prints 25
    return 0;
}
```

**Answer:** The corrected macro is **`#define SQUARE(x) ((x)*(x))`**.

</details>

##### **5.6. Reading from a File**
**Question:** Write a program that creates a file named `data.txt`, writes "Hello, World!" to it, closes it, and then re-opens it for reading to print its content to the console.
<details>
<summary>Click to see the solution</summary>

```c
#include <stdio.h>

int main() {
    FILE *file_ptr;
    char buffer; // A buffer to hold the line read from the file

    // 1. Open file for writing ("w" mode).
    file_ptr = fopen("data.txt", "w");
    if (file_ptr == NULL) {
        printf("Could not create file for writing.\n");
        return 1;
    }
    
    // 2. Write to the file and close it.
    fprintf(file_ptr, "Hello, World!\n");
    fclose(file_ptr);
    printf("Wrote to data.txt successfully.\n");

    // 3. Open the same file for reading ("r" mode).
    file_ptr = fopen("data.txt", "r");
    if (file_ptr == NULL) {
        printf("Could not open file for reading.\n");
        return 1;
    }

    // 4. Read the line from the file and print it.
    if (fgets(buffer, sizeof(buffer), file_ptr) != NULL) {
        printf("Content of data.txt: %s", buffer);
    }
    
    // 5. Close the file.
    fclose(file_ptr);

    return 0;
}
```

**Answer:** The program will first print **`Wrote to data.txt successfully.`** and then **`Content of data.txt: Hello, World!`**.

</details>

##### **5.7. Using an Include Guard**
**Question:** Create a header file `math_utils.h` that defines a simple `PI` constant. Protect it with an include guard to prevent multiple inclusion errors. Then, create a `main.c` file that includes it twice to show the guard works.
<details>
<summary>Click to see the solution</summary>

**Step 1: Create `math_utils.h`**
```c
// math_utils.h

// 1. The include guard starts here.
#ifndef MATH_UTILS_H
#define MATH_UTILS_H

// 2. The actual content of the header file.
#define PI 3.14159

// 3. The include guard ends here.
#endif // MATH_UTILS_H
```

**Step 2: Create `main.c`**
```c
// main.c
#include <stdio.h>

// 4. Include the header file the first time.
// The preprocessor sees that MATH_UTILS_H is not defined,
// defines it, and includes the content.
#include "math_utils.h"

// 5. Include the header file the second time.
// The preprocessor sees that MATH_UTILS_H is now defined,
// so it skips the content between #ifndef and #endif.
#include "math_utils.h"

int main() {
    printf("The value of PI is: %f\n", PI);
    return 0;
}
```

**Explanation:** Without the include guard, the preprocessor would try to `#define PI` twice, causing a compilation error. With the guard, the second `#include` does nothing, and the program compiles and runs correctly.

**Answer:** The program will compile successfully and print **`The value of PI is: 3.141590`**.

</details>