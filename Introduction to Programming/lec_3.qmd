---
title: "3. Pointers, Declarations, Preprocessing, and File I/O in C"
author: "Zakhar Podyakov"
date: "September 18, 2025"
format: html
engine: knitr
---

{{< video lec_3.mp4 >}}

[Quiz](https://notebooklm.google.com/notebook/75225fb6-1a48-403e-9915-9d6a13e235e8?artifactId=fa65ba46-1add-46ba-a3bf-cd41d72dbd71) | [Flashcards](https://notebooklm.google.com/notebook/75225fb6-1a48-403e-9915-9d6a13e235e8?artifactId=fd8509c1-a167-4239-8e93-88ca1e684017)

#### **1. Summary**

##### **1.1 The C Memory Model: Stack, Heap, and Global Storage**

To understand pointers and variables in C, it's crucial to know how a program organizes its memory. A C program typically divides memory into three main regions:

1.  **Global (or Static) Storage Area**: This area holds **global variables** (declared outside any function) and **static variables** (declared with the `static` keyword). These objects are created when the program starts and exist for the entire duration of the program's execution. They have a fixed, known memory address.
2.  **The Stack**: The stack is a region of memory used for managing function calls. When a function is called, a new *stack frame* is created. This frame holds all the function's **local variables** (also called *automatic variables*), its parameters, and the return address. The stack operates on a Last-In, First-Out (LIFO) basis. When a function returns, its stack frame is destroyed, and all its local variables cease to exist. This process is managed automatically by the compiler.
3.  **The Heap**: The heap is a large pool of memory available for use during the program's execution. Unlike the stack, the heap's memory is not managed automatically. The programmer must explicitly request memory from the heap and is responsible for releasing it once it's no longer needed. This is known as **dynamic memory allocation** and is used for creating objects whose size or lifetime is not known at compile time.

<!-- DIAGRAM HERE -->

##### **1.2 Pointers: The Foundation**

A **pointer** is a special type of variable that does not hold data directly but instead holds the *memory address* of another variable. It "points to" the location where the actual data is stored. This mechanism allows for powerful features like dynamic memory management and efficient manipulation of arrays and data structures.

The two fundamental pointer operators are:

*   **Address-of operator (`&`)**: When placed before a variable name, it returns the memory address of that variable. For example, `&my_var` gives the address where `my_var` is stored.
*   **Dereference operator (`*`)**: When placed before a pointer variable, it accesses the value stored at the memory address the pointer is holding. For instance, if `p` holds the address of `my_var`, then `*p` is equivalent to `my_var` itself.

##### **1.3 Pointer Arithmetic and Arrays**

In C, pointers and arrays are intimately related. An array's name, when used in an expression, is treated as a *constant pointer* to its first element. This means `array` is equivalent to `&array[0]`.

This relationship enables **pointer arithmetic**, which allows you to perform mathematical operations on pointer addresses. When you add an integer `n` to a pointer `p`, the result is not `p + n` bytes. Instead, the address is advanced by `n * sizeof(type)`, where `type` is the data type the pointer points to. This makes it easy to navigate through arrays.

*   `p + i`: Points to the i-th element after the one `p` currently points to.
*   `*(p + i)`: Is equivalent to accessing the array element `p[i]`.
*   `p++`: Increments the pointer to point to the next element in memory.

Because of this, the C standard defines the array subscript operation `E1[E2]` as being identical to `(*((E1)+(E2)))`. Since addition is commutative, this means `*(E1+E2)` is the same as `*(E2+E1)`, which leads to the surprising but valid syntax `E2[E1]`. For example, if `arr` is an array, `arr[5]` is the same as `5[arr]`.

##### **1.4 Dynamic Memory Management**

Dynamic memory is allocated on the **heap** using functions from the `<stdlib.h>` library.

1.  **Allocation (`malloc`)**: The `malloc` function reserves a block of memory.
    *   It takes one argument: the number of bytes to allocate. The `sizeof` operator is essential here to ensure portability and correctness (e.g., `malloc(10 * sizeof(int))` for an array of 10 integers).
    *   It returns a generic pointer of type `void*` to the first byte of the allocated block. If allocation fails (e.g., the system is out of memory), it returns `NULL`.
    *   This `void*` must be **cast** to the appropriate pointer type (e.g., `int*`) before it can be used, to inform the compiler how to interpret the data and perform correct pointer arithmetic.
2.  **Deallocation (`free`)**: The `free` function releases a block of dynamically allocated memory back to the heap.
    *   It takes a single argument: the pointer that was returned by `malloc`.
    *   It is the **programmer's absolute responsibility** to call `free` for every `malloc`. Failure to do so results in a **memory leak**.

<!-- DIAGRAM HERE -->

##### **1.5 Common Pointer Pitfalls**

Pointers are powerful but introduce risks if not managed carefully. Scott Meyer identified several common categories of pointer problems:

*   **Ownership and Destruction**: A pointer itself doesn't carry information about who is responsible for freeing the memory it points to. This can lead to **memory leaks** (if no one frees the memory) or **double frees** (if multiple parts of the code try to free it), which can corrupt the heap.
*   **Dangling Pointers**: A **dangling pointer** is a pointer that refers to a memory location that has already been deallocated with `free`. Using (dereferencing) a dangling pointer results in *undefined behavior*, as that memory may now contain garbage or be in use by another part of the program.
*   **Pointer vs. Array Ambiguity**: A pointer of type `T*` can point either to a single object or to the first element of an array of objects. The language itself provides no way to know which it is, or the size of the array, from the pointer alone.
*   **Uninitialized Pointers**: A pointer that has been declared but not assigned a valid address contains a garbage value. Dereferencing it will access a random memory location, almost always leading to a crash.

##### **1.6 C Declarations**

A **declaration** introduces an identifier (like a variable or function name) and specifies its properties. A declaration can contain up to four parts: a **storage class** (`static`), a **type specifier** (`int`), an **entity name** (`a`), and an **initializer** (`= 1`).

C's declaration syntax is famously complex because it follows the rule "declaration follows use." This means the declaration mimics how the identifier would be used in an expression.

*   `int *p;`: "*p gives an int," so `p` is a pointer to an `int`.
*   `int arr[10];`: "arr[i] gives an int," so `arr` is an array of 10 ints.
*   `void (*f)(int);`: "*f called with an int gives void," so `f` is a **pointer to a function** that takes an `int` parameter and returns `void`.

The `typedef` keyword allows you to create an alias for a data type, which is invaluable for simplifying complex declarations and improving code readability. For instance, `typedef int (*MathFunc)(int, int);` creates a type `MathFunc` for a pointer to a function that takes two integers and returns one.

<!-- DIAGRAM HERE -->

##### **1.7 The C Preprocessor**

The C preprocessor is a text-processing tool that runs *before* the compiler. It scans the source code for lines beginning with `#`, known as **preprocessor directives**.

*   `#include <filename>` or `#include "filename"`: Replaces this line with the content of the specified header file.
*   `#define MACRO_NAME value`: Defines a **macro**. The preprocessor will replace every subsequent occurrence of `MACRO_NAME` with `value`. Function-like macros with parameters are also possible, but they are a common source of bugs if not written carefully (parameters and the body should always be enclosed in parentheses).
*   **Conditional Compilation**: Directives like `#if`, `#ifdef`, `#ifndef`, `#else`, and `#endif` allow blocks of code to be included or excluded from compilation based on a condition. Their most important use is creating **include guards** in header files to prevent errors from multiple inclusions. An include guard typically looks like this:
    ```c
    #ifndef MY_HEADER_H
    #define MY_HEADER_H
    // ... header content ...
    #endif
    ```

<!-- DIAGRAM HERE -->

##### **1.8 File I/O in C**

File Input/Output (I/O) in C is handled by a set of standard library functions declared in `<stdio.h>`. Operations are performed on **streams**, which are represented by a `FILE*` pointer, also known as a **file handle**.

The standard workflow is:

1.  **Open**: Use `fopen("filename", "mode")` to open a file. The **mode** string specifies the operation:
    *   `"r"`: Read text.
    *   `"w"`: Write text (discards existing content).
    *   `"a"`: Append text.
    *   `"rb"`, `"wb"`, `"ab"`: Corresponding operations for binary files.
    *   `"r+"`, `"w+"`, `"a+"`: Update modes (both reading and writing).
    `fopen` returns a `FILE*` on success or `NULL` on failure. Always check for `NULL`.
2.  **Read/Write**: Use functions like `fprintf`, `fscanf`, `fgetc`, `fputc`, `fgets`, `fputs`, `fread`, and `fwrite` to interact with the file.
3.  **Close**: Use `fclose(file_handle)` to close the stream. This flushes any buffered data to the disk and releases system resources. Failing to close a file can lead to data loss.

#### **2. Definitions**

*   **Pointer**: A variable that stores the memory address of another object.
*   **Dereferencing**: The action of accessing the value stored at the memory address pointed to by a pointer, using the `*` operator.
*   **Pointer Arithmetic**: Performing arithmetic operations (like addition or subtraction) on a pointer, which scales the result by the size of the pointed-to data type.
*   **Dynamic Memory Allocation**: The process of requesting and managing memory on the heap at runtime using functions like `malloc()` and `free()`.
*   **Heap**: A region of a program's memory used for dynamic allocation.
*   **Stack**: A region of memory used to store local variables and manage function calls in a Last-In, First-Out (LIFO) manner.
*   **Memory Leak**: A situation where dynamically allocated memory is no longer needed but is not deallocated, making it unusable for the program's lifetime.
*   **Dangling Pointer**: A pointer that refers to a memory location that has been freed or is otherwise no longer valid.
*   **Preprocessor**: A program that processes source code before compilation, performing tasks like file inclusion, macro expansion, and conditional compilation.
*   **Macro**: An identifier defined with `#define` that is replaced by its corresponding value or code block by the preprocessor.
*   **Include Guard**: A preprocessor construct used in header files to prevent their content from being included more than once in a single compilation unit.
*   **Typedef**: A keyword used to create a synonym or alias for an existing data type.
*   **File Handle**: A pointer to a `FILE` structure (`FILE*`), which represents an open file stream and holds information needed to manage it.

#### **4. Mistakes**

*   **Dereferencing an Uninitialized or NULL Pointer**: Attempting to access memory via a pointer that hasn't been assigned a valid address (`*p`) will read from or write to an arbitrary, invalid memory location, typically causing a segmentation fault. **Why it's wrong**: It's an attempt to access memory that the program does not own or that is not meaningful.
*   **Forgetting to Free Dynamically Allocated Memory**: If you allocate memory with `malloc()` but do not release it with `free()` when it is no longer needed, you create a memory leak. **Why it's wrong**: Over time, memory leaks consume available system memory, which can degrade performance and eventually crash the program or the entire system.
*   **Using a Pointer After `free()`**: This is a classic dangling pointer error. After `free(p)` is called, the memory `p` points to is invalid. **Why it's wrong**: The memory manager may have already reassigned that memory block. Writing to it can silently corrupt unrelated data, leading to bugs that are extremely difficult to diagnose.
*   **Returning a Pointer to a Local Variable**: A function's local variables are created on the stack and are destroyed when the function returns. Returning a pointer to such a variable is a serious error. **Why it's wrong**: The caller receives a dangling pointer to a memory location that is no longer valid. Any attempt to use it will result in undefined behavior.
*   **Incorrect Macro Definitions**: Defining a macro like `#define MAX(a,b) a>b?a:b` can lead to incorrect results due to operator precedence when used with complex expressions. **Why it's wrong**: The preprocessor performs simple text substitution. Always wrap macro parameters and the entire macro body in parentheses to ensure correct evaluation: `#define MAX(a,b) (((a)>(b))?(a):(b))`.
*   **Not Checking the Return Value of `fopen()` and `malloc()`**: Both `fopen()` and `malloc()` return `NULL` to signal failure. Proceeding to use this `NULL` pointer will cause a program crash. **Why it's wrong**: It's a specific case of dereferencing a `NULL` pointer. Robust code must always check the return values of functions that can fail before using the results.

#### **5. Examples**

##### **5.1. Basic Pointer Manipulation**
**Question:** Write a C program that declares an integer `x` with a value of 100. Declare a pointer `p`, make it point to `x`, and then use the pointer to change the value of `x` to 200. Print the final value of `x`.
<details>
<summary>Click to see the solution</summary>

```c
#include <stdio.h>

int main() {
    // 1. Declare an integer and a pointer.
    int x;
    int *p;

    // 2. Initialize the integer and make the pointer point to it.
    x = 100;
    p = &x; // Assign the address of x to p

    // 3. Use the pointer to modify the value.
    // *p accesses the value at the address p is holding.
    *p = 200;

    // 4. Print the result.
    printf("The final value of x is: %d\n", x);

    return 0;
}
```

**Answer:** The program will print **`The final value of x is: 200`**.

</details>

##### **5.2. Dynamic Memory Allocation for an Array**
**Question:** Write a C program to dynamically allocate memory for an array of 5 integers, fill it with the first 5 multiples of 10, print the array, and then free the memory.
<details>
<summary>Click to see the solution</summary>

```c
#include <stdio.h>
#include <stdlib.h> // Required for malloc() and free()

int main() {
    // 1. Declare a pointer to hold the base address of the array.
    int *arr;
    int n = 5;

    // 2. Allocate memory for 5 integers using malloc().
    arr = (int *)malloc(n * sizeof(int));

    // 3. Check if malloc() was successful.
    if (arr == NULL) {
        printf("Memory allocation failed!\n");
        return 1; // Exit with an error code
    }

    // 4. Fill the array using pointer arithmetic or array syntax.
    for (int i = 0; i < n; i++) {
        arr[i] = (i + 1) * 10;
    }

    // 5. Print the array's content.
    printf("Array values: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");

    // 6. Free the allocated memory to prevent a leak.
    free(arr);
    arr = NULL; // Good practice to nullify pointer after freeing

    return 0;
}
```

**Answer:** The program will print **`Array values: 10 20 30 40 50`**.

</details>

##### **5.3. Passing Pointers to Functions (Swap)**
**Question:** Create a function `swap` that takes pointers to two integers as arguments and swaps their values. Demonstrate its use in the `main` function.
<details>
<summary>Click to see the solution</summary>

```c
#include <stdio.h>

// 1. Define the swap function that accepts pointers.
void swap(int *a, int *b) {
    int temp = *a; // Store the value at address 'a'
    *a = *b;       // Put the value at address 'b' into address 'a'
    *b = temp;     // Put the stored original value into address 'b'
}

int main() {
    // 2. Initialize two integers.
    int x = 10;
    int y = 20;

    printf("Before swap: x = %d, y = %d\n", x, y);

    // 3. Call swap, passing the addresses of x and y.
    swap(&x, &y);

    printf("After swap: x = %d, y = %d\n", x, y);

    return 0;
}
```

**Answer:** The program's output will be:
**Before swap: x = 10, y = 20**
**After swap: x = 20, y = 10**

</details>

##### **5.4. Pointer to a Function**
**Question:** Create two functions, `add(int, int)` and `subtract(int, int)`. Create a pointer to a function that can point to either of them. Use the pointer to call both functions with inputs 5 and 3 and print the results.
<details>
<summary>Click to see the solution</summary>

```c
#include <stdio.h>

int add(int a, int b) {
    return a + b;
}

int subtract(int a, int b) {
    return a - b;
}

int main() {
    // 1. Declare a pointer to a function that takes two ints and returns an int.
    int (*operation)(int, int);
    int result;

    // 2. Point it to the 'add' function and call it.
    operation = &add;
    result = operation(5, 3); // or (*operation)(5, 3)
    printf("Result of addition: %d\n", result);

    // 3. Point it to the 'subtract' function and call it.
    operation = &subtract;
    result = operation(5, 3);
    printf("Result of subtraction: %d\n", result);

    return 0;
}
```

**Answer:** The output will be:
**Result of addition: 8**
**Result of subtraction: 2**

</details>

##### **5.5. Fixing a Faulty Macro**
**Question:** The following macro is intended to calculate the square of a number but fails for expressions like `SQUARE(2+3)`. Correct the macro.
`#define SQUARE(x) x*x`
<details>
<summary>Click to see the solution</summary>

1.  **Identify the problem**: The expression `SQUARE(2+3)` expands to `2+3*2+3`, which evaluates to `2 + 6 + 3 = 11` due to operator precedence, not the expected `5*5=25`.
2.  **Add parentheses around parameters**: To ensure the parameter `x` is evaluated as a single unit, wrap every instance of it in parentheses. The macro becomes `#define SQUARE(x) (x)*(x)`.
3.  **Add parentheses around the whole body**: To protect the macro from the surrounding context when used in larger expressions, wrap the entire body in parentheses.

**Corrected Macro:**
```c
#define SQUARE(x) ((x)*(x))
```

**Example Usage:**
```c
#include <stdio.h>

#define SQUARE(x) ((x)*(x))

int main() {
    int result = SQUARE(2+3);
    printf("The result is: %d\n", result); // Prints 25
    return 0;
}
```

**Answer:** The corrected macro is **`#define SQUARE(x) ((x)*(x))`**.

</details>

##### **5.6. Reading from a File**
**Question:** Write a program that creates a file named `data.txt`, writes "Hello, World!" to it, closes it, and then re-opens it for reading to print its content to the console.
<details>
<summary>Click to see the solution</summary>

```c
#include <stdio.h>

int main() {
    FILE *file_ptr;
    char buffer; // A buffer to hold the line read from the file

    // 1. Open file for writing ("w" mode).
    file_ptr = fopen("data.txt", "w");
    if (file_ptr == NULL) {
        printf("Could not create file for writing.\n");
        return 1;
    }
    
    // 2. Write to the file and close it.
    fprintf(file_ptr, "Hello, World!\n");
    fclose(file_ptr);
    printf("Wrote to data.txt successfully.\n");

    // 3. Open the same file for reading ("r" mode).
    file_ptr = fopen("data.txt", "r");
    if (file_ptr == NULL) {
        printf("Could not open file for reading.\n");
        return 1;
    }

    // 4. Read the line from the file and print it.
    if (fgets(buffer, sizeof(buffer), file_ptr) != NULL) {
        printf("Content of data.txt: %s", buffer);
    }
    
    // 5. Close the file.
    fclose(file_ptr);

    return 0;
}
```

**Answer:** The program will first print **`Wrote to data.txt successfully.`** and then **`Content of data.txt: Hello, World!`**.

</details>

##### **5.7. Using an Include Guard**
**Question:** Create a header file `math_utils.h` that defines a simple `PI` constant. Protect it with an include guard to prevent multiple inclusion errors. Then, create a `main.c` file that includes it twice to show the guard works.
<details>
<summary>Click to see the solution</summary>

**Step 1: Create `math_utils.h`**
```c
// math_utils.h

// 1. The include guard starts here. Checks if the macro is NOT defined.
#ifndef MATH_UTILS_H
// 2. If not defined, define it now.
#define MATH_UTILS_H

// 3. The actual content of the header file.
#define PI 3.14159

// 4. The include guard ends here.
#endif // MATH_UTILS_H
```

**Step 2: Create `main.c`**
```c
// main.c
#include <stdio.h>

// 5. Include the header file the first time.
// The preprocessor sees that MATH_UTILS_H is not defined,
// so it defines it and includes the content.
#include "math_utils.h"

// 6. Include the header file the second time.
// The preprocessor sees that MATH_UTILS_H is now defined,
// so it skips the content between #ifndef and #endif.
#include "math_utils.h"

int main() {
    printf("The value of PI is: %f\n", PI);
    return 0;
}
```

**Explanation:** Without the include guard, the preprocessor would try to `#define PI` twice, causing a compilation error. With the guard, the second `#include` does nothing, and the program compiles and runs correctly.

**Answer:** The program will compile successfully and print **`The value of PI is: 3.141590`**.

</details>