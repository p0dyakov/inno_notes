---
title: "Pointers, Strings, and Arrays in C"
author: "Zakhar Podyakov"
date: "September 17, 25 25"
format: html
engine: knitr
---

#### **1. Summary**

##### **1.1 Memory, Values, and Addresses**
In computing, a program's data is stored in **memory**. It's helpful to visualize memory as a huge, single sequence of cells, much like a long row of mailboxes. Each cell has two key attributes:
1.  An **address**: This is a unique numerical identifier for the cell's location, similar to a mailbox number. Addresses are typically represented in hexadecimal format (e.g., `0x7ffc...`).
2.  A **value**: This is the actual data stored inside the cell, like the letter inside a mailbox.

Every variable you declare in a program, whether it's an integer, a character, or something more complex, occupies one or more of these memory cells. The crucial concept is to *distinguish between the address of a variable and the value it holds*. For instance, an integer variable `x` with a value of `100` might be located at memory address `0x23451`.

<!-- DIAGRAM HERE -->

##### **1.2 Pointers**
A **pointer** is a special type of variable designed to hold a *memory address* as its value. Instead of storing data like an integer or a character directly, it stores the location of *other* data. This makes pointers an incredibly powerful tool for indirect data manipulation.

A pointer is declared by specifying the type of data it will point to, followed by an asterisk (`*`). For example, `int* p;` declares a pointer `p` that is intended to hold the address of an integer.

There are two fundamental operators associated with pointers:
*   The **address-of operator (`&`)**: This is a unary operator that, when placed before a variable name, returns its memory address. For example, `&var1` gives the address where `var1` is stored.
*   The **dereference operator (`*`)**: This is also a unary operator that, when placed before a pointer variable, accesses the value *at the address the pointer is holding*. It essentially says, "go to the address stored in this pointer and get the value from there."

For example, to make a pointer `p` point to an integer `x`, you would write `p = &x;`. To then retrieve the value of `x` using the pointer `p`, you would write `*p`.

##### **1.3 Arrays**
An **array** is a data structure that stores a *fixed-size, sequential collection of elements of the same data type*. Imagine an array as a connected block of memory cells. You can access individual elements by their position, or **index**, which starts at `0`.

For example, `double balance[10];` declares an array named `balance` that can hold 10 elements of type `double`. The first element is `balance[0]` and the last is `balance[9]`.

A critical concept in C is the close relationship between arrays and pointers. *The name of an array, when used in most expressions, decays into a pointer to its first element*. This means that the expressions `balance` and `&balance[0]` are equivalent; both yield the memory address of the first element of the array.

Because of this, you can use pointer arithmetic to navigate an array. If `p` is a pointer to the first element of an array, then `*(p + i)` is equivalent to `array[i]`. It's important to note that pointer arithmetic is automatically scaled by the size of the data type. If `p` is an `int*`, `p + 1` increments the address not by 1 byte, but by `sizeof(int)` bytes to point to the next integer in memory.

##### **1.4 Strings in C**
In the C programming language, a **string** is not a built-in data type. Instead, a string is implemented as a *one-dimensional array of characters that is terminated by a special character called the **null terminator***.

The **null terminator**, represented as `\0`, is a character with the ASCII value 0. It serves as a marker to signal the end of the string. Standard library functions that work with strings (like printing or calculating length) rely on this null character to know where to stop processing.

There are two common ways to initialize a string:
1.  **As a character array**: `char greeting[] = {'H', 'e', 'l', 'l', 'o', '\0'};`. In this case, you *must explicitly include the `\0`* at the end.
2.  **As a string literal**: `char greeting[] = "Hello";`. This is the more common and convenient method. When you use double quotes, the compiler automatically allocates enough space for the characters and *appends the `\0` terminator for you*. This is why "Hello" requires an array of 6 characters, not 5.

Failure to properly null-terminate a character array will lead to undefined behavior when it is treated as a string, as functions will read past the end of the intended data into adjacent memory.

#### **2. Definitions**
*   **Pointer**: A variable that stores the memory address of another variable or a location in memory.
*   **Array**: A data structure consisting of a fixed-size, contiguous collection of elements of the same data type, accessed by an integer index.
*   **C-Style String**: A sequence of characters stored in a character array and terminated by a null character (`\0`).
*   **Null Terminator (`\0`)**: A special character with an ASCII value of zero that marks the end of a C-style string.
*   **Address-of Operator (`&`)**: A unary operator that returns the memory address of its operand (the variable it is applied to).
*   **Dereference Operator (`*`)**: A unary operator that accesses the value stored at the memory address held by a pointer. It is used to "de-reference" the pointer to get to the data it points to.
*   **Dangling Pointer**: A pointer that refers to a memory location that has already been freed or is otherwise no longer valid (e.g., pointing to a local variable that has gone out of scope).

#### **3. Mistakes**
*   **Forgetting the Null Terminator:** When manually building a string character by character in an array, it's easy to forget to add the `\0` at the end. **Why it's wrong:** Standard string functions will not know where the string ends and will continue reading into adjacent memory, causing bugs and potential crashes.
*   **Dereferencing an Uninitialized Pointer:** Declaring a pointer like `int* p;` and then immediately trying to use it like `*p = 10;`. **Why it's wrong:** The pointer `p` holds a garbage memory address. Writing to this random location corrupts memory and leads to undefined behavior. A pointer must first be assigned a valid address.
*   **Returning a Pointer to a Local Variable:** A function creates a local variable and returns its address. **Why it's wrong:** The local variable exists on the function's stack frame, which is destroyed upon the function's return. The returned pointer becomes a "dangling pointer" that points to invalid memory.
*   **Array Out-of-Bounds Access:** Trying to access an element beyond the defined size of an array, such as accessing `arr[10]` in an array declared as `int arr[10];`. **Why it's wrong:** The valid indices are 0 through 9. Accessing `arr[10]` reads from or writes to memory that is not part of the array, which can corrupt other variables or cause the program to crash.
*   **Confusing Pointer Assignment with Value Assignment:** Writing `p = q;` when you meant `*p = *q;`. **Why it's wrong:** `p = q;` makes pointer `p` point to the same memory address as pointer `q`. In contrast, `*p = *q;` copies the *value* from the location pointed to by `q` to the location pointed to by `p`. These are fundamentally different operations.
*   **Assuming `sizeof` gives the length of a string:** Using `sizeof(my_string)` to find the number of characters in a string. **Why it's wrong:** `sizeof` is a compile-time operator that returns the total memory size of the array in bytes, not the number of characters before the null terminator. To get the string length at runtime, you must use the `strlen()` function.

#### **4. Examples**

##### **4.1. Swap Two Integers using Pointers**
**Question:** Write a C function `swap` that takes pointers to two integers as arguments and swaps their values.
<details>
<summary>Click to see the solution</summary>

```c
#include <stdio.h>

void swap(int* a, int* b) {
    // 1. Declare a temporary integer variable to hold one of the values.
    int temp;

    // 2. Dereference pointer 'a' to get its value and store it in 'temp'.
    temp = *a;

    // 3. Dereference pointer 'b' to get its value, then dereference 'a' again
    //    to assign this value to the variable 'a' points to.
    *a = *b;

    // 4. Assign the value stored in 'temp' (the original value of *a) to the
    //    variable that 'b' points to.
    *b = temp;
}

int main() {
    int x = 10;
    int y = 20;
    printf("Before swap: x = %d, y = %d\n", x, y);
    swap(&x, &y); // Pass the addresses of x and y
    printf("After swap: x = %d, y = %d\n", x, y);
    return 0;
}
```

**Answer:** The function uses a temporary variable to hold the value of the first integer. It then uses the dereference operator `*` to access and modify the values at the memory addresses passed into it, effectively swapping them in the `main` function's scope.
The output will be:
Before swap: x = 10, y = 20
After swap: x = 20, y = 10

</details>

##### **4.2. Calculate String Length**
**Question:** Write a C function `my_strlen` that takes a constant character pointer (a string) and returns its length, excluding the null terminator. Do not use the standard `strlen` library function.
<details>
<summary>Click to see the solution</summary>

```c
#include <stdio.h>

int my_strlen(const char* str) {
    // 1. Initialize a counter for the length to 0.
    int length = 0;

    // 2. Use a while loop that continues as long as the character
    //    at the current pointer location is not the null terminator ('\0').
    //    The expression *(str + length) is equivalent to str[length].
    while (*(str + length) != '\0') {
        // 3. Increment the length counter for each non-null character.
        length++;
    }

    // 4. Return the final count.
    return length;
}

int main() {
    char my_string[] = "Hello, World!";
    int len = my_strlen(my_string);
    printf("The length of the string is: %d\n", len);
    return 0;
}
```

**Answer:** The function iterates through the character array using pointer arithmetic, incrementing a counter until it encounters the `\0` character. The final count is the length of the string. The output will be `19`.
The output will be:
The length of the string is: 13

</details>

##### **4.3. Reverse a String in Place**
**Question:** Write a C function that takes a character array (string) and reverses it in place using pointers.
<details>
<summary>Click to see the solution</summary>

```c
#include <stdio.h>
#include <string.h> // For strlen to find the end

void reverse_string(char* str) {
    // 1. Create two pointers. 'start' points to the beginning of the string.
    char* start = str;
    
    // 2. 'end' points to the last character of the string (before the null terminator).
    char* end = str + strlen(str) - 1;
    
    char temp;

    // 3. Loop as long as the start pointer is before the end pointer.
    while (start < end) {
        // 4. Swap the characters pointed to by 'start' and 'end'.
        temp = *start;
        *start = *end;
        *end = temp;

        // 5. Move the 'start' pointer forward and the 'end' pointer backward.
        start++;
        end--;
    }
}

int main() {
    char my_string[] = "Quarto";
    printf("Original string: %s\n", my_string);
    reverse_string(my_string);
    printf("Reversed string: %s\n", my_string);
    return 0;
}
```

**Answer:** The function uses two pointers, one at the beginning and one at the end of the string. It swaps the characters they point to and then moves the pointers toward the center until they meet or cross, effectively reversing the entire string.
The output will be:
Original string: Quarto
Reversed string: otrauQ

</details>

##### **4.4. Sum Array Elements using a Pointer**
**Question:** Write a C function that calculates the sum of all elements in an integer array using only pointer arithmetic to iterate through the array. The function should take a pointer to the first element and the size of the array.
<details>
<summary>Click to see the solution</summary>

```c
#include <stdio.h>

int sum_array(int* arr, int size) {
    // 1. Initialize a sum variable to 0.
    int sum = 0;
    
    // 2. Create a pointer 'ptr' and initialize it with the starting address of the array.
    int* ptr = arr;
    
    // 3. Create a pointer 'end' that points to the memory location just after the last element.
    //    This will serve as our loop termination condition.
    int* end = arr + size;

    // 4. Loop while the current pointer 'ptr' has not reached the 'end' pointer.
    for (; ptr < end; ptr++) {
        // 5. Dereference the current pointer to get the integer value and add it to the sum.
        sum += *ptr;
    }

    return sum;
}

int main() {
    int numbers[] = {10, 20, 30, 40, 50};
    int total = sum_array(numbers, 5);
    printf("The sum of the array elements is: %d\n", total);
    return 0;
}
```
**Answer:** The function iterates through the array by incrementing a pointer from the start of the array to one element past the end. In each iteration, it dereferences the pointer to add the current element's value to a running total.
The output will be:
The sum of the array elements is: 150

</details>

##### **4.5. Find the Maximum Value in an Array**
**Question:** Write a C function `find_max` that finds the largest integer in an array using pointers. The function should return a pointer to the element containing the maximum value.
<details>
<summary>Click to see the solution</summary>

```c
#include <stdio.h>

int* find_max(int* arr, int size) {
    // 1. Handle the edge case of an empty or invalid array.
    if (arr == NULL || size <= 0) {
        return NULL;
    }

    // 2. Create a pointer to hold the address of the maximum element found so far.
    //    Initialize it to point to the first element of the array.
    int* max_ptr = arr;
    
    // 3. Loop through the array from the second element to the end.
    for (int i = 1; i < size; i++) {
        // 4. Compare the value at the current position (arr[i]) with the value
        //    at the current maximum's position (*max_ptr).
        if (arr[i] > *max_ptr) {
            // 5. If the current element is larger, update max_ptr to point to it.
            max_ptr = &arr[i];
        }
    }

    // 6. Return the pointer to the largest element.
    return max_ptr;
}

int main() {
    int numbers[] = {1, 99, 23, 56, 88};
    int* max_element_ptr = find_max(numbers, 5);
    
    if (max_element_ptr != NULL) {
        printf("The maximum value in the array is: %d\n", *max_element_ptr);
    }
    
    return 0;
}
```

**Answer:** The function assumes the first element is the maximum, then iterates through the rest of the array. If it finds a larger element, it updates its `max_ptr` to point to that new maximum element. It returns the final pointer.
The output will be:
The maximum value in the array is: 99

</details>

##### **4.6. Concatenate Two Strings**
**Question:** Write a C function `my_strcat` that appends the source string to the end of the destination string. Assume the destination array has enough space. The function should return a pointer to the destination string.
<details>
<summary>Click to see the solution</summary>

```c
#include <stdio.h>

char* my_strcat(char* dest, const char* src) {
    // 1. Create a pointer to the start of the destination string to return later.
    char* ptr = dest;

    // 2. Move the pointer 'dest' to the end of the destination string.
    //    The loop stops when it finds the null terminator.
    while (*dest != '\0') {
        dest++;
    }

    // 3. Copy characters from the source 'src' to the destination 'dest'
    //    until the null terminator of the source is reached.
    while (*src != '\0') {
        *dest = *src;
        dest++;
        src++;
    }

    // 4. Add the null terminator to the end of the newly combined string.
    *dest = '\0';

    // 5. Return the original starting address of the destination string.
    return ptr;
}

int main() {
    char str1 = "Hello, ";
    char str2[] = "World!";
    
    printf("String 1 before: %s\n", str1);
    my_strcat(str1, str2);
    printf("String 1 after: %s\n", str1);
    
    return 0;
}
```

**Answer:** The function first finds the end of the `dest` string by locating its null terminator. Then, it copies characters one by one from the `src` string to the end of the `dest` string. Finally, it adds a new null terminator to mark the end of the concatenated string.
The output will be:
String 1 before: Hello, 
String 1 after: Hello, World!

</details>

##### **4.7. Initialize and Print a 2D Array using Pointers**
**Question:** Declare a 2x3 integer array. Write a function that takes a pointer to this 2D array, its number of rows, and its number of columns to initialize it with sequential numbers. Write another function to print it using pointer notation.
<details>
<summary>Click to see the solution</summary>

```c
#include <stdio.h>

// Note the function parameter: int (*arr) is a pointer to an array of 3 integers.
void initialize_array(int (*arr), int rows, int cols) {
    int count = 1;
    // 1. Iterate through each row.
    for (int i = 0; i < rows; i++) {
        // 2. Iterate through each column in the current row.
        for (int j = 0; j < cols; j++) {
            // 3. Use pointer notation to access the element.
            //    arr[i] is the i-th array (row).
            //    *(arr + i) is also a pointer to the i-th row.
            //    *(*(arr + i) + j) is the element at row i, col j.
            *(*(arr + i) + j) = count++;
        }
    }
}

void print_array(int (*arr), int rows, int cols) {
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            // 4. Print the element using the same pointer notation.
            printf("%d\t", *(*(arr + i) + j));
        }
        printf("\n");
    }
}

int main() {
    int my_array;
    
    initialize_array(my_array, 2, 3);
    print_array(my_array, 2, 3);
    
    return 0;
}
```

**Answer:** The key is the function signature `int (*arr)[3]`, which correctly declares a pointer to a complete row (an array of 3 integers). Inside the functions, the expression `*(*(arr + i) + j)` is used. `arr + i` moves the pointer to the `i`-th row, `*(arr + i)` dereferences it to get a pointer to the first element of that row, and adding `j` moves it to the `j`-th column. The final dereference `*` gets the value.
The output will be:
1       2       3
4       5       6

</details>