---
title: "2. FPGA Project Workflow in Quartus Prime, Fundamental Ideas of Computer Architecture"
author: "Zakhar Podyakov"
date: "September 16, 2025"
format: html
---

#### 1. Summary

This document outlines the foundational principles of computer architecture and provides a practical guide to implementing a basic project on a Field-Programmable Gate Array (FPGA) using Intel's Quartus Prime software.

##### 1.1 Fundamental Ideas of Computer Architecture
Computer architecture is built upon several key concepts that govern how systems are designed for performance, reliability, and efficiency.

1.  **Hierarchy of Memories**: Computer systems use a tiered memory structure. At the top are the fastest, smallest, and most expensive memories like **CPU registers** and **caches (L1, L2, etc.)**. As you move down the hierarchy to **System Memory (RAM)** and finally to **Storage Devices (SSDs, HDDs)**, the memory becomes larger, slower, and less costly per byte. This design works because processors frequently access a small subset of data, which can be kept in faster memory (*caching*) to improve performance.
2.  **Design Simplification via Abstraction**: Complex systems like a CPU are designed in layers of abstraction. At the highest level, we might see a single "CPU" block. At a lower level, this is broken into a **Control Unit (CU)**, an **Arithmetic Logic Unit (ALU)**, and **Registers**. At the lowest level, these are composed of millions of individual logic gates. Abstraction allows designers to work on one part of the system without needing to understand the intricate details of all other parts.
3.  **Moore's Law for CPU Performance**: Historically, **Moore's Law** stated that the number of transistors on a chip would double approximately every two years, leading to exponential growth in processing power. While the growth in transistor count continues, *CPU clock speed has stagnated since the mid-2000s* due to heat dissipation problems.
4.  **Performance via Parallelism**: To overcome the limits of single-core speed, modern performance gains are achieved through **parallelism**â€”using multiple processors or cores to execute multiple instructions or programs simultaneously. This is distinct from concurrency and requires careful management of tasks.
5.  **Performance via Pipelining**: **Pipelining** is a technique used within a single processor to improve throughput. It breaks down the execution of an instruction into sequential stages (e.g., Fetch, Decode, Execute, Write Back). The processor can work on different stages of multiple instructions at the same time, much like an assembly line.
6.  **Performance via Speculation (Prediction)**: To keep a pipeline full and avoid stalls, modern processors use **branch prediction** to guess the outcome of a conditional operation (e.g., an `if` statement) before it's fully calculated. If the guess is correct, time is saved. If not, the pipeline is flushed, and the correct path is taken, incurring a small penalty.
7.  **Dependability via Redundancy**: Critical systems, such as those in spacecraft or servers, achieve high reliability by including **redundant** or "spare" components. If a primary CPU or memory module fails, a backup can take over, preventing system failure.
8.  **Make the Common Case Fast**: This design principle, central to both hardware and software, dictates that resources should be optimized for the most frequent operations. For example, CPU caches store frequently accessed data because most programs exhibit *locality of reference*.
9.  **Finite State Machines (FSM)**: An **FSM** is a mathematical model of computation used to design digital logic and computer programs. It consists of a finite number of states and transitions between those states, providing a structured way to model system behavior in response to inputs.

##### 1.2 FPGA Project Workflow in Quartus Prime
Creating a hardware design on an FPGA involves a structured workflow within a specialized software environment like Quartus Prime.

1.  **Project Creation**: The process begins with the **New Project Wizard**, where you define the project name, directory, and top-level design entity.
2.  **Device Specification**: It is crucial to select the correct FPGA device model. For the **DE10-Lite** board, the device is an Altera **MAX 10** with the part number `10M50DAF484C7G`. Selecting the wrong device will cause the project to fail.
3.  **Design Entry**: The hardware logic is created using a **Block Diagram** (schematic) or a Hardware Description Language (HDL) like Verilog or VHDL. For a simple circuit, you place components like input/output pins and logic gates (e.g., `AND`, `OR`, `NOT`) from the primitives library and connect them with wires.
4.  **First Compilation**: The initial design is **compiled**. This process synthesizes the high-level design into a low-level configuration of logic elements, checks for errors, and prepares the design for the target FPGA.
5.  **Pin Assignment**: The **Pin Planner** is used to map the logical input and output pins from your design to the physical pins on the FPGA chip. These pins are connected to external hardware like switches, LEDs, and GPIO headers. For example, on the DE10-Lite, `SW0` is connected to `PIN_C10`.
6.  **Second Compilation**: After assigning pins, the project must be **re-compiled**. This step incorporates the physical pin locations into the final design file.
7.  **Hardware Programming**: Connect the FPGA board to the computer (e.g., via USB-Blaster). Use the **Programmer** tool in Quartus to upload the generated configuration file (typically a `.sof` file) to the FPGA.
8.  **Testing**: Once the FPGA is programmed, you can test the hardware design by interacting with the physical components (e.g., flipping switches and observing LEDs) to verify its correctness.

#### 2. Definitions

*   **FPGA (Field-Programmable Gate Array)**: An integrated circuit that can be configured by a user after manufacturing. It consists of a matrix of configurable logic blocks (CLBs) connected via programmable interconnects.
*   **Quartus Prime**: A software suite by Intel for designing, synthesizing, and programming FPGAs and CPLDs.
*   **Boolean Function**: A logical function that takes one or more binary inputs (0 or 1) and produces a single binary output.
*   **Logic Gate**: A physical or abstract device that implements a Boolean function. Basic gates include AND, OR, and NOT.
*   **Pin Planner**: A tool within Quartus Prime used to assign the logical signals in a design to the physical pins of the FPGA package.
*   **Parallelism**: The simultaneous execution of multiple computations or processes, typically on different processors or cores, to increase overall throughput.
*   **Pipelining**: A technique where a single task (like executing an instruction) is broken into a series of independent stages, allowing the system to process multiple tasks concurrently by overlapping their execution in an assembly-line fashion.
*   **Moore's Law**: An observation that the number of transistors in an integrated circuit doubles about every two years. While historically linked to performance, its modern impact is more on core count and complexity rather than raw clock speed.
*   **Hierarchy of Memories**: A computer memory structure organized into levels based on speed, capacity, and cost. Faster levels (registers, cache) are smaller, while slower levels (RAM, SSD) are larger.

#### 3. Mistakes

*   **Incorrect FPGA Model Selection**: Choosing the wrong device family or part number in the Quartus project setup. **Why it's wrong**: The compiled design file will be incompatible with the physical hardware, and programming will fail. The internal architecture and pin layout differ between FPGA models.
*   **Forgetting to Re-compile After Pin Assignment**: Making changes in the Pin Planner but then immediately trying to program the device. **Why it's wrong**: The compiler needs to integrate the pin locations into the final hardware configuration file. Without re-compiling, the previously generated file (without pin assignments) will be used, and the I/O will not work.
*   **Confusing Parallelism and Pipelining**: Using the terms interchangeably. **Why it's wrong**: **Parallelism** involves using multiple, distinct processing units to handle different tasks at the same time. **Pipelining** is a technique to improve the throughput of a *single* processing unit by overlapping the stages of different tasks.
*   **Assuming Moore's Law Still Means Faster Clock Speeds**: Believing that CPU performance continues to double by increasing its clock frequency (GHz). **Why it's wrong**: Since ~2008, clock speeds have stagnated due to physical limitations like heat dissipation. Performance gains now primarily come from increasing the number of cores (parallelism) rather than making a single core faster.
*   **Connecting Wires Incorrectly in Block Diagram**: In the schematic editor, failing to ensure the mouse pointer turns into a "cross" at both the start and end points of a wire. **Why it's wrong**: This indicates that a proper connection was not made. The design might look correct visually, but the logical connection does not exist, leading to compilation errors or unexpected behavior.

#### 4. Examples

##### Example 1: Basic FPGA Logic with Switches and an LED
**Question:** Design a logic circuit in Quartus Prime for a DE10-Lite board that illuminates a single LED (LEDR0) if and only if two switches (SW0 and SW1) are both in the 'on' position. Provide the high-level steps for implementation.

<details>
<summary>Click to see the solution</summary>

1.  **Determine the Logical Operation**: The condition "if and only if two switches are both on" translates directly to a logical **AND** operation. The circuit will require two inputs (for SW0 and SW1) and one output (for LEDR0), connected through a 2-input AND gate.

2.  **Set Up the Quartus Project**:
    *   Create a new project using the New Project Wizard.
    *   In the device selection step, choose the `MAX 10` family and filter for the specific part name `10M50DAF484C7G`.

3.  **Create the Block Diagram**:
    *   Create a new Block Diagram/Schematic file (`.bdf`).
    *   From the symbol library, add two `input` pins and one `output` pin. Rename them `SW0`, `SW1`, and `LEDR0`, respectively.
    *   From the library under `primitives/logic`, add an `and2` (2-input AND gate).
    *   Use the wiring tool to connect the `SW0` and `SW1` input pins to the two inputs of the `and2` gate.
    *   Connect the output of the `and2` gate to the `LEDR0` output pin.

4.  **Compile the Design**: Run the compilation process (Processing -> Start Compilation). This will synthesize the schematic into a circuit and check for errors.

5.  **Assign Physical Pins**:
    *   Open the Pin Planner (Assignments -> Pin Planner).
    *   In the table at the bottom, find your three pins (`SW0`, `SW1`, `LEDR0`).
    *   Click in the "Location" column for each pin and enter the physical pin number corresponding to the DE10-Lite's hardware. [3, 7]
        *   For `SW0`, set the Location to `PIN_C10`.
        *   For `SW1`, set the Location to `PIN_C11`.
        *   For `LEDR0`, set the Location to `PIN_A8`.

6.  **Re-compile the Design**: After saving the pin assignments, run the compilation process again. This finalizes the design file with the correct physical connections.

7.  **Program the FPGA**:
    *   Connect the DE10-Lite board to your computer.
    *   Open the Programmer (Tools -> Programmer).
    *   Ensure "USB-Blaster" is selected as the hardware. If not, use "Hardware Setup" to add it.
    *   The compiled file (e.g., `output_files/your_project.sof`) should be listed.
    *   Click "Start" to upload the design to the FPGA. A green "100% (Successful)" message will appear on completion.

8.  **Test the Hardware**: Physically toggle the SW0 and SW1 switches on the board. The LEDR0 should only turn on when both switches are in the UP (on) position.

**Answer:** The DE10-Lite board is now programmed with the AND logic. Flipping both SW0 and SW1 to their 'on' positions will illuminate LEDR0, confirming the circuit works as designed.
</details>