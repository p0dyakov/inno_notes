---
title: "Computer Architecture, FPGA Boards"
author: "Zakhar Podyakov"
date: "September 17, 2025"
format: html
engine: knitr
---

#### **1. Summary**

##### **1.1 What is a Computer?**
A **computer** is an electronic machine designed to automatically execute a sequence of arithmetic or logical operations (a program). It processes input data based on a set of instructions and produces an output. At its core, a computer operates on binary data—strings of zeros and ones—manipulating this input to generate a binary result according to a given program.

<!-- DIAGRAM HERE -->

##### **1.2 Core Components of a Computer**
The fundamental structure of a modern computer, often referred to as its **Computer Architecture**, consists of several key components that interact to execute programs.

*   **1.2.1 CPU (Central Processing Unit)**: Often called the "brain" of the computer, the CPU is responsible for executing instructions. It is an intricate electrical circuit that performs calculations and manages the flow of information. The CPU itself is composed of smaller, specialized units:
    *   The **Arithmetic-Logic Unit (ALU)** performs all arithmetic (addition, subtraction) and logical (AND, OR, NOT) operations.
    *   The **Control Unit (CU)** directs the computer's operations. It fetches the next instruction from memory, decodes it, and coordinates the other parts of the computer to execute it.
    *   **Registers** are small, extremely fast storage locations within the CPU. They hold data that is actively being used by the CPU, such as the input arguments for an operation or its result.

*   **1.2.2 System Memory (RAM)**: Also known as **Random Access Memory**, this is the primary workspace for the computer. It stores the program instructions and data that the CPU needs to access quickly. Memory is volatile, meaning its contents are lost when the power is turned off.

*   **1.2.3 Storage Devices**: Unlike RAM, storage devices (like Solid-State Drives or SSDs) provide long-term, non-volatile storage. They hold the operating system, applications, and user files, which are loaded into RAM as needed.

*   **1.2.4 Input/Output (I/O) Devices**: These are peripheral components that allow the computer to interact with the outside world. Examples include keyboards, mice, monitors, printers, and network cards.

*   **1.2.5 Communication Bus**: The bus is a set of electrical pathways that connects all the computer's components, allowing them to exchange data. The speed of the bus is critical for overall system performance.

##### **1.3 The Memory Hierarchy**
Not all memory is created equal. To balance speed, cost, and capacity, computers use a *memory hierarchy*. Data moves between levels based on how frequently the CPU needs it.

1.  **Registers (inside the CPU)**: Fastest access, smallest capacity.
2.  **CPU Cache (L1, L2, L3)**: A small amount of very fast memory located on or very close to the CPU chip. It stores copies of frequently used data from the main memory to reduce the time it takes to access it. *L1 cache* is the fastest and smallest, embedded directly into each CPU core. Higher-level caches (*L2*, *L3*) are progressively larger and slower.
3.  **System Memory (RAM)**: Slower than cache but has a much larger capacity (e.g., gigabytes).
4.  **Storage Devices (SSD)**: Slowest access speed but offers the largest capacity (e.g., terabytes).

This hierarchy creates a performance bottleneck known as the *"memory wall problem"*, where the CPU is often idle while waiting for data to arrive from slower levels of memory. Efficiently managing this hierarchy is a key challenge in computer architecture.

<!-- DIAGRAM HERE -->

##### **1.4 Processors vs. FPGAs**
A standard **CPU** is a *general-purpose processor*. Its functionality is fixed at the time of manufacturing. It supports a specific, limited set of instructions (its **instruction set**), and this functionality cannot be changed or extended.

An **FPGA (Field-Programmable Gate Array)** is fundamentally different. It is not a processor, but rather an integrated circuit containing a matrix of configurable logic blocks and programmable interconnects.

*   **1.4.1 Key Differences**:
    *   **Programmability**: A CPU executes software instructions, but its underlying hardware is fixed. An FPGA's hardware itself can be reprogrammed many times to perform custom tasks.
    *   **Instruction Set**: A CPU has a fixed instruction set. With an FPGA, you design the logic circuits yourself, effectively creating a custom set of instructions tailored precisely to your needs.
    *   **Speed & Efficiency**: For general tasks, a CPU is efficient. For highly specific, parallelizable tasks (like real-time signal processing), a custom circuit on an FPGA can be significantly faster because the hardware is built for that one job.
    *   **Cost and Power**: FPGAs are generally more expensive and consume more power than general-purpose processors.

*   **1.4.2 Use Cases for FPGAs**: FPGAs are often used for prototyping and testing new processor designs before committing to expensive mass manufacturing. They are also ideal for tasks that require massive parallelism and low latency, such as in telecommunications, scientific instruments, and high-frequency trading.

##### **1.5 FPGA Programming and Boards**
FPGAs are programmed using a **Hardware Description Language (HDL)**, such as **Verilog** or **VHDL**. These are not traditional programming languages; instead, they describe the structure and behavior of digital logic circuits. Software like **Intel Quartus Prime** is used to synthesize this HDL code into a configuration file that is then loaded onto the FPGA to implement the desired hardware design.

Educational FPGA boards, like the **DE10-Lite**, come equipped with an FPGA chip and various I/O devices (LEDs, push buttons, switches, displays, sensors) that allow students to design and test real-world digital circuits.

#### **2. Definitions**

*   **Computer**: An electronic device that processes data by executing a sequence of instructions defined in a program.
*   **Computer Architecture**: The fundamental design and operational structure of a computer system, detailing how its hardware components (CPU, memory, I/O) are organized and interact.
*   **CPU (Central Processing Unit)**: The primary component of a computer that executes program instructions and performs arithmetic, logic, and control operations.
*   **ALU (Arithmetic-Logic Unit)**: A digital circuit within the CPU that performs integer arithmetic (add, subtract) and bitwise logic operations (AND, OR, NOT).
*   **CU (Control Unit)**: The component of the CPU that directs the operation of the processor by interpreting instructions and generating control signals for other components.
*   **Register**: A small, high-speed storage location directly within the CPU used to hold data and instructions temporarily during processing.
*   **System Memory (RAM)**: Volatile computer memory that stores data and machine code currently being used. It allows for fast read and write access.
*   **CPU Cache**: A small, fast volatile memory, located closer to the CPU core, that stores copies of frequently used data from main memory to improve access times.
*   **Memory Hierarchy**: A structure that uses a hierarchy of memory and storage devices with different performance characteristics to optimize data access and balance cost, speed, and capacity.
*   **FPGA (Field-Programmable Gate Array)**: An integrated circuit that can be configured by a user after manufacturing, allowing the hardware logic itself to be reprogrammed.
*   **Verilog HDL**: A hardware description language used to model electronic systems, most commonly for designing and verifying digital circuits at the register-transfer level of abstraction.
*   **Instruction Set**: The specific set of commands that a particular CPU can recognize and execute, defined by the processor's architecture.

#### **3. Mistakes**

*   **Confusing an FPGA with a CPU**: Treating an FPGA as just a "faster CPU." **Why it's wrong:** They are fundamentally different. A CPU is a fixed-function processor that runs software instructions, while an FPGA is a blank slate of configurable hardware logic. An FPGA is not inherently faster; it's only faster for tasks that can be efficiently implemented in custom, parallel hardware.
*   **Assuming FPGAs are always the better choice for performance**: Believing an FPGA will outperform a CPU on any task. **Why it's wrong:** For general-purpose computing (like running an operating system or a web browser), CPUs are far more efficient due to their specialized architecture and rich instruction sets. FPGAs excel only in very specific, often parallel, applications.
*   **Ignoring the Memory Hierarchy**: Writing code without considering how data moves between the CPU cache and main memory. **Why it's wrong:** The "memory wall"—the large speed gap between the CPU and RAM—is a primary performance bottleneck. Programs that access memory randomly and without locality of reference will perform poorly, as the CPU will constantly stall while waiting for data.
*   **Treating Verilog like a software programming language**: Writing Verilog code sequentially, as one would in Python or C, and expecting it to execute line by line. **Why it's wrong:** Verilog is a hardware description language. It describes physical circuits that operate in parallel. A misunderstanding of this core concept leads to designs that don't synthesize into working hardware or behave unexpectedly.
*   **Believing a processor's functionality can be changed with software**: Thinking you can add new hardware-level instructions to a CPU through a software update. **Why it's wrong:** A CPU's instruction set is physically etched into its silicon circuits during manufacturing and cannot be altered. While software can emulate new functionality, the underlying hardware capabilities remain fixed.

#### **4. Examples**

##### **4.1 Simple Logic in Verilog**
**Question:** Write a Verilog module that implements a simple AND gate. It should take two single-bit inputs, `a` and `b`, and produce one single-bit output, `y`.

<details>
<summary>Click to see the solution</summary>

1.  **Define the module:** Start by declaring a module with a name (e.g., `simple_and`) and list its input and output ports.
    ```verilog
    module simple_and(
        input  logic a,
        input  logic b,
        output logic y
    );
    ```
2.  **Assign the logic:** Use a continuous `assign` statement to describe the relationship between the inputs and the output. The `&` operator performs a bitwise AND operation.
    ```verilog
    assign y = a & b;
    ```
3.  **End the module:** Close the module definition.
    ```verilog
    endmodule
    ```

**Answer:** The complete Verilog module is:
```verilog
module simple_and(
    input  logic a,
    input  logic b,
    output logic y
);

assign y = a & b;

endmodule
```
</details>

##### **4.2 Controlling an LED with a Switch**
**Question:** On an FPGA board like the DE10-Lite, you have a switch (`SW0`) and an LED (`LED0`). Write a Verilog module to make the LED turn on when the switch is on, and turn off when the switch is off.

<details>
<summary>Click to see the solution</summary>

1.  **Define the module and ports:** Create a module named `led_control` with one input for the switch and one output for the LED.
    ```verilog
    module led_control(
        input  logic SW0,
        output logic LED0
    );
    ```
2.  **Connect the switch to the LED:** The simplest way to achieve this is to directly connect the input to the output. An `assign` statement creates a "wire" between the two.
    ```verilog
    assign LED0 = SW0;
    ```
3.  **End the module:** Close the module definition.
    ```verilog
    endmodule
    ```
**Answer:** The Verilog module directly connects the switch's state to the LED's state:
```verilog
module led_control(
    input  logic SW0,
    output logic LED0
);

assign LED0 = SW0;

endmodule
```
</details>

##### **4.3 CPU vs. FPGA Application Choice**
**Question:** You are designing a system for real-time video encoding that needs to process 4K video at 60 frames per second with very low latency. Would a general-purpose CPU or an FPGA be a better choice for the core processing unit? Explain why.

<details>
<summary>Click to see the solution</summary>

1.  **Analyze the task requirements:** The task involves processing a massive, continuous stream of data (4K video) with strict timing constraints (60 fps, low latency). The operations (e.g., color space conversion, compression algorithms) are highly repetitive and can be broken down into many small, parallel steps.
2.  **Evaluate the CPU's suitability:** A CPU would process the video frames using software. While powerful, it executes instructions sequentially (even with multiple cores) and has overhead from the operating system. Achieving consistent low latency for every single frame would be extremely challenging.
3.  **Evaluate the FPGA's suitability:** An FPGA can be configured to have a dedicated hardware pipeline for video processing. Multiple stages of the encoding algorithm can run simultaneously on different parts of the chip for different pixels or frames. This massive parallelism is ideal for video streams. Because it's a dedicated hardware solution, it avoids OS overhead and can guarantee consistent, low-latency processing.
**Answer:** An **FPGA** is the better choice. **Why:** Video encoding is a highly parallel task. An FPGA allows for the creation of a custom hardware pipeline where many calculations happen simultaneously, which is far more efficient and provides the low, predictable latency required for real-time processing, something a general-purpose CPU struggling with OS and other overheads cannot guarantee.
</details>

##### **4.4 Memory Hierarchy Access**
**Question:** A program is executing a `for` loop that repeatedly adds two numbers. The machine code instruction for the addition operation is currently being executed by the CPU. In which level of the memory hierarchy would you most likely find this instruction?

<details>
<summary>Click to see the solution</summary>

1.  **Consider the CPU's immediate needs:** The CPU can only execute instructions that are physically inside it.
2.  **Recall the fastest memory level:** The fastest and closest memory to the ALU and CU are the registers. The Control Unit fetches instructions from memory into a special-purpose register (often called the Instruction Register) just before decoding and execution.
3.  **Consider the role of cache:** Since the instruction is part of a loop, it's being used repeatedly. Therefore, it is almost certain to have been copied from the slower main memory (RAM) into the much faster L1 instruction cache for quick access on subsequent loop iterations.
4.  **Combine the points:** The instruction must be in a register to be executed. Given it's in a loop, it would also reside in the L1 cache to avoid fetching it from slow RAM every time. The most immediate location is a register.
**Answer:** The instruction would be found in a **CPU register** (specifically, the instruction register) at the moment of execution. A copy of it would also reside in the **L1 cache** for fast re-access during the next iteration of the loop.
</details>

##### **4.5 2-to-1 Multiplexer in Verilog**
**Question:** A 2-to-1 multiplexer (MUX) is a circuit that selects one of two inputs (`a` or `b`) to pass to the output (`y`) based on a selector signal (`sel`). If `sel` is 0, `y` should be `a`. If `sel` is 1, `y` should be `b`. Implement this in a Verilog module.

<details>
<summary>Click to see the solution</summary>

1.  **Define the module and its ports:** The module requires three inputs (`a`, `b`, `sel`) and one output (`y`).
    ```verilog
    module mux_2_to_1(
        input  logic a,
        input  logic b,
        input  logic sel,
        output logic y
    );
    ```
2.  **Implement the selection logic:** A conditional `assign` statement using the ternary operator (`? :`) is a concise way to model this. The structure is `condition ? value_if_true : value_if_false`.
    ```verilog
    assign y = (sel == 1) ? b : a;
    ```
    This line reads as: "Assign `y` the value of `b` if `sel` is 1; otherwise, assign it the value of `a`."
3.  **End the module:** Close the module definition.
    ```verilog
    endmodule
    ```
**Answer:** The complete Verilog module for a 2-to-1 MUX is:
```verilog
module mux_2_to_1(
    input  logic a,
    input  logic b,
    input  logic sel,
    output logic y
);

assign y = sel ? b : a; // A more compact way of writing (sel == 1)

endmodule
```
</details>

##### **4.6 Processor Instruction Set Limitation**
**Question:** Imagine a very simple processor whose instruction set only contains `ADD`, `SUBTRACT`, and `STORE`. You need to perform a multiplication, for example, 5 * 3. How could you accomplish this using only the available instructions?

<details>
<summary>Click to see the solution</summary>

1.  **Understand the core concept of multiplication:** Multiplication is repeated addition. For example, 5 * 3 is the same as 5 + 5 + 5.
2.  **Formulate an algorithm using available instructions:**
    *   Initialize a result variable (in a register, let's call it `R1`) to 0.
    *   Use the `ADD` instruction to add 5 to `R1`.
    *   Use the `ADD` instruction again to add 5 to `R1`. `R1` now holds 10.
    *   Use the `ADD` instruction a third time to add 5 to `R1`. `R1` now holds 15.
    *   Use the `STORE` instruction to save the value from `R1` to a memory location.
3.  **Structure the process:** This would be implemented as a software loop. The program would use the `ADD` instruction three times.
**Answer:** You can perform multiplication by implementing it as a series of additions. To calculate 5 * 3, you would write a short program that uses a loop to execute the `ADD 5` instruction three times, accumulating the result in a register.
</details>

##### **4.7 Identifying FPGA Board Components**
**Question:** You are looking at a DE10-Lite FPGA board. You see a large, square chip in the center labeled "MAX 10". What is the function of this component?

<details>
<summary>Click to see the solution</summary>
1.  **Analyze the component's description:** The chip is large, centrally located, and has a specific model name ("MAX 10").
2.  **Recall the purpose of an FPGA board:** The primary purpose of an FPGA development board is to provide a platform for programming and testing an FPGA.
3.  **Connect the information:** The central, most prominent chip on an FPGA board is almost always the FPGA itself. The "MAX 10" is a product family of FPGAs made by Altera (now Intel).
**Answer:** The chip labeled "MAX 10" is the **FPGA (Field-Programmable Gate Array)** itself. It is the main component that you program with your hardware design using a language like Verilog.
</details>