---
title: "1. Computer Architecture, CPU Principles, Memory Hierarchy, FPGA Boards"
author: "Zakhar Podyakov"
date: "September 18, 2025"
format: html
engine: knitr
---

{{< video lec_1.mp4 >}}

[Quiz](https://notebooklm.google.com/notebook/4eebeef9-a055-41cf-ab6c-653c424b8a0f?artifactId=44ab9f97-f0b3-45e2-b1b6-6230aa909643) | [Flashcards](https://notebooklm.google.com/notebook/4eebeef9-a055-41cf-ab6c-653c424b8a0f?artifactId=85482dad-351c-43dd-a3e6-25ab5ec762ba)

#### **1. Summary**

##### **1.1 What is a Computer?**
A **computer** is an electronic machine designed to automatically execute a sequence of arithmetic or logical operations based on a given program. It processes **input data** and produces an **output result**. Fundamentally, computers operate on binary data—strings of zeros and ones—manipulating this input to generate a binary output according to a predefined sequence of instructions.

<!-- DIAGRAM HERE -->

##### **1.2 The Problem Solution Stack**
Solving a problem with a computer involves multiple layers of abstraction, from the physical world to the software application. This is often visualized as a stack.

1.  **Problem to Solve**: The high-level goal.
2.  **Algorithm + Data Structures**: The conceptual solution.
3.  **User Program**: The implementation in a high-level language (e.g., C++, Python).
4.  **System Programs**: The operating system and compilers that translate the user program into machine instructions.
5.  **Processor Instruction Set Architecture (ISA)**: The specific set of low-level instructions the hardware can execute. This is the interface between hardware and software.
6.  **Microarchitecture**: The specific implementation of the ISA in hardware (e.g., how the CPU components are arranged and connected).
7.  **Logic Circuits**: The fundamental building blocks, like AND and OR gates, that implement the microarchitecture.
8.  **Electrons, Photons, etc.**: The underlying physics that makes the circuits work.

*Computer architecture* is the study of the layers from the Instruction Set Architecture down to the logic circuits, including how they interact with system software.

##### **1.3 What is Computer Architecture?**
**Computer Architecture** is a field of computer science and engineering that covers three main areas:

1.  *Hardware organization of computer systems*: How components like the CPU, memory, and I/O devices are structured and interconnected.
2.  *Hardware/Software interaction principles*: The rules and methods by which software controls the hardware, primarily through the instruction set.
3.  *Performance-related computer aspects*: Analyzing and designing systems to optimize for speed, power efficiency, and cost.

Studying architecture helps us understand how to design efficient hardware, write high-performance software, and customize computing systems for specific tasks.

##### **1.4 Core Components of a Computer**
A modern computer's architecture is built around several key interacting components.

###### **1.4.1 CPU (Central Processing Unit)**
The "brain" of the computer, the CPU executes program instructions. It is a complex electrical circuit with several key parts:

*   **Control Unit (CU)**: Fetches instructions from memory, decodes them, and directs the other components to carry them out.
*   **Arithmetic-Logic Unit (ALU)**: Performs all arithmetic (e.g., addition, subtraction) and logical (e.g., AND, OR) operations.
*   **Registers**: A small number of extremely fast memory locations located directly within the CPU. They hold data that is being actively processed, such as the arguments for an ALU operation or its result.

##### **1.4.2 The Processor Principle**
A processor operates by receiving electrical signals on its **input pins** and producing a result on its **output pins**. The inputs consist of:

*   **Instruction Code**: A binary code that tells the processor which operation to perform (e.g., `0` for logical OR, `1` for logical AND).
*   **Input Arguments**: The data values on which the operation will be performed.

The combination of the instruction code and its arguments forms a **machine instruction** (e.g., the binary string `010` could mean "OR the values 1 and 0").

##### **1.4.3 System Memory (RAM)**
**Random Access Memory** is the computer's main workspace. It stores program instructions and data for the CPU to access quickly. RAM is *volatile*, meaning its contents are lost when power is cut.

##### **1.4.4 Storage Devices**:
These provide long-term, *non-volatile* storage for the operating system, applications, and files. Examples include Solid-State Drives (SSDs) and hard disk drives (HDDs). Data is loaded from storage into RAM for execution.

##### **1.4.5 Input/Output (I/O) Devices**
Peripherals that allow the computer to interact with the world, such as keyboards, monitors, printers, and network interfaces.

##### **1.4.6 Communication Bus**
The set of electrical pathways connecting all components, allowing them to communicate and exchange data. Bus speed is a critical factor in system performance. Significant delays in data transfer between the CPU and memory lead to the *"memory wall problem,"* a key performance limitation in modern computers.

##### **1.5 The Memory Hierarchy**
To balance speed, cost, and capacity, computers organize memory in a hierarchy. Data is moved between levels based on how frequently the CPU needs it.

1.  **Registers (inside the CPU)**: Fastest access (<1 nanosecond), smallest capacity (hundreds of bytes).
2.  **CPU Cache (L1, L2, L3)**: Very fast memory on or near the CPU. It stores copies of frequently used data from RAM.
    *   **L1 Cache**: Embedded in each CPU core, fastest cache, smallest capacity (tens of kilobytes).
    *   **L2 Cache**: Slower but larger than L1.
    *   **L3 Cache (LLC - Last Level Cache)**: Shared among all CPU cores, slowest and largest cache (megabytes).
3.  **System Memory (RAM)**: Much larger capacity (gigabytes) but significantly slower than cache.
4.  **Storage Devices (SSD/HDD)**: Largest capacity (terabytes) but the slowest access speeds.

<!-- DIAGRAM HERE -->

##### **1.6 CPU Architectures and Multicore Systems**
A CPU's design is defined by its **Instruction Set Architecture (ISA)**.

###### **1.6.1 Widely-known Architectures**
*   **Intel x86 / AMD64**: Dominant in desktop and server computers (CISC - Complex Instruction Set Computer).
*   **ARM**: Dominant in mobile and embedded devices (RISC - Reduced Instruction Set Computer).
*   **RISC-V**: A modern, open-standard RISC architecture gaining popularity.
*   Others include **Baikal** and **Elbrus**.

###### **1.6.2 Multicore Systems**
Modern CPUs are **multicore processors**, meaning a single chip contains multiple independent processing units (cores). Each core has its own ALU, CU, and L1 cache, while typically sharing an L3 cache and main memory. This allows for parallel execution of tasks but introduces challenges in coordinating, or **scheduling**, work across the cores.

##### **1.7 Processors vs. FPGAs**
A standard **CPU** is a *general-purpose processor* with a fixed, unchangeable hardware design. An **FPGA (Field-Programmable Gate Array)** is an integrated circuit containing a grid of configurable logic blocks that can be reprogrammed by the user after manufacturing.

###### **1.7.1 Key Differences**
*   **Programmability**: A CPU's hardware is fixed; it executes software. An FPGA's hardware itself is reconfigured to create a custom circuit.
*   **Instruction Set**: A CPU has a fixed instruction set defined by its manufacturer. An FPGA has no inherent instruction set; you design the digital logic circuits directly.
*   **Computation Speed**: For general tasks, CPUs are optimized and efficient. For highly specific, parallelizable tasks, an FPGA's custom hardware can be much faster.
*   **Power Consumption**: FPGAs typically consume more power than a CPU for the same task due to their programmable nature.
*   **Cost**: FPGAs are generally more expensive than mass-produced CPUs.

###### **1.7.2 Use Cases for FPGAs**
FPGAs are used for prototyping new processor designs, high-frequency trading, real-time signal processing, and other tasks requiring massive parallelism and low latency.

##### **1.8 FPGA Programming and Development Boards**
FPGAs are programmed using a **Hardware Description Language (HDL)** like **Verilog** or **VHDL**. These languages describe the structure of hardware circuits rather than a sequence of software instructions. A tool like **Intel Quartus Prime Lite** is used to synthesize the HDL code into a configuration file that is then loaded onto the FPGA.

Educational boards like the **DE10-Lite MAX 10** include an FPGA chip along with various I/O devices for hands-on learning, such as:

*   LEDs and Switches
*   Push Buttons
*   7-Segment Displays
*   VGA Output
*   Accelerometer (G-Sensor)
*   GPIO (General-Purpose Input/Output) pins

#### **2. Definitions**

*   **Computer**: An electronic device that processes data by executing a sequence of instructions defined in a program.
*   **Computer Architecture**: The design and operational structure of a computer system, defining its hardware components, their interconnections, and the hardware-software interface (the instruction set).
*   **CPU (Central Processing Unit)**: The component of a computer that executes program instructions and performs arithmetic, logic, and control operations.
*   **ALU (Arithmetic-Logic Unit)**: A digital circuit within the CPU that performs arithmetic and bitwise logic operations.
*   **CU (Control Unit)**: The component of the CPU that directs the processor by interpreting instructions and generating control signals.
*   **Register**: A small, high-speed storage location directly within the CPU.
*   **Instruction Set Architecture (ISA)**: The specific set of commands that a CPU can execute, acting as the interface between the hardware and the software.
*   **System Memory (RAM)**: Volatile memory that stores data and machine code currently in use.
*   **CPU Cache**: A small, fast volatile memory that stores copies of frequently used data from main memory to reduce access times.
*   **Memory Hierarchy**: A tiered structure of memory and storage devices that balances speed, cost, and capacity.
*   **FPGA (Field-Programmable Gate Array)**: An integrated circuit with configurable logic blocks and programmable interconnects that can be rewired by the user after manufacturing.
*   **Verilog HDL**: A hardware description language (HDL) used to model and design digital electronic systems.
*   **Multicore Processor**: A single CPU chip that contains two or more independent processing units called "cores."

#### **3. Mistakes**

*   **Confusing an FPGA with a CPU**: Treating an FPGA as just a "faster CPU." **Why it's wrong:** They are fundamentally different. A CPU is a fixed processor that runs software instructions, while an FPGA is a blank slate of configurable hardware. An FPGA is only faster for tasks that can be efficiently implemented in custom, parallel hardware.
*   **Ignoring the Memory Hierarchy**: Writing code without considering how data moves between CPU cache and main memory. **Why it's wrong:** The "memory wall"—the large speed gap between the CPU and RAM—is a primary performance bottleneck. Programs that access memory without locality will perform poorly as the CPU constantly stalls waiting for data.
*   **Treating Verilog like a software programming language**: Writing Verilog code sequentially and expecting it to execute line by line. **Why it's wrong:** Verilog is a hardware description language. It describes physical circuits that operate in parallel. This misunderstanding leads to designs that don't synthesize into working hardware or behave unexpectedly.
*   **Believing a processor's functionality can be changed with software**: Thinking you can add new hardware-level instructions to a CPU through a software update. **Why it's wrong:** A CPU's instruction set is physically etched into its silicon circuits during manufacturing and cannot be altered.
*   **Underestimating the Communication Bus**: Focusing only on CPU speed while ignoring the performance of the bus connecting the CPU to RAM. **Why it's wrong:** A slow bus will starve a fast CPU of data, creating a massive bottleneck. The entire system's performance depends on the ability of the bus to transfer data efficiently.

#### **4. Examples**

##### **4.1 Simple Logic in Verilog**
**Question:** Write a Verilog module that implements a simple AND gate. It should take two single-bit inputs, `a` and `b`, and produce one single-bit output, `y`.

<details>
<summary>Click to see the solution</summary>

1.  **Define the module:** Start by declaring a module with a name (e.g., `simple_and`) and list its input and output ports.
    ```verilog
    module simple_and(
        input  logic a,
        input  logic b,
        output logic y
    );
    ```
2.  **Assign the logic:** Use a continuous `assign` statement to describe the relationship between the inputs and the output. The `&` operator performs a bitwise AND operation.
    ```verilog
    assign y = a & b;
    ```
3.  **End the module:** Close the module definition.
    ```verilog
    endmodule
    ```

**Answer:** The complete Verilog module is:
```verilog
module simple_and(
    input  logic a,
    input  logic b,
    output logic y
);

assign y = a & b;

endmodule
```
</details>

##### **4.2 Controlling an LED with a Switch**
**Question:** On an FPGA board like the DE10-Lite, you have a switch (`SW0`) and an LED (`LED0`). Write a Verilog module to make the LED turn on when the switch is on, and turn off when the switch is off.

<details>
<summary>Click to see the solution</summary>

1.  **Define the module and ports:** Create a module named `led_control` with one input for the switch and one output for the LED.
    ```verilog
    module led_control(
        input  logic SW0,
        output logic LED0
    );
    ```
2.  **Connect the switch to the LED:** The simplest way to achieve this is to directly connect the input to the output. An `assign` statement creates a "wire" between the two.
    ```verilog
    assign LED0 = SW0;
    ```
3.  **End the module:** Close the module definition.
    ```verilog
    endmodule
    ```
**Answer:** The Verilog module directly connects the switch's state to the LED's state:
```verilog
module led_control(
    input  logic SW0,
    output logic LED0
);

assign LED0 = SW0;

endmodule
```
</details>

##### **4.3 CPU vs. FPGA Application Choice**
**Question:** You are designing a system for real-time video encoding that needs to process 4K video at 60 frames per second with very low latency. Would a general-purpose CPU or an FPGA be a better choice for the core processing unit? Explain why.

<details>
<summary>Click to see the solution</summary>

1.  **Analyze the task requirements:** The task involves processing a massive, continuous stream of data (4K video) with strict timing constraints (60 fps, low latency). The operations are highly repetitive and can be broken down into many small, parallel steps.
2.  **Evaluate the CPU's suitability:** A CPU would process the video frames using software. While powerful, it executes instructions sequentially (even with multiple cores) and has overhead from the operating system. Achieving consistent low latency for every single frame would be extremely challenging.
3.  **Evaluate the FPGA's suitability:** An FPGA can be configured to have a dedicated hardware pipeline for video processing. Multiple stages of the encoding algorithm can run simultaneously on different parts of the chip. This massive parallelism is ideal for video streams and guarantees consistent, low-latency processing.
**Answer:** An **FPGA** is the better choice. **Why:** Video encoding is a highly parallel task. An FPGA allows for the creation of a custom hardware pipeline where many calculations happen simultaneously, which is far more efficient and provides the low, predictable latency required for real-time processing, something a general-purpose CPU struggling with OS and other overheads cannot guarantee.
</details>

##### **4.4 Memory Hierarchy Access**
**Question:** A program is executing a `for` loop that repeatedly adds two numbers. The machine code instruction for the addition operation is currently being executed by the CPU. In which level of the memory hierarchy would you most likely find this instruction?

<details>
<summary>Click to see the solution</summary>

1.  **Consider the CPU's immediate needs:** The CPU can only execute instructions that are physically inside it.
2.  **Recall the fastest memory level:** The fastest and closest memory to the ALU and CU are the registers. The Control Unit fetches instructions from memory into a special-purpose register (often called the Instruction Register) just before decoding and execution.
3.  **Consider the role of cache:** Since the instruction is part of a loop, it's being used repeatedly. Therefore, it is almost certain to have been copied from the slower main memory (RAM) into the much faster L1 instruction cache for quick access on subsequent loop iterations.
4.  **Combine the points:** The instruction must be in a register to be executed. Given it's in a loop, it would also reside in the L1 cache to avoid fetching it from slow RAM every time. The most immediate location is a register.
**Answer:** The instruction would be found in a **CPU register** (specifically, the instruction register) at the moment of execution. A copy of it would also reside in the **L1 cache** for fast re-access during the next iteration of the loop.
</details>

##### **4.5 2-to-1 Multiplexer in Verilog**
**Question:** A 2-to-1 multiplexer (MUX) is a circuit that selects one of two inputs (`a` or `b`) to pass to the output (`y`) based on a selector signal (`sel`). If `sel` is 0, `y` should be `a`. If `sel` is 1, `y` should be `b`. Implement this in a Verilog module.

<details>
<summary>Click to see the solution</summary>

1.  **Define the module and its ports:** The module requires three inputs (`a`, `b`, `sel`) and one output (`y`).
    ```verilog
    module mux_2_to_1(
        input  logic a,
        input  logic b,
        input  logic sel,
        output logic y
    );
    ```
2.  **Implement the selection logic:** A conditional `assign` statement using the ternary operator (`? :`) is a concise way to model this. The structure is `condition ? value_if_true : value_if_false`.
    ```verilog
    assign y = (sel == 1) ? b : a;
    ```
    This line reads as: "Assign `y` the value of `b` if `sel` is 1; otherwise, assign it the value of `a`."
3.  **End the module:** Close the module definition.
    ```verilog
    endmodule
    ```
**Answer:** The complete Verilog module for a 2-to-1 MUX is:
```verilog
module mux_2_to_1(
    input  logic a,
    input  logic b,
    input  logic sel,
    output logic y
);

assign y = sel ? b : a; // A more compact way of writing (sel == 1)

endmodule
```
</details>

##### **4.6 Processor Instruction Set Limitation**
**Question:** Imagine a very simple processor whose instruction set only contains `ADD`, `SUBTRACT`, and `STORE`. You need to perform a multiplication, for example, 5 * 3. How could you accomplish this using only the available instructions?

<details>
<summary>Click to see the solution</summary>

1.  **Understand the core concept of multiplication:** Multiplication is repeated addition. For example, 5 * 3 is the same as 5 + 5 + 5.
2.  **Formulate an algorithm using available instructions:**
    *   Initialize a result variable (in a register, let's call it `R1`) to 0.
    *   Use the `ADD` instruction to add 5 to `R1`.
    *   Use the `ADD` instruction again to add 5 to `R1`. `R1` now holds 10.
    *   Use the `ADD` instruction a third time to add 5 to `R1`. `R1` now holds 15.
    *   Use the `STORE` instruction to save the value from `R1` to a memory location.
3.  **Structure the process:** This would be implemented as a software loop. The program would use the `ADD` instruction three times.
**Answer:** You can perform multiplication by implementing it as a series of additions. To calculate 5 * 3, you would write a short program that uses a loop to execute the `ADD 5` instruction three times, accumulating the result in a register.
</details>

##### **4.7 Identifying FPGA Board Components**
**Question:** You are looking at a DE10-Lite FPGA board. You see a large, square chip in the center labeled "MAX 10". What is the function of this component?

<details>
<summary>Click to see the solution</summary>
1.  **Analyze the component's description:** The chip is large, centrally located, and has a specific model name ("MAX 10").
2.  **Recall the purpose of an FPGA board:** The primary purpose of an FPGA development board is to provide a platform for programming and testing an FPGA.
3.  **Connect the information:** The central, most prominent chip on an FPGA board is almost always the FPGA itself. The "MAX 10" is a product family of FPGAs made by Altera (now Intel).
**Answer:** The chip labeled "MAX 10" is the **FPGA (Field-Programmable Gate Array)** itself. It is the main component that you program with your hardware design using a language like Verilog.
</details>