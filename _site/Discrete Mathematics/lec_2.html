<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.24">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Zakhar Podyakov">
<meta name="dcterms.date" content="2025-09-16">

<title>2. Logical Equivalence, Normal Forms (DNF, CNF, ANF) – InnoNotes</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-dc55a5b9e770e841cd82e46aadbfb9b0.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-42ed7287b56c5c583e2c2463c9cf4916.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar docked fullcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../Discrete Mathematics/lec_1.html">Discrete Mathematics</a></li><li class="breadcrumb-item"><a href="../Discrete Mathematics/lec_2.html">2. Logical Equivalence, Normal Forms (DNF, CNF, ANF)</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
      <a href="../index.html" class="sidebar-logo-link">
      </a>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Academic Writing and Argumentation</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Academic Writing and Argumentation/lec_1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">1. Effective Sentence Structure, Clauses, and Sentence Types</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Academic Writing and Argumentation/lec_2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">2. Principles of Effective Academic Writing</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Academic Writing and Argumentation/lec_3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">3. Sentence Problems, Punctuation</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Academic Writing and Argumentation/lec_4.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">4. Writing an Effective Paragraph, Paragraph Structure, Transitions</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Academic Writing and Argumentation/lec_5.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">5. Avoiding Plagiarism, Referencing, Summarizing, Paraphrasing</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Academic Writing and Argumentation/lec_6.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">6. Descriptive Paragraph</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true">
 <span class="menu-text">Analytical Geometry and Linear Algebra I</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Analytical Geometry and Linear Algebra I /lec_1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">1. Vectors, Vector Spaces, and Linear Independence</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Analytical Geometry and Linear Algebra I /lec_2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">2. Inner Product, Dot Product, Vector Norms, Orthogonality, Vector Projection</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Analytical Geometry and Linear Algebra I /lec_3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">3. Matrices and Determinants, Vector Cross Product, Scalar Triple Product</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true">
 <span class="menu-text">Computer Architecture</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Computer Architecture/lec_1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">1. Computer Architecture Fundamentals, CPU Components, Memory Hierarchy, FPGAs</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Computer Architecture/lec_2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">2. Fundamental Ideas of Computer Architecture</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" role="navigation" aria-expanded="true">
 <span class="menu-text">Discrete Mathematics</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-4" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Discrete Mathematics/lec_1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">1. Truth Tables, Disjunctive Normal Form (DNF), Conjunctive Normal Form (CNF)</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Discrete Mathematics/lec_2.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">2. Logical Equivalence, Normal Forms (DNF, CNF, ANF)</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" role="navigation" aria-expanded="true">
 <span class="menu-text">Introduction to Programming</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-5" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Introduction to Programming/lec_1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">1. Introduction to Programming and C, Compilation, Memory</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Introduction to Programming/lec_2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">2. Memory, Pointers, and Types</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Introduction to Programming/lec_3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">3. Pointers, Declarations, Preprocessing, and File I/O</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" role="navigation" aria-expanded="true">
 <span class="menu-text">Mathematical Analysis I</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-6" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Mathematical Analysis I/lec_1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">1. Set Theory, Complex Numbers, Mathematical Induction</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Mathematical Analysis I/lec_2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">2. Complex Numbers, Set Theory, Real Numbers, Mathematical Induction</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../Discrete Mathematics/lec_1.html">Discrete Mathematics</a></li><li class="breadcrumb-item"><a href="../Discrete Mathematics/lec_2.html">2. Logical Equivalence, Normal Forms (DNF, CNF, ANF)</a></li></ol></nav>
<div class="quarto-title">
<h1 class="title">2. Logical Equivalence, Normal Forms (DNF, CNF, ANF)</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Zakhar Podyakov </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">September 16, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="summary" class="level4">
<h4 class="anchored" data-anchor-id="summary">1. Summary</h4>
<section id="classification-of-logical-formulas" class="level5">
<h5 class="anchored" data-anchor-id="classification-of-logical-formulas">1.1 Classification of Logical Formulas</h5>
<p>In logic, any declarative statement, or <strong>proposition</strong>, can be classified based on its truth values across all possible scenarios.</p>
<ul>
<li>A <strong>Tautology</strong> is a formula that is <em>always true</em>, regardless of the truth values of its variables. For example, the formula <span class="math inline">\(p \lor \neg p\)</span> is a tautology because it is true whether <span class="math inline">\(p\)</span> is true or false.</li>
<li>A <strong>Contradiction</strong> is a formula that is <em>always false</em>. The formula <span class="math inline">\(p \land \neg p\)</span> is a contradiction.</li>
<li>A <strong>Contingency</strong> is a formula that is neither a tautology nor a contradiction. Its truth value <em>depends</em> on the truth values of its variables. For example, <span class="math inline">\(p \land q\)</span> is a contingency.</li>
</ul>
<p>A formula is considered <strong>satisfiable</strong> if there exists at least one assignment of truth values to its variables that makes the entire formula true. Both tautologies and contingencies are satisfiable, while contradictions are not.</p>
</section>
<section id="logical-equivalence" class="level5">
<h5 class="anchored" data-anchor-id="logical-equivalence">1.2 Logical Equivalence</h5>
<p>Two propositions, <span class="math inline">\(P_1\)</span> and <span class="math inline">\(P_2\)</span>, are <strong>logically equivalent</strong> if they have the exact same truth table. This means that for every possible combination of truth values for their variables, <span class="math inline">\(P_1\)</span> and <span class="math inline">\(P_2\)</span> will have the same resulting truth value. We denote this equivalence using the symbol <span class="math inline">\(\equiv\)</span>. For example, the implication <span class="math inline">\(a \rightarrow b\)</span> is logically equivalent to <span class="math inline">\(\neg a \lor b\)</span>, written as <span class="math inline">\(a \rightarrow b \equiv \neg a \lor b\)</span>.</p>
<p>Proving logical equivalence can be done by constructing a truth table for both expressions or by using a series of known equivalences (laws) to transform one expression into the other.</p>
</section>
<section id="key-logical-equivalences-laws" class="level5">
<h5 class="anchored" data-anchor-id="key-logical-equivalences-laws">1.3 Key Logical Equivalences (Laws)</h5>
<ul>
<li><strong>Identity Laws:</strong> <span class="math inline">\(p \lor F \equiv p\)</span>, <span class="math inline">\(p \land T \equiv p\)</span></li>
<li><strong>Domination Laws:</strong> <span class="math inline">\(p \lor T \equiv T\)</span>, <span class="math inline">\(p \land F \equiv F\)</span></li>
<li><strong>Idempotent Laws:</strong> <span class="math inline">\(p \lor p \equiv p\)</span>, <span class="math inline">\(p \land p \equiv p\)</span></li>
<li><strong>Double Negation Law:</strong> <span class="math inline">\(\neg(\neg p) \equiv p\)</span></li>
<li><strong>Commutative Laws:</strong> <span class="math inline">\(p \lor q \equiv q \lor p\)</span>, <span class="math inline">\(p \land q \equiv q \land p\)</span></li>
<li><strong>Associative Laws:</strong> <span class="math inline">\((p \lor q) \lor r \equiv p \lor (q \lor r)\)</span>, <span class="math inline">\((p \land q) \land r \equiv p \land (q \land r)\)</span></li>
<li><strong>Distributive Laws:</strong> <span class="math inline">\(p \lor (q \land r) \equiv (p \lor q) \land (p \lor r)\)</span>, <span class="math inline">\(p \land (q \lor r) \equiv (p \land q) \lor (p \land r)\)</span></li>
<li><strong>De Morgan’s Laws:</strong> These are crucial for simplifying negated expressions: <span class="math inline">\(\neg(p \land q) \equiv \neg p \lor \neg q\)</span> and <span class="math inline">\(\neg(p \lor q) \equiv \neg p \land \neg q\)</span>. <em>Correction from source material: The slides correctly apply the laws, but it’s important to state explicitly that the operator between the terms is also inverted (AND to OR, OR to AND).</em></li>
<li><strong>Absorption Laws:</strong> <span class="math inline">\(p \lor (p \land q) \equiv p\)</span>, <span class="math inline">\(p \land (p \lor q) \equiv p\)</span></li>
<li><strong>Implication Equivalence:</strong> <span class="math inline">\(p \rightarrow q \equiv \neg p \lor q\)</span></li>
<li><strong>Bi-implication Equivalence:</strong> <span class="math inline">\(p \leftrightarrow q \equiv (p \rightarrow q) \land (q \rightarrow p) \equiv (p \land q) \lor (\neg p \land \neg q)\)</span></li>
</ul>
</section>
<section id="normal-forms-dnf-and-cnf" class="level5">
<h5 class="anchored" data-anchor-id="normal-forms-dnf-and-cnf">1.4 Normal Forms: DNF and CNF</h5>
<p>A logical formula can be standardized into a <strong>normal form</strong>.</p>
<ul>
<li><strong>Disjunctive Normal Form (DNF):</strong> A formula is in DNF if it is a <em>disjunction (ORs) of conjunctions (ANDs)</em> of literals (a variable or its negation). A DNF expression can be derived from a truth table by taking every row where the formula is true and creating an AND clause that matches that row’s inputs. All these AND clauses are then ORed together. This is often called a “sum of products.”</li>
<li><strong>Conjunctive Normal Form (CNF):</strong> A formula is in CNF if it is a <em>conjunction (ANDs) of disjunctions (ORs)</em> of literals. A CNF expression can be derived from a truth table by taking every row where the formula is false, creating an OR clause from the <em>negation</em> of that row’s inputs, and then ANDing all these OR clauses together. This is often called a “product of sums.”</li>
</ul>
</section>
<section id="algebraic-normal-form-anf" class="level5">
<h5 class="anchored" data-anchor-id="algebraic-normal-form-anf">1.5 Algebraic Normal Form (ANF)</h5>
<p><strong>Algebraic Normal Form (ANF)</strong>, also known as a <strong>Zhegalkin polynomial</strong>, re-expresses a logical formula as a polynomial modulo 2. In this system, multiplication corresponds to the logical AND (<span class="math inline">\(\land\)</span>), and addition corresponds to the logical XOR (<span class="math inline">\(\oplus\)</span>).</p>
<p>The key translations are:</p>
<ul>
<li><span class="math inline">\(p \land q \equiv p \cdot q\)</span> (or simply <span class="math inline">\(pq\)</span>)</li>
<li><span class="math inline">\(p \oplus q\)</span> (XOR)</li>
<li><span class="math inline">\(\neg p \equiv p \oplus 1\)</span></li>
<li><span class="math inline">\(p \lor q \equiv p \oplus q \oplus pq\)</span></li>
<li><span class="math inline">\(p \rightarrow q \equiv 1 \oplus p \oplus pq\)</span></li>
<li><span class="math inline">\(p \leftrightarrow q \equiv 1 \oplus p \oplus q\)</span></li>
</ul>
<p>Any boolean expression can be uniquely converted into this polynomial form, which is useful in cryptography and circuit design.</p>
<hr>
</section>
</section>
<section id="definitions" class="level4">
<h4 class="anchored" data-anchor-id="definitions">2. Definitions</h4>
<ul>
<li><strong>Proposition</strong>: A declarative statement that is either true or false.</li>
<li><strong>Tautology</strong>: A logical formula that is true for all possible truth value assignments to its variables.</li>
<li><strong>Contradiction</strong>: A logical formula that is false for all possible truth value assignments.</li>
<li><strong>Contingency</strong>: A formula that can be either true or false, depending on the truth values of its variables.</li>
<li><strong>Satisfiable Formula</strong>: A formula for which there exists at least one assignment of truth values that makes the formula true.</li>
<li><strong>Logical Equivalence</strong>: The property of two formulas having identical truth tables.</li>
<li><strong>Literal</strong>: A propositional variable (e.g., <span class="math inline">\(p\)</span>) or its negation (e.g., <span class="math inline">\(\neg p\)</span>).</li>
<li><strong>Disjunctive Normal Form (DNF)</strong>: A logical formula represented as a disjunction of conjunctive clauses (e.g., <span class="math inline">\((p \land q) \lor (\neg r \land s)\)</span>).</li>
<li><strong>Conjunctive Normal Form (CNF)</strong>: A logical formula represented as a conjunction of disjunctive clauses (e.g., <span class="math inline">\((p \lor q) \land (\neg r \lor s)\)</span>).</li>
<li><strong>Algebraic Normal Form (ANF)</strong>: The representation of a logical function as a polynomial using AND (multiplication) and XOR (addition) operations modulo 2.</li>
</ul>
<hr>
</section>
<section id="formulas" class="level4">
<h4 class="anchored" data-anchor-id="formulas">3. Formulas</h4>
<ul>
<li><strong>Double Negation</strong>: <span class="math inline">\(\neg(\neg p) \equiv p\)</span></li>
<li><strong>De Morgan’s Laws</strong>:
<ul>
<li><span class="math inline">\(\neg(p \lor q) \equiv \neg p \land \neg q\)</span></li>
<li><span class="math inline">\(\neg(p \land q) \equiv \neg p \lor \neg q\)</span></li>
</ul></li>
<li><strong>Distributive Laws</strong>:
<ul>
<li><span class="math inline">\(p \land (q \lor r) \equiv (p \land q) \lor (p \land r)\)</span></li>
<li><span class="math inline">\(p \lor (q \land r) \equiv (p \lor q) \land (p \lor r)\)</span></li>
</ul></li>
<li><strong>Implication</strong>: <span class="math inline">\(p \rightarrow q \equiv \neg p \lor q\)</span></li>
<li><strong>Bi-implication</strong>: <span class="math inline">\(p \leftrightarrow q \equiv (p \land q) \lor (\neg p \land \neg q)\)</span></li>
<li><strong>Algebraic Normal Form (ANF) Conversions</strong>:
<ul>
<li><span class="math inline">\(\neg p \equiv p \oplus 1\)</span></li>
<li><span class="math inline">\(p \lor q \equiv p \oplus q \oplus pq\)</span></li>
<li><span class="math inline">\(p \land q \equiv pq\)</span></li>
<li><span class="math inline">\(p \rightarrow q \equiv 1 \oplus p \oplus pq\)</span></li>
<li><span class="math inline">\(p \leftrightarrow q \equiv 1 \oplus p \oplus q\)</span></li>
</ul></li>
<li><strong>ANF Properties (Modulo 2)</strong>:
<ul>
<li><span class="math inline">\(p \oplus p \equiv 0\)</span></li>
<li><span class="math inline">\(p \cdot p \equiv p\)</span></li>
</ul></li>
</ul>
<hr>
</section>
<section id="mistakes" class="level4">
<h4 class="anchored" data-anchor-id="mistakes">4. Mistakes</h4>
<ul>
<li><strong>Incorrectly applying De Morgan’s Law</strong>: A common mistake is to distribute the negation without flipping the operator. For example, writing <span class="math inline">\(\neg(a \lor b)\)</span> as <span class="math inline">\(\neg a \lor \neg b\)</span>. <strong>Why it’s wrong</strong>: De Morgan’s Law requires inverting the operator as well, so the correct form is <span class="math inline">\(\neg a \land \neg b\)</span>.</li>
<li><strong>Confusing XOR with OR in ANF</strong>: Translating <span class="math inline">\(a \lor b\)</span> as just <span class="math inline">\(a \oplus b\)</span>. <strong>Why it’s wrong</strong>: Logical OR is not equivalent to XOR. The correct ANF for OR is <span class="math inline">\(a \oplus b \oplus ab\)</span>. The term <span class="math inline">\(ab\)</span> corrects for the case where both <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> are true, as <span class="math inline">\(1 \oplus 1 = 0\)</span> but <span class="math inline">\(1 \lor 1 = 1\)</span>.</li>
<li><strong>Assuming Distributivity of XOR over AND</strong>: Believing that <span class="math inline">\(x \oplus (y \cdot z) \equiv (x \oplus y) \cdot (x \oplus z)\)</span>. <strong>Why it’s wrong</strong>: This property does not hold in Boolean algebra. As shown in the slides, a truth table for both sides yields different results. AND distributes over XOR, but not the other way around.</li>
<li><strong>Errors in CNF/DNF Simplification</strong>: Failing to apply the absorption law, <span class="math inline">\(a \lor (a \land b) \equiv a\)</span>. A student might leave the expression as is, thinking it’s fully simplified. <strong>Why it’s wrong</strong>: The absorption law shows that the term <span class="math inline">\((a \land b)\)</span> is redundant if <span class="math inline">\(a\)</span> is already present in a disjunction, leading to a simpler, equivalent formula.</li>
<li><strong>Forgetting to Negate Inputs for CNF</strong>: When deriving CNF from a truth table, one must create OR clauses for the rows where the output is FALSE. A common error is to use the variables directly instead of their negations. <strong>Why it’s wrong</strong>: To make the clause true (and thus not affect the outcome of the AND expression), you must ensure that the specific combination of false inputs evaluates to true in the clause. For a false row like <span class="math inline">\((a=0, b=1)\)</span>, the clause must be <span class="math inline">\((\neg a \lor b)\)</span> to be a valid part of the CNF. <em>Correction: The slide says for CNF use <span class="math inline">\((\neg a \lor b)\)</span> for the row where <code>a=1,b=0</code>. This is correct, as for that specific input combination (which makes the original function false), this clause also evaluates to false (<code>0 v 0 = 0</code>). The full CNF is a conjunction of such clauses that are <code>0</code> only on their specific false line.</em></li>
</ul>
<hr>
</section>
<section id="examples" class="level4">
<h4 class="anchored" data-anchor-id="examples">5. Examples</h4>
<section id="example-1-applying-de-morgans-laws" class="level5">
<h5 class="anchored" data-anchor-id="example-1-applying-de-morgans-laws">Example 1: Applying De Morgan’s Laws</h5>
<p><strong>Question:</strong> Apply negation and simplify the expression <span class="math inline">\((\neg a \lor b) \land (c \lor \neg d)\)</span> using De Morgan’s Laws.</p>
<details>
<summary>
Click to see the solution
</summary>
<ol type="1">
<li><strong>Apply negation to the entire expression:</strong> <span class="math display">\[ \neg ((\neg a \lor b) \land (c \lor \neg d)) \]</span></li>
<li><strong>Apply De Morgan’s Law to the central AND operator.</strong> This flips the AND to an OR and distributes the negation to the two parenthetical clauses. <span class="math display">\[ \neg(\neg a \lor b) \lor \neg(c \lor \neg d) \]</span></li>
<li><strong>Apply De Morgan’s Law to each of the two clauses.</strong>
<ul>
<li>For the first clause: <span class="math inline">\(\neg(\neg a \lor b) \equiv \neg(\neg a) \land \neg b\)</span></li>
<li>For the second clause: <span class="math inline">\(\neg(c \lor \neg d) \equiv \neg c \land \neg(\neg d)\)</span></li>
</ul></li>
<li><strong>Simplify using the Double Negation law</strong> (<span class="math inline">\(\neg(\neg p) \equiv p\)</span>).
<ul>
<li>First clause becomes: <span class="math inline">\(a \land \neg b\)</span></li>
<li>Second clause becomes: <span class="math inline">\(\neg c \land d\)</span></li>
</ul></li>
<li><strong>Combine the simplified clauses with the OR from step 2.</strong></li>
</ol>
<strong>Answer:</strong> The simplified expression is <strong><span class="math inline">\((a \land \neg b) \lor (\neg c \land d)\)</span></strong>.
</details>
</section>
<section id="example-2-finding-and-simplifying-dnf" class="level5">
<h5 class="anchored" data-anchor-id="example-2-finding-and-simplifying-dnf">Example 2: Finding and Simplifying DNF</h5>
<p><strong>Question:</strong> Find the Disjunctive Normal Form (DNF) for a function <span class="math inline">\(\Phi(x, y, z)\)</span> with the truth table vector <span class="math inline">\((01111110)\)</span> and simplify it. (The vector represents the function’s output for inputs <span class="math inline">\(xyz=000, 001, ..., 111\)</span>).</p>
<details>
<summary>
Click to see the solution
</summary>
<ol type="1">
<li><strong>Identify rows where the output is 1.</strong> These correspond to the minterms.
<ul>
<li><span class="math inline">\(xyz=001\)</span>: <span class="math inline">\(\neg x \land \neg y \land z\)</span></li>
<li><span class="math inline">\(xyz=010\)</span>: <span class="math inline">\(\neg x \land y \land \neg z\)</span></li>
<li><span class="math inline">\(xyz=011\)</span>: <span class="math inline">\(\neg x \land y \land z\)</span></li>
<li><span class="math inline">\(xyz=100\)</span>: <span class="math inline">\(x \land \neg y \land \neg z\)</span></li>
<li><span class="math inline">\(xyz=101\)</span>: <span class="math inline">\(x \land \neg y \land z\)</span></li>
<li><span class="math inline">\(xyz=110\)</span>: <span class="math inline">\(x \land y \land \neg z\)</span></li>
</ul></li>
<li><strong>Write the full DNF by ORing all minterms:</strong> <span class="math display">\[ (\neg x \land \neg y \land z) \lor (\neg x \land y \land \neg z) \lor (\neg x \land y \land z) \lor (x \land \neg y \land \neg z) \lor (x \land \neg y \land z) \lor (x \land y \land \neg z) \]</span></li>
<li><strong>Simplify by grouping terms.</strong>
<ul>
<li>Group <span class="math inline">\((\neg x \land y \land \neg z) \lor (\neg x \land y \land z) \rightarrow \neg x \land y\)</span></li>
<li>Group <span class="math inline">\((\neg x \land \neg y \land z) \lor (\neg x \land y \land z) \rightarrow \neg x \land z\)</span></li>
<li>Group <span class="math inline">\((x \land \neg y \land z) \lor (\neg x \land \neg y \land z) \rightarrow \neg y \land z\)</span></li>
<li>It is often easier to derive the CNF for the ‘0’ cases and then negate. The function is 0 for <span class="math inline">\(xyz=000\)</span> and <span class="math inline">\(xyz=111\)</span>.</li>
</ul></li>
<li><strong>Alternative (easier) Method:</strong> Find CNF of the zeros and apply De Morgan’s law.
<ul>
<li>The function is 0 for <span class="math inline">\(xyz=000\)</span> and <span class="math inline">\(xyz=111\)</span>.</li>
<li>The CNF of the function is <span class="math inline">\((x \lor y \lor z) \land (\neg x \lor \neg y \lor \neg z)\)</span>.</li>
<li>The DNF of the <em>negation</em> is <span class="math inline">\((\neg x \land \neg y \land \neg z) \lor (x \land y \land z)\)</span>.</li>
<li>Negating this gives back the original function’s DNF: <span class="math inline">\(\neg((\neg x \land \neg y \land \neg z) \lor (x \land y \land z)) \equiv (x \lor y \lor z) \land (\neg x \lor \neg y \lor \neg z)\)</span>, which is the CNF. Let’s return to simplifying the DNF directly.</li>
</ul></li>
<li><strong>Simplify the full DNF using consensus or algebraic manipulation.</strong>
<ul>
<li><span class="math inline">\((\neg x \land \neg y \land z) \lor (\neg x \land y \land z) = \neg x \land z\)</span></li>
<li><span class="math inline">\((\neg x \land y \land \neg z) \lor (x \land y \land \neg z) = y \land \neg z\)</span></li>
<li><span class="math inline">\((x \land \neg y \land \neg z) \lor (x \land \neg y \land z) = x \land \neg y\)</span></li>
<li>The simplified expression is the OR of these three terms.</li>
</ul></li>
</ol>
<strong>Answer:</strong> The simplified DNF is <strong><span class="math inline">\((\neg x \land z) \lor (y \land \neg z) \lor (x \land \neg y)\)</span></strong>.
</details>
</section>
<section id="example-3-finding-and-simplifying-cnf" class="level5">
<h5 class="anchored" data-anchor-id="example-3-finding-and-simplifying-cnf">Example 3: Finding and Simplifying CNF</h5>
<p><strong>Question:</strong> Find the Conjunctive Normal Form (CNF) for a function <span class="math inline">\(\Psi(x, y, z)\)</span> with the truth table vector <span class="math inline">\((00110000)\)</span> and simplify it.</p>
<details>
<summary>
Click to see the solution
</summary>
<ol type="1">
<li><strong>Identify rows where the output is 0.</strong> These will form the clauses of the CNF.
<ul>
<li><span class="math inline">\(xyz=000\)</span>: Clause is <span class="math inline">\((x \lor y \lor z)\)</span></li>
<li><span class="math inline">\(xyz=001\)</span>: Clause is <span class="math inline">\((x \lor y \lor \neg z)\)</span></li>
<li><span class="math inline">\(xyz=100\)</span>: Clause is <span class="math inline">\((\neg x \lor y \lor z)\)</span></li>
<li><span class="math inline">\(xyz=101\)</span>: Clause is <span class="math inline">\((\neg x \lor y \lor \neg z)\)</span></li>
<li><span class="math inline">\(xyz=110\)</span>: Clause is <span class="math inline">\((\neg x \lor \neg y \lor z)\)</span></li>
<li><span class="math inline">\(xyz=111\)</span>: Clause is <span class="math inline">\((\neg x \lor \neg y \lor \neg z)\)</span></li>
</ul></li>
<li><strong>Write the full CNF by ANDing all clauses:</strong> <span class="math display">\[ (x \lor y \lor z) \land (x \lor y \lor \neg z) \land (\neg x \lor y \lor z) \land (\neg x \lor y \lor \neg z) \land (\neg x \lor \neg y \lor z) \land (\neg x \lor \neg y \lor \neg z) \]</span></li>
<li><strong>Simplify by grouping terms using the rule <span class="math inline">\((A \lor B) \land (A \lor \neg B) \equiv A\)</span>.</strong>
<ul>
<li>Group 1 &amp; 2: <span class="math inline">\((x \lor y \lor z) \land (x \lor y \lor \neg z) \equiv (x \lor y)\)</span></li>
<li>Group 3 &amp; 4: <span class="math inline">\((\neg x \lor y \lor z) \land (\neg x \lor y \lor \neg z) \equiv (\neg x \lor y)\)</span></li>
<li>Group 5 &amp; 6: <span class="math inline">\((\neg x \lor \neg y \lor z) \land (\neg x \lor \neg y \lor \neg z) \equiv (\neg x \lor \neg y)\)</span></li>
</ul></li>
<li><strong>Combine the results:</strong> <span class="math display">\[ (x \lor y) \land (\neg x \lor y) \land (\neg x \lor \neg y) \]</span></li>
<li><strong>Simplify further.</strong>
<ul>
<li>Group the first two simplified clauses: <span class="math inline">\((x \lor y) \land (\neg x \lor y) \equiv y\)</span>.</li>
<li>Now we have: <span class="math inline">\(y \land (\neg x \lor \neg y)\)</span>.</li>
</ul></li>
<li><strong>Apply the distributive law:</strong> <span class="math display">\[ (y \land \neg x) \lor (y \land \neg y) \]</span></li>
<li>Since <span class="math inline">\((y \land \neg y) \equiv F\)</span> (contradiction), the expression simplifies to the first term.</li>
</ol>
<strong>Answer:</strong> The simplified CNF is <strong><span class="math inline">\(y \land \neg x\)</span></strong>. <em>(The DNF would be the same)</em>.
</details>
</section>
<section id="example-4-converting-to-algebraic-normal-form-anf" class="level5">
<h5 class="anchored" data-anchor-id="example-4-converting-to-algebraic-normal-form-anf">Example 4: Converting to Algebraic Normal Form (ANF)</h5>
<p><strong>Question:</strong> Find the Algebraic Normal Form for the expression <span class="math inline">\((a \rightarrow \neg b) \land (b \rightarrow a)\)</span>.</p>
<details>
<summary>
Click to see the solution
</summary>
<ol type="1">
<li><strong>Translate each part of the expression into its ANF equivalent.</strong>
<ul>
<li>First, translate the implications:
<ul>
<li><span class="math inline">\(a \rightarrow \neg b\)</span>: The formula for implication <span class="math inline">\(x \rightarrow y\)</span> is <span class="math inline">\(1 \oplus x \oplus xy\)</span>. Here, <span class="math inline">\(x=a\)</span> and <span class="math inline">\(y=\neg b\)</span>.</li>
<li><span class="math inline">\(b \rightarrow a\)</span>: Here, <span class="math inline">\(x=b\)</span> and <span class="math inline">\(y=a\)</span>. So it becomes <span class="math inline">\(1 \oplus b \oplus ba\)</span>.</li>
</ul></li>
</ul></li>
<li><strong>Substitute the ANF for negation.</strong> The formula for negation <span class="math inline">\(\neg y\)</span> is <span class="math inline">\(y \oplus 1\)</span>.
<ul>
<li><span class="math inline">\(\neg b \equiv b \oplus 1\)</span>.</li>
</ul></li>
<li><strong>Substitute back into the first implication.</strong>
<ul>
<li><span class="math inline">\(a \rightarrow \neg b \equiv 1 \oplus a \oplus a(\neg b) \equiv 1 \oplus a \oplus a(b \oplus 1)\)</span></li>
<li>Distribute <span class="math inline">\(a\)</span>: <span class="math inline">\(1 \oplus a \oplus (ab \oplus a)\)</span></li>
<li>Since <span class="math inline">\(a \oplus a = 0\)</span>, this simplifies to <span class="math inline">\(1 \oplus ab\)</span>.</li>
</ul></li>
<li><strong>The full expression is the AND (multiplication) of the two translated parts.</strong> <span class="math display">\[ (1 \oplus ab) \cdot (1 \oplus b \oplus ab) \]</span></li>
<li><strong>Expand the polynomial (multiply the terms).</strong> <span class="math display">\[ 1(1 \oplus b \oplus ab) \oplus ab(1 \oplus b \oplus ab) \]</span> <span class="math display">\[ (1 \oplus b \oplus ab) \oplus (ab \oplus ab^2 \oplus a^2b^2) \]</span></li>
<li><strong>Simplify using modulo 2 rules: <span class="math inline">\(x \oplus x = 0\)</span> and <span class="math inline">\(x^2 = x\)</span>.</strong>
<ul>
<li><span class="math inline">\(ab^2 = ab\)</span> and <span class="math inline">\(a^2b^2 = ab\)</span>.</li>
<li>The expression becomes: <span class="math inline">\(1 \oplus b \oplus ab \oplus ab \oplus ab \oplus ab\)</span></li>
</ul></li>
<li><strong>Cancel out pairs.</strong>
<ul>
<li><span class="math inline">\(ab \oplus ab = 0\)</span>. We have two such pairs.</li>
<li>The expression simplifies to: <span class="math inline">\(1 \oplus b\)</span>.</li>
</ul></li>
</ol>
<strong>Answer:</strong> The ANF is <strong><span class="math inline">\(1 \oplus b\)</span></strong> (which is equivalent to <span class="math inline">\(\neg b\)</span>).
</details>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>